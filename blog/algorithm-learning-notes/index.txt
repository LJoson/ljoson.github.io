2:I[313,["754","static/chunks/754-2d7956d0ca320083.js","308","static/chunks/app/blog/%5Bslug%5D/page-4898a743cdf7fc4a.js"],"BlogDetail"]
4:I[1270,["754","static/chunks/754-2d7956d0ca320083.js","308","static/chunks/app/blog/%5Bslug%5D/page-4898a743cdf7fc4a.js"],"BlogSidebar"]
5:I[4420,["754","static/chunks/754-2d7956d0ca320083.js","308","static/chunks/app/blog/%5Bslug%5D/page-4898a743cdf7fc4a.js"],"RelatedPosts"]
b:I[4707,[],""]
d:I[6423,[],""]
e:I[3529,["185","static/chunks/app/layout-f6c41656a6971b66.js"],"ThemeProvider"]
f:I[4326,["185","static/chunks/app/layout-f6c41656a6971b66.js"],"ClientLayout"]
10:I[3164,["185","static/chunks/app/layout-f6c41656a6971b66.js"],"PageTransition"]
11:I[3157,["185","static/chunks/app/layout-f6c41656a6971b66.js"],"Header"]
12:I[3490,["601","static/chunks/app/error-aca96ac5bb368170.js"],"default"]
13:I[5447,["160","static/chunks/app/not-found-b4a85d88d4259f8a.js"],"default"]
14:I[2063,["185","static/chunks/app/layout-f6c41656a6971b66.js"],"Footer"]
15:I[9615,["555","static/chunks/app/loading-14670c1b72ad4c70.js"],"default"]
3:T900f,
# ç®—æ³•å­¦ä¹ ç¬”è®°ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•æ€ç»´è¿›åŒ–å²

> ä»"æš´åŠ›è§£æ³•"åˆ°"ä¼˜é›…ç®—æ³•"ï¼Œæˆ‘çš„ç®—æ³•æ€ç»´è¿›åŒ–ä¹‹è·¯

## æˆ‘ä¸ç®—æ³•çš„"ç›¸çˆ±ç›¸æ€"

### ç¬¬ä¸€æ¬¡"ç¿»è½¦"ï¼šæš´åŠ›è§£æ³•çš„ç¾éš¾

è¿˜è®°å¾—ç¬¬ä¸€æ¬¡é‡åˆ°ç®—æ³•é¢˜æ—¶ï¼Œæˆ‘ä¿¡å¿ƒæ»¡æ»¡åœ°å¼€å§‹ç¼–ç ï¼š

```python
# æˆ‘çš„ç¬¬ä¸€ä¸ª"æ°ä½œ" - æš´åŠ›è§£æ³•
def find_max_subarray(arr):
    max_sum = float('-inf')
    max_start = 0
    max_end = 0

    # æš´åŠ›æšä¸¾æ‰€æœ‰å­æ•°ç»„
    for i in range(len(arr)):
        for j in range(i, len(arr)):
            current_sum = sum(arr[i:j+1])  # æ¯æ¬¡éƒ½é‡æ–°è®¡ç®—
            if current_sum > max_sum:
                max_sum = current_sum
                max_start = i
                max_end = j

    return max_sum, max_start, max_end

# æµ‹è¯•
arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
result = find_max_subarray(arr)
print(f"æœ€å¤§å­æ•°ç»„å’Œ: {result[0]}, èµ·å§‹ä½ç½®: {result[1]}, ç»“æŸä½ç½®: {result[2]}")
```

ç»“æœå‘¢ï¼Ÿæ—¶é—´å¤æ‚åº¦O(nÂ³)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ï¼Œå°æ•°ç»„è¿˜èƒ½è·‘ï¼Œå¤§æ•°ç»„ç›´æ¥è¶…æ—¶ã€‚å¯¼å¸ˆçœ‹åˆ°åç›´æ¥ç»™æˆ‘å‘äº†ä¸ª"ğŸ¤¦â€â™‚ï¸"çš„è¡¨æƒ…ï¼š"ä½ è¿™æ˜¯åœ¨åš'æš´åŠ›ç®—æ³•ç¾éš¾'å—ï¼Ÿ"

### ç¬¬äºŒæ¬¡å°è¯•ï¼šä¼˜åŒ–ç®—æ³•çš„è§‰é†’

å¥½ä¸å®¹æ˜“å­¦ä¼šäº†åŠ¨æ€è§„åˆ’ï¼Œæˆ‘åˆå¼€å§‹æŒ‘æˆ˜ä¼˜åŒ–ç®—æ³•ï¼š

```python
# æˆ‘çš„"ä¼˜åŒ–ç®—æ³•"æ°ä½œ
def find_max_subarray_dp(arr):
    if not arr:
        return 0, -1, -1

    n = len(arr)
    dp = [0] * n  # dp[i]è¡¨ç¤ºä»¥arr[i]ç»“å°¾çš„æœ€å¤§å­æ•°ç»„å’Œ
    dp[0] = arr[0]

    max_sum = dp[0]
    max_end = 0

    # åŠ¨æ€è§„åˆ’
    for i in range(1, n):
        dp[i] = max(arr[i], dp[i-1] + arr[i])
        if dp[i] > max_sum:
            max_sum = dp[i]
            max_end = i

    # å›æº¯æ‰¾åˆ°èµ·å§‹ä½ç½®
    max_start = max_end
    current_sum = max_sum
    while max_start > 0 and current_sum > 0:
        current_sum -= arr[max_start]
        max_start -= 1

    return max_sum, max_start + 1, max_end

# æµ‹è¯•
arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
result = find_max_subarray_dp(arr)
print(f"æœ€å¤§å­æ•°ç»„å’Œ: {result[0]}, èµ·å§‹ä½ç½®: {result[1]}, ç»“æŸä½ç½®: {result[2]}")
```

è¿™æ¬¡å¥½å¤šäº†ï¼æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ï¼Œä½†ä»£ç å¤æ‚åº¦ç›´çº¿ä¸Šå‡ï¼Œè°ƒè¯•å›°éš¾ã€‚æˆ‘çš„"ä¼˜åŒ–ç®—æ³•"å˜æˆäº†"å¤æ‚ä»£ç "ã€‚

### è§‰é†’æ—¶åˆ»ï¼šç®—æ³•ä¸æ˜¯ä»£ç ï¼Œæ˜¯æ€ç»´

ç»è¿‡æ— æ•°æ¬¡çš„"ç¿»è½¦"ç»å†ï¼Œæˆ‘ç»ˆäºæ˜ç™½ï¼šç®—æ³•ä¸ä»…ä»…æ˜¯ä»£ç ï¼Œæ›´æ˜¯ä¸€ç§æ€ç»´æ–¹å¼ã€‚å…³é”®æ˜¯è¦ç†è§£é—®é¢˜çš„æœ¬è´¨ï¼Œæ‰¾åˆ°æœ€ä¼˜çš„è§£å†³æ–¹æ¡ˆã€‚

## ç®—æ³•æ€ç»´ï¼šä»é—®é¢˜åˆ°è§£å†³æ–¹æ¡ˆ

### 1. é—®é¢˜åˆ†æï¼šç†è§£é—®é¢˜çš„æœ¬è´¨

#### é—®é¢˜åˆ†ç±»æ€ç»´

**å¸¸è§é—®é¢˜ç±»å‹ï¼š**
```python
# é—®é¢˜åˆ†ç±»æ¡†æ¶
class ProblemAnalyzer:
    def __init__(self):
        self.problem_types = {
            'array': ['æ’åº', 'æŸ¥æ‰¾', 'å­æ•°ç»„', 'æ’åˆ—ç»„åˆ'],
            'string': ['åŒ¹é…', 'ç¼–è¾‘è·ç¦»', 'å›æ–‡', 'å­åºåˆ—'],
            'tree': ['éå†', 'è·¯å¾„', 'æ„é€ ', 'éªŒè¯'],
            'graph': ['æœç´¢', 'æœ€çŸ­è·¯å¾„', 'è¿é€šæ€§', 'æ‹“æ‰‘æ’åº'],
            'dynamic_programming': ['èƒŒåŒ…', 'åºåˆ—', 'çŸ©é˜µ', 'çŠ¶æ€å‹ç¼©']
        }

    def classify_problem(self, problem_description):
        """æ ¹æ®é—®é¢˜æè¿°åˆ†ç±»é—®é¢˜ç±»å‹"""
        keywords = problem_description.lower().split()

        for category, types in self.problem_types.items():
            for problem_type in types:
                if any(keyword in problem_type for keyword in keywords):
                    return category, problem_type

        return 'unknown', 'unknown'

    def suggest_approach(self, category, problem_type):
        """æ ¹æ®é—®é¢˜ç±»å‹å»ºè®®è§£é¢˜æ€è·¯"""
        approaches = {
            'array': {
                'æ’åº': ['å¿«é€Ÿæ’åº', 'å½’å¹¶æ’åº', 'å †æ’åº'],
                'æŸ¥æ‰¾': ['äºŒåˆ†æŸ¥æ‰¾', 'å“ˆå¸Œè¡¨', 'åŒæŒ‡é’ˆ'],
                'å­æ•°ç»„': ['æ»‘åŠ¨çª—å£', 'å‰ç¼€å’Œ', 'åŠ¨æ€è§„åˆ’'],
                'æ’åˆ—ç»„åˆ': ['å›æº¯', 'é€’å½’', 'æ•°å­¦å…¬å¼']
            },
            'string': {
                'åŒ¹é…': ['KMPç®—æ³•', 'Rabin-Karp', 'æ­£åˆ™è¡¨è¾¾å¼'],
                'ç¼–è¾‘è·ç¦»': ['åŠ¨æ€è§„åˆ’', 'çŠ¶æ€è½¬ç§»'],
                'å›æ–‡': ['ä¸­å¿ƒæ‰©å±•', 'Manacherç®—æ³•'],
                'å­åºåˆ—': ['åŠ¨æ€è§„åˆ’', 'LCSç®—æ³•']
            },
            'tree': {
                'éå†': ['DFS', 'BFS', 'ä¸­åºéå†'],
                'è·¯å¾„': ['æ·±åº¦ä¼˜å…ˆæœç´¢', 'è·¯å¾„è®°å½•'],
                'æ„é€ ': ['é€’å½’æ„é€ ', 'åˆ†æ²»æ€æƒ³'],
                'éªŒè¯': ['æ€§è´¨éªŒè¯', 'éå†éªŒè¯']
            }
        }

        return approaches.get(category, {}).get(problem_type, ['æš´åŠ›è§£æ³•'])

# ä½¿ç”¨ç¤ºä¾‹
analyzer = ProblemAnalyzer()
problem = "ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°å’Œæœ€å¤§çš„è¿ç»­å­æ•°ç»„"
category, problem_type = analyzer.classify_problem(problem)
approaches = analyzer.suggest_approach(category, problem_type)
print(f"é—®é¢˜ç±»å‹: {category} - {problem_type}")
print(f"å»ºè®®æ€è·¯: {approaches}")
```

#### å¤æ‚åº¦åˆ†ææ€ç»´

**ç®—æ³•å¤æ‚åº¦è¯„ä¼°ï¼š**
```python
# å¤æ‚åº¦åˆ†æå·¥å…·
class ComplexityAnalyzer:
    def __init__(self):
        self.complexity_patterns = {
            'O(1)': ['å¸¸æ•°æ—¶é—´', 'å“ˆå¸Œè¡¨æŸ¥æ‰¾', 'æ•°ç»„ç´¢å¼•'],
            'O(log n)': ['äºŒåˆ†æŸ¥æ‰¾', 'æ ‘çš„é«˜åº¦', 'åˆ†æ²»ç®—æ³•'],
            'O(n)': ['çº¿æ€§éå†', 'æ»‘åŠ¨çª—å£', 'åŒæŒ‡é’ˆ'],
            'O(n log n)': ['æ’åºç®—æ³•', 'åˆ†æ²»+åˆå¹¶'],
            'O(nÂ²)': ['åŒé‡å¾ªç¯', 'æš´åŠ›è§£æ³•', 'å†’æ³¡æ’åº'],
            'O(2â¿)': ['é€’å½’', 'å›æº¯', 'ç»„åˆé—®é¢˜'],
            'O(n!)': ['æ’åˆ—', 'å…¨æ’åˆ—', 'æ—…è¡Œå•†é—®é¢˜']
        }

    def analyze_time_complexity(self, code):
        """åˆ†æä»£ç çš„æ—¶é—´å¤æ‚åº¦"""
        lines = code.split('\n')
        max_nested_loops = 0
        current_nesting = 0

        for line in lines:
            if 'for' in line or 'while' in line:
                current_nesting += 1
                max_nested_loops = max(max_nested_loops, current_nesting)
            elif line.strip().startswith('}'):
                current_nesting = max(0, current_nesting - 1)

        complexity_map = {
            0: 'O(1)',
            1: 'O(n)',
            2: 'O(nÂ²)',
            3: 'O(nÂ³)'
        }

        return complexity_map.get(max_nested_loops, f'O(n^{max_nested_loops})')

    def analyze_space_complexity(self, code):
        """åˆ†æä»£ç çš„ç©ºé—´å¤æ‚åº¦"""
        # ç®€å•çš„ç©ºé—´å¤æ‚åº¦åˆ†æ
        if 'dp = [0] * n' in code or 'memo = {}' in code:
            return 'O(n)'
        elif 'matrix = [[0] * n for _ in range(n)]' in code:
            return 'O(nÂ²)'
        elif 'stack = []' in code or 'queue = []' in code:
            return 'O(n)'
        else:
            return 'O(1)'

# ä½¿ç”¨ç¤ºä¾‹
analyzer = ComplexityAnalyzer()
code = """
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
"""

time_complexity = analyzer.analyze_time_complexity(code)
space_complexity = analyzer.analyze_space_complexity(code)
print(f"æ—¶é—´å¤æ‚åº¦: {time_complexity}")
print(f"ç©ºé—´å¤æ‚åº¦: {space_complexity}")
```

### 2. è§£é¢˜ç­–ç•¥ï¼šä»æš´åŠ›åˆ°ä¼˜åŒ–

#### æš´åŠ›è§£æ³•ï¼šç†è§£é—®é¢˜çš„ç¬¬ä¸€æ­¥

**æš´åŠ›è§£æ³•çš„ä»·å€¼ï¼š**
```python
# æš´åŠ›è§£æ³•æ¨¡æ¿
class BruteForceSolver:
    def __init__(self):
        self.solutions = []

    def solve_two_sum_brute(self, nums, target):
        """ä¸¤æ•°ä¹‹å’Œ - æš´åŠ›è§£æ³•"""
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] + nums[j] == target:
                    return [i, j]
        return []

    def solve_three_sum_brute(self, nums):
        """ä¸‰æ•°ä¹‹å’Œ - æš´åŠ›è§£æ³•"""
        n = len(nums)
        result = []

        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j + 1, n):
                    if nums[i] + nums[j] + nums[k] == 0:
                        triplet = sorted([nums[i], nums[j], nums[k]])
                        if triplet not in result:
                            result.append(triplet)

        return result

    def solve_permutations_brute(self, nums):
        """å…¨æ’åˆ— - æš´åŠ›è§£æ³•"""
        if len(nums) <= 1:
            return [nums]

        result = []
        for i in range(len(nums)):
            current = nums[i]
            remaining = nums[:i] + nums[i+1:]

            for perm in self.solve_permutations_brute(remaining):
                result.append([current] + perm)

        return result

# æš´åŠ›è§£æ³•çš„ä»·å€¼
def demonstrate_brute_force_value():
    """æ¼”ç¤ºæš´åŠ›è§£æ³•çš„ä»·å€¼"""
    solver = BruteForceSolver()

    # 1. ç†è§£é—®é¢˜
    print("=== ç†è§£é—®é¢˜ ===")
    nums = [2, 7, 11, 15]
    target = 9
    result = solver.solve_two_sum_brute(nums, target)
    print(f"ä¸¤æ•°ä¹‹å’Œ: {nums}, ç›®æ ‡: {target}, ç»“æœ: {result}")

    # 2. éªŒè¯æ­£ç¡®æ€§
    print("\n=== éªŒè¯æ­£ç¡®æ€§ ===")
    test_cases = [
        ([2, 7, 11, 15], 9),
        ([3, 2, 4], 6),
        ([3, 3], 6)
    ]

    for nums, target in test_cases:
        result = solver.solve_two_sum_brute(nums, target)
        if result:
            actual_sum = nums[result[0]] + nums[result[1]]
            print(f"è¾“å…¥: {nums}, ç›®æ ‡: {target}, ç»“æœ: {result}, éªŒè¯: {actual_sum == target}")

    # 3. æ€§èƒ½åŸºå‡†
    print("\n=== æ€§èƒ½åŸºå‡† ===")
    import time
    large_nums = list(range(1000))
    start_time = time.time()
    result = solver.solve_two_sum_brute(large_nums, 1998)
    end_time = time.time()
    print(f"å¤§æ•°ç»„æš´åŠ›è§£æ³•è€—æ—¶: {end_time - start_time:.4f}ç§’")

demonstrate_brute_force_value()
```

#### ä¼˜åŒ–ç­–ç•¥ï¼šä»æš´åŠ›åˆ°ä¼˜é›…

**å¸¸è§ä¼˜åŒ–ç­–ç•¥ï¼š**
```python
# ä¼˜åŒ–ç­–ç•¥æ¨¡æ¿
class OptimizationStrategies:
    def __init__(self):
        self.strategies = {
            'two_pointers': 'åŒæŒ‡é’ˆæŠ€å·§',
            'sliding_window': 'æ»‘åŠ¨çª—å£',
            'binary_search': 'äºŒåˆ†æŸ¥æ‰¾',
            'dynamic_programming': 'åŠ¨æ€è§„åˆ’',
            'greedy': 'è´ªå¿ƒç®—æ³•',
            'divide_conquer': 'åˆ†æ²»ç®—æ³•'
        }

    def two_sum_optimized(self, nums, target):
        """ä¸¤æ•°ä¹‹å’Œ - å“ˆå¸Œè¡¨ä¼˜åŒ–"""
        num_map = {}

        for i, num in enumerate(nums):
            complement = target - num
            if complement in num_map:
                return [num_map[complement], i]
            num_map[num] = i

        return []

    def three_sum_optimized(self, nums):
        """ä¸‰æ•°ä¹‹å’Œ - åŒæŒ‡é’ˆä¼˜åŒ–"""
        nums.sort()
        result = []
        n = len(nums)

        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            left, right = i + 1, n - 1
            while left < right:
                total = nums[i] + nums[left] + nums[right]

                if total == 0:
                    result.append([nums[i], nums[left], nums[right]])

                    # è·³è¿‡é‡å¤å…ƒç´ 
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1

                    left += 1
                    right -= 1
                elif total < 0:
                    left += 1
                else:
                    right -= 1

        return result

    def max_subarray_optimized(self, nums):
        """æœ€å¤§å­æ•°ç»„å’Œ - Kadaneç®—æ³•"""
        if not nums:
            return 0

        max_sum = current_sum = nums[0]

        for num in nums[1:]:
            current_sum = max(num, current_sum + num)
            max_sum = max(max_sum, current_sum)

        return max_sum

    def longest_increasing_subsequence(self, nums):
        """æœ€é•¿é€’å¢å­åºåˆ— - åŠ¨æ€è§„åˆ’ä¼˜åŒ–"""
        if not nums:
            return 0

        n = len(nums)
        dp = [1] * n

        for i in range(1, n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)

        return max(dp)

# ä¼˜åŒ–æ•ˆæœå¯¹æ¯”
def compare_optimization_effects():
    """å¯¹æ¯”ä¼˜åŒ–æ•ˆæœ"""
    strategies = OptimizationStrategies()

    # ä¸¤æ•°ä¹‹å’Œå¯¹æ¯”
    print("=== ä¸¤æ•°ä¹‹å’Œä¼˜åŒ–å¯¹æ¯” ===")
    nums = list(range(10000))
    target = 19998

    import time

    # æš´åŠ›è§£æ³•
    start_time = time.time()
    result1 = strategies.two_sum_optimized(nums, target)  # ä½¿ç”¨ä¼˜åŒ–ç‰ˆæœ¬
    end_time = time.time()
    print(f"ä¼˜åŒ–è§£æ³•è€—æ—¶: {end_time - start_time:.6f}ç§’")

    # æœ€å¤§å­æ•°ç»„å’Œå¯¹æ¯”
    print("\n=== æœ€å¤§å­æ•°ç»„å’Œä¼˜åŒ–å¯¹æ¯” ===")
    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
    result = strategies.max_subarray_optimized(nums)
    print(f"æ•°ç»„: {nums}")
    print(f"æœ€å¤§å­æ•°ç»„å’Œ: {result}")

    # ä¸‰æ•°ä¹‹å’Œå¯¹æ¯”
    print("\n=== ä¸‰æ•°ä¹‹å’Œä¼˜åŒ–å¯¹æ¯” ===")
    nums = [-1, 0, 1, 2, -1, -4]
    result = strategies.three_sum_optimized(nums)
    print(f"æ•°ç»„: {nums}")
    print(f"ä¸‰æ•°ä¹‹å’Œä¸º0çš„ç»„åˆ: {result}")

compare_optimization_effects()
```

### 3. æ•°æ®ç»“æ„ï¼šç®—æ³•çš„åŸºçŸ³

#### åŸºç¡€æ•°æ®ç»“æ„ï¼šç†è§£ä¸åº”ç”¨

**å¸¸ç”¨æ•°æ®ç»“æ„å®ç°ï¼š**
```python
# åŸºç¡€æ•°æ®ç»“æ„å®ç°
class DataStructures:
    def __init__(self):
        self.data_structures = {
            'array': 'æ•°ç»„',
            'linked_list': 'é“¾è¡¨',
            'stack': 'æ ˆ',
            'queue': 'é˜Ÿåˆ—',
            'tree': 'æ ‘',
            'graph': 'å›¾',
            'heap': 'å †',
            'hash_table': 'å“ˆå¸Œè¡¨'
        }

    # é“¾è¡¨èŠ‚ç‚¹
    class ListNode:
        def __init__(self, val=0, next=None):
            self.val = val
            self.next = next

    # é“¾è¡¨æ“ä½œ
    def create_linked_list(self, values):
        """åˆ›å»ºé“¾è¡¨"""
        if not values:
            return None

        head = self.ListNode(values[0])
        current = head

        for val in values[1:]:
            current.next = self.ListNode(val)
            current = current.next

        return head

    def reverse_linked_list(self, head):
        """åè½¬é“¾è¡¨"""
        prev = None
        current = head

        while current:
            next_temp = current.next
            current.next = prev
            prev = current
            current = next_temp

        return prev

    def detect_cycle(self, head):
        """æ£€æµ‹é“¾è¡¨ç¯"""
        if not head or not head.next:
            return False

        slow = fast = head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

            if slow == fast:
                return True

        return False

    # æ ˆå®ç°
    class Stack:
        def __init__(self):
            self.items = []

        def push(self, item):
            self.items.append(item)

        def pop(self):
            if not self.is_empty():
                return self.items.pop()
            raise IndexError("Stack is empty")

        def peek(self):
            if not self.is_empty():
                return self.items[-1]
            raise IndexError("Stack is empty")

        def is_empty(self):
            return len(self.items) == 0

        def size(self):
            return len(self.items)

    # é˜Ÿåˆ—å®ç°
    class Queue:
        def __init__(self):
            self.items = []

        def enqueue(self, item):
            self.items.append(item)

        def dequeue(self):
            if not self.is_empty():
                return self.items.pop(0)
            raise IndexError("Queue is empty")

        def front(self):
            if not self.is_empty():
                return self.items[0]
            raise IndexError("Queue is empty")

        def is_empty(self):
            return len(self.items) == 0

        def size(self):
            return len(self.items)

    # äºŒå‰æ ‘èŠ‚ç‚¹
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right

    # äºŒå‰æ ‘éå†
    def inorder_traversal(self, root):
        """ä¸­åºéå†"""
        result = []

        def inorder(node):
            if node:
                inorder(node.left)
                result.append(node.val)
                inorder(node.right)

        inorder(root)
        return result

    def preorder_traversal(self, root):
        """å‰åºéå†"""
        result = []

        def preorder(node):
            if node:
                result.append(node.val)
                preorder(node.left)
                preorder(node.right)

        preorder(root)
        return result

    def postorder_traversal(self, root):
        """ååºéå†"""
        result = []

        def postorder(node):
            if node:
                postorder(node.left)
                postorder(node.right)
                result.append(node.val)

        postorder(root)
        return result

    def level_order_traversal(self, root):
        """å±‚åºéå†"""
        if not root:
            return []

        result = []
        queue = [root]

        while queue:
            level = []
            level_size = len(queue)

            for _ in range(level_size):
                node = queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(level)

        return result

# æ•°æ®ç»“æ„åº”ç”¨ç¤ºä¾‹
def demonstrate_data_structures():
    """æ¼”ç¤ºæ•°æ®ç»“æ„åº”ç”¨"""
    ds = DataStructures()

    # é“¾è¡¨åº”ç”¨
    print("=== é“¾è¡¨åº”ç”¨ ===")
    values = [1, 2, 3, 4, 5]
    head = ds.create_linked_list(values)

    # åè½¬é“¾è¡¨
    reversed_head = ds.reverse_linked_list(head)
    print(f"åŸé“¾è¡¨: {values}")

    # æ£€æµ‹ç¯
    has_cycle = ds.detect_cycle(head)
    print(f"æ˜¯å¦æœ‰ç¯: {has_cycle}")

    # æ ˆåº”ç”¨
    print("\n=== æ ˆåº”ç”¨ ===")
    stack = ds.Stack()
    stack.push(1)
    stack.push(2)
    stack.push(3)
    print(f"æ ˆé¡¶å…ƒç´ : {stack.peek()}")
    print(f"å¼¹å‡ºå…ƒç´ : {stack.pop()}")
    print(f"æ ˆå¤§å°: {stack.size()}")

    # é˜Ÿåˆ—åº”ç”¨
    print("\n=== é˜Ÿåˆ—åº”ç”¨ ===")
    queue = ds.Queue()
    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(3)
    print(f"é˜Ÿé¦–å…ƒç´ : {queue.front()}")
    print(f"å‡ºé˜Ÿå…ƒç´ : {queue.dequeue()}")
    print(f"é˜Ÿåˆ—å¤§å°: {queue.size()}")

    # äºŒå‰æ ‘åº”ç”¨
    print("\n=== äºŒå‰æ ‘åº”ç”¨ ===")
    root = ds.TreeNode(1)
    root.left = ds.TreeNode(2)
    root.right = ds.TreeNode(3)
    root.left.left = ds.TreeNode(4)
    root.left.right = ds.TreeNode(5)

    print(f"ä¸­åºéå†: {ds.inorder_traversal(root)}")
    print(f"å‰åºéå†: {ds.preorder_traversal(root)}")
    print(f"ååºéå†: {ds.postorder_traversal(root)}")
    print(f"å±‚åºéå†: {ds.level_order_traversal(root)}")

demonstrate_data_structures()
```

### 4. é«˜çº§ç®—æ³•ï¼šæ€ç»´çš„è‰ºæœ¯

#### åŠ¨æ€è§„åˆ’ï¼šçŠ¶æ€ä¸è½¬ç§»

**åŠ¨æ€è§„åˆ’æ€ç»´æ¡†æ¶ï¼š**
```python
# åŠ¨æ€è§„åˆ’æ¨¡æ¿
class DynamicProgramming:
    def __init__(self):
        self.memo = {}

    def fibonacci_dp(self, n):
        """æ–æ³¢é‚£å¥‘æ•°åˆ— - åŠ¨æ€è§„åˆ’"""
        if n <= 1:
            return n

        if n in self.memo:
            return self.memo[n]

        self.memo[n] = self.fibonacci_dp(n - 1) + self.fibonacci_dp(n - 2)
        return self.memo[n]

    def fibonacci_iterative(self, n):
        """æ–æ³¢é‚£å¥‘æ•°åˆ— - è¿­ä»£ä¼˜åŒ–"""
        if n <= 1:
            return n

        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b

        return b

    def longest_common_subsequence(self, text1, text2):
        """æœ€é•¿å…¬å…±å­åºåˆ—"""
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

        return dp[m][n]

    def coin_change(self, coins, amount):
        """é›¶é’±å…‘æ¢"""
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0

        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] = min(dp[i], dp[i - coin] + 1)

        return dp[amount] if dp[amount] != float('inf') else -1

    def knapsack_01(self, weights, values, capacity):
        """0-1èƒŒåŒ…é—®é¢˜"""
        n = len(weights)
        dp = [[0] * (capacity + 1) for _ in range(n + 1)]

        for i in range(1, n + 1):
            for w in range(capacity + 1):
                if weights[i - 1] <= w:
                    dp[i][w] = max(dp[i - 1][w],
                                  dp[i - 1][w - weights[i - 1]] + values[i - 1])
                else:
                    dp[i][w] = dp[i - 1][w]

        return dp[n][capacity]

# åŠ¨æ€è§„åˆ’åº”ç”¨ç¤ºä¾‹
def demonstrate_dynamic_programming():
    """æ¼”ç¤ºåŠ¨æ€è§„åˆ’åº”ç”¨"""
    dp = DynamicProgramming()

    # æ–æ³¢é‚£å¥‘æ•°åˆ—
    print("=== æ–æ³¢é‚£å¥‘æ•°åˆ— ===")
    n = 10
    fib_dp = dp.fibonacci_dp(n)
    fib_iter = dp.fibonacci_iterative(n)
    print(f"F({n}) = {fib_dp} (DP), {fib_iter} (è¿­ä»£)")

    # æœ€é•¿å…¬å…±å­åºåˆ—
    print("\n=== æœ€é•¿å…¬å…±å­åºåˆ— ===")
    text1 = "abcde"
    text2 = "ace"
    lcs = dp.longest_common_subsequence(text1, text2)
    print(f"æ–‡æœ¬1: {text1}")
    print(f"æ–‡æœ¬2: {text2}")
    print(f"æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦: {lcs}")

    # é›¶é’±å…‘æ¢
    print("\n=== é›¶é’±å…‘æ¢ ===")
    coins = [1, 2, 5]
    amount = 11
    min_coins = dp.coin_change(coins, amount)
    print(f"ç¡¬å¸: {coins}")
    print(f"ç›®æ ‡é‡‘é¢: {amount}")
    print(f"æœ€å°‘ç¡¬å¸æ•°: {min_coins}")

    # 0-1èƒŒåŒ…é—®é¢˜
    print("\n=== 0-1èƒŒåŒ…é—®é¢˜ ===")
    weights = [2, 1, 3, 2]
    values = [12, 10, 20, 15]
    capacity = 5
    max_value = dp.knapsack_01(weights, values, capacity)
    print(f"é‡é‡: {weights}")
    print(f"ä»·å€¼: {values}")
    print(f"èƒŒåŒ…å®¹é‡: {capacity}")
    print(f"æœ€å¤§ä»·å€¼: {max_value}")

demonstrate_dynamic_programming()
```

#### è´ªå¿ƒç®—æ³•ï¼šå±€éƒ¨æœ€ä¼˜çš„é€‰æ‹©

**è´ªå¿ƒç®—æ³•æ€ç»´ï¼š**
```python
# è´ªå¿ƒç®—æ³•æ¨¡æ¿
class GreedyAlgorithms:
    def __init__(self):
        self.greedy_strategies = {
            'activity_selection': 'æ´»åŠ¨é€‰æ‹©',
            'fractional_knapsack': 'åˆ†æ•°èƒŒåŒ…',
            'huffman_coding': 'å“ˆå¤«æ›¼ç¼–ç ',
            'dijkstra': 'æœ€çŸ­è·¯å¾„',
            'kruskal': 'æœ€å°ç”Ÿæˆæ ‘'
        }

    def activity_selection(self, activities):
        """æ´»åŠ¨é€‰æ‹©é—®é¢˜"""
        if not activities:
            return []

        # æŒ‰ç»“æŸæ—¶é—´æ’åº
        activities.sort(key=lambda x: x[1])

        selected = [activities[0]]
        last_end = activities[0][1]

        for start, end in activities[1:]:
            if start >= last_end:
                selected.append((start, end))
                last_end = end

        return selected

    def fractional_knapsack(self, weights, values, capacity):
        """åˆ†æ•°èƒŒåŒ…é—®é¢˜"""
        items = list(zip(weights, values))
        # æŒ‰å•ä½ä»·å€¼æ’åº
        items.sort(key=lambda x: x[1] / x[0], reverse=True)

        total_value = 0
        remaining_capacity = capacity

        for weight, value in items:
            if remaining_capacity >= weight:
                total_value += value
                remaining_capacity -= weight
            else:
                fraction = remaining_capacity / weight
                total_value += value * fraction
                break

        return total_value

    def minimum_platforms(self, arrivals, departures):
        """æœ€å°‘ç«™å°æ•°é—®é¢˜"""
        arrivals.sort()
        departures.sort()

        platforms_needed = 1
        max_platforms = 1
        i = 1
        j = 0

        while i < len(arrivals) and j < len(departures):
            if arrivals[i] <= departures[j]:
                platforms_needed += 1
                i += 1
            else:
                platforms_needed -= 1
                j += 1

            max_platforms = max(max_platforms, platforms_needed)

        return max_platforms

    def job_scheduling(self, jobs):
        """ä½œä¸šè°ƒåº¦é—®é¢˜"""
        # æŒ‰æˆªæ­¢æ—¶é—´æ’åº
        jobs.sort(key=lambda x: x[1])

        scheduled = []
        current_time = 0

        for job_id, deadline, profit in jobs:
            if current_time < deadline:
                scheduled.append(job_id)
                current_time += 1

        return scheduled

# è´ªå¿ƒç®—æ³•åº”ç”¨ç¤ºä¾‹
def demonstrate_greedy_algorithms():
    """æ¼”ç¤ºè´ªå¿ƒç®—æ³•åº”ç”¨"""
    greedy = GreedyAlgorithms()

    # æ´»åŠ¨é€‰æ‹©
    print("=== æ´»åŠ¨é€‰æ‹©é—®é¢˜ ===")
    activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11)]
    selected_activities = greedy.activity_selection(activities)
    print(f"æ‰€æœ‰æ´»åŠ¨: {activities}")
    print(f"é€‰æ‹©çš„æ´»åŠ¨: {selected_activities}")
    print(f"æœ€å¤§æ´»åŠ¨æ•°: {len(selected_activities)}")

    # åˆ†æ•°èƒŒåŒ…
    print("\n=== åˆ†æ•°èƒŒåŒ…é—®é¢˜ ===")
    weights = [10, 20, 30]
    values = [60, 100, 120]
    capacity = 50
    max_value = greedy.fractional_knapsack(weights, values, capacity)
    print(f"é‡é‡: {weights}")
    print(f"ä»·å€¼: {values}")
    print(f"èƒŒåŒ…å®¹é‡: {capacity}")
    print(f"æœ€å¤§ä»·å€¼: {max_value}")

    # æœ€å°‘ç«™å°æ•°
    print("\n=== æœ€å°‘ç«™å°æ•°é—®é¢˜ ===")
    arrivals = [900, 940, 950, 1100, 1500, 1800]
    departures = [910, 1200, 1120, 1130, 1900, 2000]
    platforms = greedy.minimum_platforms(arrivals, departures)
    print(f"åˆ°è¾¾æ—¶é—´: {arrivals}")
    print(f"ç¦»å¼€æ—¶é—´: {departures}")
    print(f"æœ€å°‘ç«™å°æ•°: {platforms}")

demonstrate_greedy_algorithms()
```

## ç®—æ³•å­¦ä¹ ç­–ç•¥ï¼šä»å…¥é—¨åˆ°ç²¾é€š

### 1. å­¦ä¹ è·¯å¾„è§„åˆ’

**é˜¶æ®µæ€§å­¦ä¹ è®¡åˆ’ï¼š**
```python
# å­¦ä¹ è·¯å¾„è§„åˆ’å™¨
class LearningPathPlanner:
    def __init__(self):
        self.learning_stages = {
            'beginner': {
                'duration': '1-2ä¸ªæœˆ',
                'topics': ['åŸºç¡€æ•°æ®ç»“æ„', 'ç®€å•æ’åº', 'åŸºæœ¬æŸ¥æ‰¾'],
                'target': 'ç†è§£åŸºæœ¬æ¦‚å¿µï¼Œèƒ½å†™ç®€å•ç®—æ³•'
            },
            'intermediate': {
                'duration': '2-3ä¸ªæœˆ',
                'topics': ['åŠ¨æ€è§„åˆ’', 'è´ªå¿ƒç®—æ³•', 'å›¾è®ºåŸºç¡€'],
                'target': 'æŒæ¡å¸¸è§ç®—æ³•æ€æƒ³ï¼Œèƒ½è§£å†³ä¸­ç­‰éš¾åº¦é—®é¢˜'
            },
            'advanced': {
                'duration': '3-6ä¸ªæœˆ',
                'topics': ['é«˜çº§æ•°æ®ç»“æ„', 'å¤æ‚ç®—æ³•', 'ç®—æ³•ä¼˜åŒ–'],
                'target': 'èƒ½è§£å†³å›°éš¾é—®é¢˜ï¼Œç†è§£ç®—æ³•æœ¬è´¨'
            }
        }

    def create_learning_plan(self, current_level, target_level):
        """åˆ›å»ºå­¦ä¹ è®¡åˆ’"""
        plan = {
            'current_level': current_level,
            'target_level': target_level,
            'timeline': [],
            'resources': [],
            'practice_problems': []
        }

        # æ ¹æ®ç›®æ ‡çº§åˆ«åˆ¶å®šè®¡åˆ’
        if target_level == 'beginner':
            plan['timeline'] = [
                {'week': 1, 'focus': 'æ•°ç»„å’Œå­—ç¬¦ä¸²åŸºç¡€'},
                {'week': 2, 'focus': 'é“¾è¡¨å’Œæ ˆé˜Ÿåˆ—'},
                {'week': 3, 'focus': 'ç®€å•æ’åºç®—æ³•'},
                {'week': 4, 'focus': 'åŸºç¡€æŸ¥æ‰¾ç®—æ³•'}
            ]
        elif target_level == 'intermediate':
            plan['timeline'] = [
                {'week': 1-2, 'focus': 'åŠ¨æ€è§„åˆ’åŸºç¡€'},
                {'week': 3-4, 'focus': 'è´ªå¿ƒç®—æ³•'},
                {'week': 5-6, 'focus': 'å›¾è®ºåŸºç¡€'},
                {'week': 7-8, 'focus': 'æ ‘å’ŒäºŒå‰æ ‘'}
            ]

        return plan

    def recommend_problems(self, level, topic):
        """æ¨èç»ƒä¹ é¢˜"""
        problem_sets = {
            'beginner': {
                'array': ['ä¸¤æ•°ä¹‹å’Œ', 'æœ€å¤§å­æ•°ç»„å’Œ', 'ç§»åŠ¨é›¶'],
                'string': ['åè½¬å­—ç¬¦ä¸²', 'æœ‰æ•ˆæ‹¬å·', 'æœ€é•¿å…¬å…±å‰ç¼€'],
                'linked_list': ['åè½¬é“¾è¡¨', 'æ£€æµ‹ç¯', 'åˆå¹¶æœ‰åºé“¾è¡¨']
            },
            'intermediate': {
                'dp': ['çˆ¬æ¥¼æ¢¯', 'é›¶é’±å…‘æ¢', 'æœ€é•¿é€’å¢å­åºåˆ—'],
                'greedy': ['æ´»åŠ¨é€‰æ‹©', 'åˆ†æ•°èƒŒåŒ…', 'æœ€å°‘ç«™å°æ•°'],
                'tree': ['äºŒå‰æ ‘éå†', 'æœ€å¤§æ·±åº¦', 'è·¯å¾„å’Œ']
            }
        }

        return problem_sets.get(level, {}).get(topic, [])

# å­¦ä¹ è®¡åˆ’ç¤ºä¾‹
def create_personal_learning_plan():
    """åˆ›å»ºä¸ªäººå­¦ä¹ è®¡åˆ’"""
    planner = LearningPathPlanner()

    # åˆå­¦è€…è®¡åˆ’
    beginner_plan = planner.create_learning_plan('none', 'beginner')
    print("=== åˆå­¦è€…å­¦ä¹ è®¡åˆ’ ===")
    print(f"ç›®æ ‡: {beginner_plan['target_level']}")
    for milestone in beginner_plan['timeline']:
        print(f"ç¬¬{milestone['week']}å‘¨: {milestone['focus']}")

    # æ¨èç»ƒä¹ é¢˜
    print("\n=== æ¨èç»ƒä¹ é¢˜ ===")
    array_problems = planner.recommend_problems('beginner', 'array')
    print(f"æ•°ç»„åŸºç¡€é¢˜: {array_problems}")

create_personal_learning_plan()
```

### 2. å®è·µæŠ€å·§ï¼šä»ç†è®ºåˆ°åº”ç”¨

**åˆ·é¢˜ç­–ç•¥ï¼š**
```python
# åˆ·é¢˜ç­–ç•¥ç®¡ç†å™¨
class ProblemSolvingStrategy:
    def __init__(self):
        self.strategies = {
            'understanding': 'ç†è§£é—®é¢˜',
            'planning': 'åˆ¶å®šè®¡åˆ’',
            'coding': 'ç¼–å†™ä»£ç ',
            'testing': 'æµ‹è¯•éªŒè¯',
            'optimizing': 'ä¼˜åŒ–æ”¹è¿›'
        }

    def solve_problem_step_by_step(self, problem_description):
        """åˆ†æ­¥éª¤è§£å†³é—®é¢˜"""
        steps = []

        # æ­¥éª¤1ï¼šç†è§£é—®é¢˜
        steps.append({
            'step': 1,
            'action': 'ç†è§£é—®é¢˜',
            'questions': [
                'è¾“å…¥æ˜¯ä»€ä¹ˆï¼Ÿ',
                'è¾“å‡ºæ˜¯ä»€ä¹ˆï¼Ÿ',
                'æœ‰ä»€ä¹ˆçº¦æŸæ¡ä»¶ï¼Ÿ',
                'è¾¹ç•Œæƒ…å†µæ˜¯ä»€ä¹ˆï¼Ÿ'
            ]
        })

        # æ­¥éª¤2ï¼šåˆ¶å®šè®¡åˆ’
        steps.append({
            'step': 2,
            'action': 'åˆ¶å®šè®¡åˆ’',
            'questions': [
                'å¯ä»¥ç”¨ä»€ä¹ˆç®—æ³•ï¼Ÿ',
                'æ—¶é—´å¤æ‚åº¦è¦æ±‚ï¼Ÿ',
                'ç©ºé—´å¤æ‚åº¦è¦æ±‚ï¼Ÿ',
                'å¦‚ä½•åˆ†è§£é—®é¢˜ï¼Ÿ'
            ]
        })

        # æ­¥éª¤3ï¼šç¼–å†™ä»£ç 
        steps.append({
            'step': 3,
            'action': 'ç¼–å†™ä»£ç ',
            'tips': [
                'å…ˆå†™ä¼ªä»£ç ',
                'è€ƒè™‘è¾¹ç•Œæƒ…å†µ',
                'æ³¨æ„ä»£ç è§„èŒƒ',
                'æ·»åŠ å¿…è¦æ³¨é‡Š'
            ]
        })

        # æ­¥éª¤4ï¼šæµ‹è¯•éªŒè¯
        steps.append({
            'step': 4,
            'action': 'æµ‹è¯•éªŒè¯',
            'test_cases': [
                'æ­£å¸¸æƒ…å†µ',
                'è¾¹ç•Œæƒ…å†µ',
                'å¼‚å¸¸æƒ…å†µ',
                'æ€§èƒ½æµ‹è¯•'
            ]
        })

        # æ­¥éª¤5ï¼šä¼˜åŒ–æ”¹è¿›
        steps.append({
            'step': 5,
            'action': 'ä¼˜åŒ–æ”¹è¿›',
            'optimizations': [
                'æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–',
                'ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–',
                'ä»£ç å¯è¯»æ€§ä¼˜åŒ–',
                'ç®—æ³•é€‰æ‹©ä¼˜åŒ–'
            ]
        })

        return steps

    def analyze_problem_pattern(self, problem_description):
        """åˆ†æé—®é¢˜æ¨¡å¼"""
        patterns = {
            'array_manipulation': ['æ•°ç»„', 'å­æ•°ç»„', 'æ’åº', 'æŸ¥æ‰¾'],
            'string_processing': ['å­—ç¬¦ä¸²', 'åŒ¹é…', 'ç¼–è¾‘', 'å›æ–‡'],
            'tree_traversal': ['æ ‘', 'éå†', 'è·¯å¾„', 'æ·±åº¦'],
            'graph_search': ['å›¾', 'æœç´¢', 'è·¯å¾„', 'è¿é€š'],
            'dynamic_programming': ['æœ€å¤§', 'æœ€å°', 'æ•°é‡', 'æ–¹æ¡ˆ'],
            'greedy_choice': ['é€‰æ‹©', 'å®‰æ’', 'è°ƒåº¦', 'åˆ†é…']
        }

        matched_patterns = []
        for pattern, keywords in patterns.items():
            if any(keyword in problem_description for keyword in keywords):
                matched_patterns.append(pattern)

        return matched_patterns

# è§£é¢˜ç­–ç•¥ç¤ºä¾‹
def demonstrate_problem_solving():
    """æ¼”ç¤ºè§£é¢˜ç­–ç•¥"""
    strategy = ProblemSolvingStrategy()

    # åˆ†æ­¥éª¤è§£é¢˜
    problem = "ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°å’Œæœ€å¤§çš„è¿ç»­å­æ•°ç»„"
    steps = strategy.solve_problem_step_by_step(problem)

    print("=== è§£é¢˜æ­¥éª¤ ===")
    for step in steps:
        print(f"\næ­¥éª¤{step['step']}: {step['action']}")
        if 'questions' in step:
            for question in step['questions']:
                print(f"  - {question}")
        elif 'tips' in step:
            for tip in step['tips']:
                print(f"  - {tip}")
        elif 'test_cases' in step:
            for test_case in step['test_cases']:
                print(f"  - {test_case}")
        elif 'optimizations' in step:
            for optimization in step['optimizations']:
                print(f"  - {optimization}")

    # é—®é¢˜æ¨¡å¼åˆ†æ
    patterns = strategy.analyze_problem_pattern(problem)
    print(f"\né—®é¢˜æ¨¡å¼: {patterns}")

demonstrate_problem_solving()
```

## æ€»ç»“ä¸åæ€

### ç®—æ³•å­¦ä¹ çš„ä»·å€¼

1. **æ€ç»´è®­ç»ƒ**ï¼šåŸ¹å…»é€»è¾‘æ€ç»´å’Œé—®é¢˜è§£å†³èƒ½åŠ›
2. **ç¼–ç¨‹åŸºç¡€**ï¼šæŒæ¡é«˜æ•ˆçš„ç¼–ç¨‹æŠ€å·§å’Œæ–¹æ³•
3. **é¢è¯•å‡†å¤‡**ï¼šä¸ºæŠ€æœ¯é¢è¯•æ‰“ä¸‹åšå®åŸºç¡€
4. **èŒä¸šå‘å±•**ï¼šæå‡æŠ€æœ¯æ°´å¹³å’Œç«äº‰åŠ›

### æˆ‘çš„å­¦ä¹ å¿ƒå¾—

1. **ä»åŸºç¡€å¼€å§‹**ï¼šå…ˆæŒæ¡åŸºæœ¬æ¦‚å¿µï¼Œå†å­¦ä¹ é«˜çº§ç®—æ³•
2. **å®è·µä¸ºä¸»**ï¼šç†è®ºç»“åˆå®è·µï¼Œå¤šåšé¢˜å¤šæ€è€ƒ
3. **æŒç»­å­¦ä¹ **ï¼šç®—æ³•å­¦ä¹ æ˜¯ä¸€ä¸ªé•¿æœŸè¿‡ç¨‹
4. **æ€»ç»“åæ€**ï¼šåŠæ—¶æ€»ç»“ç»éªŒå’Œæ•™è®­

### ç»™å…¶ä»–"åºŸæŸ´"çš„å»ºè®®

1. **ä¸è¦å®³æ€•å›°éš¾**ï¼šç®—æ³•å­¦ä¹ éœ€è¦æ—¶é—´å’Œè€å¿ƒ
2. **ä¿æŒç»ƒä¹ **ï¼šæ¯å¤©åˆ·é¢˜ï¼Œä¿æŒæ‰‹æ„Ÿ
3. **å­¦ä¹ ä»–äºº**ï¼šå‚è€ƒä¼˜ç§€çš„è§£é¢˜æ€è·¯å’Œä»£ç 
4. **å»ºç«‹ä½“ç³»**ï¼šå½¢æˆè‡ªå·±çš„ç®—æ³•çŸ¥è¯†ä½“ç³»

## å‚è€ƒèµ„æ–™

- [ç®—æ³•å¯¼è®º](https://book.douban.com/subject/20432061/)
- [ç¼–ç¨‹ç ç‘](https://book.douban.com/subject/3227098/)
- [LeetCode](https://leetcode.com/)
- [ç®—æ³•å¯è§†åŒ–](https://visualgo.net/)

## ç»“è¯­

ç®—æ³•å­¦ä¹ æ˜¯ä¸€ä¸ªå……æ»¡æŒ‘æˆ˜å’Œä¹è¶£çš„è¿‡ç¨‹ã€‚ä»æœ€åˆçš„"æš´åŠ›è§£æ³•"åˆ°åæ¥çš„"ä¼˜é›…ç®—æ³•"ï¼Œæ¯ä¸€æ­¥éƒ½æ˜¯æ€ç»´çš„æå‡ã€‚

è®°ä½ï¼Œå¥½çš„ç®—æ³•ä¸æ˜¯ä¸€è¹´è€Œå°±çš„ï¼Œè€Œæ˜¯é€šè¿‡ä¸æ–­ç»ƒä¹ å’Œæ€è€ƒå¾—æ¥çš„ã€‚ä¸è¦å®³æ€•çŠ¯é”™ï¼Œä¸è¦å®³æ€•å›°éš¾ï¼Œæ¯ä¸€æ¬¡å°è¯•éƒ½æ˜¯å­¦ä¹ çš„æœºä¼šã€‚

## å®ç”¨å°è´´å£«

### ğŸ¯ ç®—æ³•å­¦ä¹ è·¯å¾„
- [ ] æŒæ¡åŸºç¡€æ•°æ®ç»“æ„ï¼ˆæ•°ç»„ã€é“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ï¼‰
- [ ] å­¦ä¹ åŸºæœ¬ç®—æ³•ï¼ˆæ’åºã€æŸ¥æ‰¾ã€é€’å½’ï¼‰
- [ ] ç†è§£é«˜çº§ç®—æ³•ï¼ˆåŠ¨æ€è§„åˆ’ã€è´ªå¿ƒã€åˆ†æ²»ï¼‰
- [ ] å®è·µå¤æ‚é—®é¢˜ï¼ˆå›¾è®ºã€å­—ç¬¦ä¸²ã€æ•°å­¦ï¼‰
- [ ] ä¼˜åŒ–ç®—æ³•æ€§èƒ½ï¼ˆæ—¶é—´å¤æ‚åº¦ã€ç©ºé—´å¤æ‚åº¦ï¼‰

### ğŸš€ å¿«é€Ÿå¼€å§‹
```python
# 1. ç†è§£é—®é¢˜
# 2. åˆ†æå¤æ‚åº¦
# 3. é€‰æ‹©ç®—æ³•
# 4. ç¼–å†™ä»£ç 
# 5. æµ‹è¯•ä¼˜åŒ–

# ç¤ºä¾‹ï¼šä¸¤æ•°ä¹‹å’Œ
def two_sum(nums, target):
    num_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_map:
            return [num_map[complement], i]
        num_map[num] = i
    return []
```

### ğŸ’¡ è¿›é˜¶æŠ€å·§
- æŒæ¡å¸¸è§ç®—æ³•æ¨¡æ¿
- ç†è§£ç®—æ³•æ€æƒ³æœ¬è´¨
- å­¦ä¼šå¤æ‚åº¦åˆ†æ
- åŸ¹å…»è§£é¢˜ç›´è§‰
- å»ºç«‹çŸ¥è¯†ä½“ç³»
6:T4465,
# ğŸ’» LeetCodeåˆ·é¢˜æŒ‡å—ï¼šä¸€ä¸ªæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•å­¦ä¹ ä¹‹è·¯

## ç®—æ³•å­¦ä¹ çš„æœ¬è´¨æ€è€ƒ

ç®—æ³•å­¦ä¹ ï¼Œæœ¬è´¨ä¸Šæ˜¯å¯¹é—®é¢˜è§£å†³æ€ç»´çš„è®­ç»ƒã€‚

å½“æˆ‘ç¬¬ä¸€æ¬¡æ¥è§¦LeetCodeæ—¶ï¼Œæˆ‘ä»¥ä¸ºè¿™åªæ˜¯ä¸€ä¸ª"åˆ·é¢˜"çš„å¹³å°ã€‚ä½†éšç€æ·±å…¥ï¼Œæˆ‘å‘ç°å®ƒæ›´åƒæ˜¯ä¸€é¢é•œå­ï¼Œç…§å‡ºäº†æˆ‘åœ¨é—®é¢˜è§£å†³èƒ½åŠ›ä¸Šçš„ä¸è¶³ã€‚

ä»æš´åŠ›è§£æ³•åˆ°æœ€ä¼˜è§£ï¼Œä»O(nÂ²)åˆ°O(n log n)ï¼Œæ¯ä¸€æ¬¡ä¼˜åŒ–éƒ½è®©æˆ‘å¯¹ç®—æ³•æœ‰äº†æ›´æ·±çš„ç†è§£ã€‚

## ç®—æ³•æ€ç»´çš„æ ¸å¿ƒï¼šé—®é¢˜åˆ†è§£ä¸æ¨¡å¼è¯†åˆ«

### é—®é¢˜åˆ†è§£çš„è‰ºæœ¯

**æ ¸å¿ƒæ€æƒ³**ï¼šå°†å¤æ‚é—®é¢˜åˆ†è§£ä¸ºç®€å•å­é—®é¢˜

**æˆ‘çš„ç†è§£**ï¼š
```
å¤æ‚é—®é¢˜ â†’ å­é—®é¢˜1 + å­é—®é¢˜2 + ... + å­é—®é¢˜n
æ¯ä¸ªå­é—®é¢˜ â†’ å·²çŸ¥è§£æ³•æˆ–é€’å½’è§£å†³
æœ€ç»ˆç»“æœ â†’ å­é—®é¢˜ç»“æœçš„ç»„åˆ
```

**å®é™…åº”ç”¨**ï¼š
```python
# é—®é¢˜ï¼šè®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—ç¬¬né¡¹
# åˆ†è§£ï¼šF(n) = F(n-1) + F(n-2)
# è¾¹ç•Œï¼šF(0) = 0, F(1) = 1

def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

### æ¨¡å¼è¯†åˆ«çš„èƒ½åŠ›

**æ ¸å¿ƒæ€æƒ³**ï¼šè¯†åˆ«é—®é¢˜èƒŒåçš„ç®—æ³•æ¨¡å¼

**å¸¸è§æ¨¡å¼**ï¼š
1. **åŒæŒ‡é’ˆ**ï¼šæ•°ç»„ã€é“¾è¡¨ä¸­çš„å¿«æ…¢æŒ‡é’ˆ
2. **æ»‘åŠ¨çª—å£**ï¼šå­æ•°ç»„ã€å­å­—ç¬¦ä¸²é—®é¢˜
3. **åˆ†æ²»**ï¼šå½’å¹¶æ’åºã€å¿«é€Ÿæ’åº
4. **åŠ¨æ€è§„åˆ’**ï¼šæœ€ä¼˜å­ç»“æ„é—®é¢˜
5. **è´ªå¿ƒ**ï¼šå±€éƒ¨æœ€ä¼˜é€‰æ‹©
6. **å›æº¯**ï¼šçŠ¶æ€ç©ºé—´æœç´¢

**æˆ‘çš„è¯†åˆ«æ–¹æ³•**ï¼š
```python
# é—®é¢˜ç‰¹å¾åˆ†æ
def analyze_problem(problem):
    if "æ•°ç»„" in problem and "æŸ¥æ‰¾" in problem:
        return "äºŒåˆ†æŸ¥æ‰¾"
    elif "å­æ•°ç»„" in problem and "å’Œ" in problem:
        return "æ»‘åŠ¨çª—å£"
    elif "è·¯å¾„" in problem and "æœ€çŸ­" in problem:
        return "BFS/åŠ¨æ€è§„åˆ’"
    elif "æ’åˆ—" in problem or "ç»„åˆ" in problem:
        return "å›æº¯"
    else:
        return "æš´åŠ›è§£æ³•"
```

## æ•°æ®ç»“æ„ï¼šç®—æ³•çš„åŸºç¡€

### æ•°ç»„ä¸é“¾è¡¨ï¼šçº¿æ€§ç»“æ„çš„å¯¹æ¯”

**æ•°ç»„ç‰¹ç‚¹**ï¼š
- éšæœºè®¿é—®ï¼šO(1)
- æ’å…¥åˆ é™¤ï¼šO(n)
- å†…å­˜è¿ç»­ï¼šç¼“å­˜å‹å¥½

**é“¾è¡¨ç‰¹ç‚¹**ï¼š
- éšæœºè®¿é—®ï¼šO(n)
- æ’å…¥åˆ é™¤ï¼šO(1)
- å†…å­˜åˆ†æ•£ï¼šç¼“å­˜ä¸å‹å¥½

**æˆ‘çš„é€‰æ‹©ç­–ç•¥**ï¼š
```python
# é€‰æ‹©æ•°ç»„çš„æƒ…å†µ
if need_random_access or need_cache_friendly:
    use_array()

# é€‰æ‹©é“¾è¡¨çš„æƒ…å†µ
if need_frequent_insert_delete or need_dynamic_size:
    use_linked_list()
```

### æ ˆä¸é˜Ÿåˆ—ï¼šLIFO vs FIFO

**æ ˆçš„åº”ç”¨åœºæ™¯**ï¼š
```python
# æ‹¬å·åŒ¹é…
def is_valid_parentheses(s):
    stack = []
    brackets = {')': '(', '}': '{', ']': '['}

    for char in s:
        if char in '({[':
            stack.append(char)
        elif char in ')}]':
            if not stack or stack.pop() != brackets[char]:
                return False

    return len(stack) == 0
```

**é˜Ÿåˆ—çš„åº”ç”¨åœºæ™¯**ï¼š
```python
# å±‚æ¬¡éå†
def level_order_traversal(root):
    if not root:
        return []

    queue = [root]
    result = []

    while queue:
        level_size = len(queue)
        level = []

        for _ in range(level_size):
            node = queue.pop(0)
            level.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(level)

    return result
```

### å“ˆå¸Œè¡¨ï¼šç©ºé—´æ¢æ—¶é—´çš„ç»å…¸

**æ ¸å¿ƒæ€æƒ³**ï¼šç”¨ç©ºé—´å¤æ‚åº¦æ¢å–æ—¶é—´å¤æ‚åº¦

**æˆ‘çš„ä½¿ç”¨å¿ƒå¾—**ï¼š
```python
# ä¸¤æ•°ä¹‹å’Œï¼šO(nÂ²) â†’ O(n)
def two_sum_brute_force(nums, target):
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []

def two_sum_hashmap(nums, target):
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []
```

## ç®—æ³•æ€æƒ³ï¼šä»æš´åŠ›åˆ°ä¼˜é›…

### åŒæŒ‡é’ˆï¼šçº¿æ€§æ—¶é—´çš„è‰ºæœ¯

**æ ¸å¿ƒæ€æƒ³**ï¼šç”¨ä¸¤ä¸ªæŒ‡é’ˆåœ¨æ•°æ®ç»“æ„ä¸­ç§»åŠ¨

**åº”ç”¨åœºæ™¯**ï¼š
1. **æœ‰åºæ•°ç»„**ï¼šäºŒåˆ†æŸ¥æ‰¾ã€åˆå¹¶æœ‰åºæ•°ç»„
2. **é“¾è¡¨**ï¼šæ£€æµ‹ç¯ã€æ‰¾ä¸­ç‚¹
3. **å­—ç¬¦ä¸²**ï¼šå›æ–‡åˆ¤æ–­ã€å­ä¸²æŸ¥æ‰¾

**æˆ‘çš„å®ç°æ¨¡å¼**ï¼š
```python
# æœ‰åºæ•°ç»„çš„åŒæŒ‡é’ˆ
def two_pointers_sorted_array(nums):
    left, right = 0, len(nums) - 1

    while left < right:
        # æ ¹æ®æ¡ä»¶ç§»åŠ¨æŒ‡é’ˆ
        if condition(nums[left], nums[right]):
            left += 1
        else:
            right -= 1

    return result

# å¿«æ…¢æŒ‡é’ˆ
def fast_slow_pointers(head):
    slow = fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    return slow
```

### æ»‘åŠ¨çª—å£ï¼šå­æ•°ç»„é—®é¢˜çš„åˆ©å™¨

**æ ¸å¿ƒæ€æƒ³**ï¼šç»´æŠ¤ä¸€ä¸ªå¯å˜å¤§å°çš„çª—å£

**æˆ‘çš„æ¨¡æ¿**ï¼š
```python
def sliding_window_template(nums):
    left = right = 0
    window_sum = 0
    result = 0

    while right < len(nums):
        # æ‰©å¤§çª—å£
        window_sum += nums[right]
        right += 1

        # æ”¶ç¼©çª—å£
        while window_sum >= target:
            result = min(result, right - left)
            window_sum -= nums[left]
            left += 1

    return result
```

**å®é™…åº”ç”¨**ï¼š
```python
# æœ€å°å­æ•°ç»„å’Œ
def min_sub_array_len(target, nums):
    left = 0
    window_sum = 0
    min_length = float('inf')

    for right in range(len(nums)):
        window_sum += nums[right]

        while window_sum >= target:
            min_length = min(min_length, right - left + 1)
            window_sum -= nums[left]
            left += 1

    return min_length if min_length != float('inf') else 0
```

### åŠ¨æ€è§„åˆ’ï¼šçŠ¶æ€è½¬ç§»çš„è‰ºæœ¯

**æ ¸å¿ƒæ€æƒ³**ï¼šå°†é—®é¢˜åˆ†è§£ä¸ºé‡å å­é—®é¢˜

**æˆ‘çš„è§£é¢˜æ­¥éª¤**ï¼š
1. **å®šä¹‰çŠ¶æ€**ï¼šdp[i] è¡¨ç¤ºä»€ä¹ˆ
2. **çŠ¶æ€è½¬ç§»**ï¼šdp[i] å¦‚ä½•ä» dp[j] è½¬ç§»
3. **åˆå§‹çŠ¶æ€**ï¼šdp[0] ç­‰è¾¹ç•Œæ¡ä»¶
4. **è®¡ç®—é¡ºåº**ï¼šä»ç®€å•åˆ°å¤æ‚

**ç»å…¸é—®é¢˜**ï¼š
```python
# æ–æ³¢é‚£å¥‘æ•°åˆ—
def fibonacci_dp(n):
    if n <= 1:
        return n

    dp = [0] * (n + 1)
    dp[1] = 1

    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]

    return dp[n]

# æœ€é•¿é€’å¢å­åºåˆ—
def length_of_lis(nums):
    if not nums:
        return 0

    dp = [1] * len(nums)

    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)
```

### å›æº¯ï¼šçŠ¶æ€ç©ºé—´æœç´¢

**æ ¸å¿ƒæ€æƒ³**ï¼šå°è¯•æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©

**æˆ‘çš„æ¨¡æ¿**ï¼š
```python
def backtrack_template(choices, path, result):
    # ç»ˆæ­¢æ¡ä»¶
    if is_solution(path):
        result.append(path[:])
        return

    # é€‰æ‹©åˆ—è¡¨
    for choice in choices:
        # åšé€‰æ‹©
        if is_valid(choice, path):
            path.append(choice)
            backtrack_template(choices, path, result)
            path.pop()  # æ’¤é”€é€‰æ‹©
```

**å®é™…åº”ç”¨**ï¼š
```python
# å…¨æ’åˆ—
def permute(nums):
    def backtrack(nums, path, result):
        if len(path) == len(nums):
            result.append(path[:])
            return

        for num in nums:
            if num not in path:
                path.append(num)
                backtrack(nums, path, result)
                path.pop()

    result = []
    backtrack(nums, [], result)
    return result
```

## ä¼˜åŒ–æŠ€å·§ï¼šä»O(nÂ²)åˆ°O(n log n)

### ç©ºé—´ä¼˜åŒ–ï¼šåŸåœ°ç®—æ³•

**æ ¸å¿ƒæ€æƒ³**ï¼šåœ¨ä¸ä½¿ç”¨é¢å¤–ç©ºé—´çš„æƒ…å†µä¸‹è§£å†³é—®é¢˜

**æˆ‘çš„å®è·µ**ï¼š
```python
# åŸåœ°åè½¬æ•°ç»„
def reverse_array_inplace(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        nums[left], nums[right] = nums[right], nums[left]
        left += 1
        right -= 1

# åŸåœ°åˆ é™¤é‡å¤å…ƒç´ 
def remove_duplicates_inplace(nums):
    if not nums:
        return 0

    write_index = 1
    for read_index in range(1, len(nums)):
        if nums[read_index] != nums[read_index - 1]:
            nums[write_index] = nums[read_index]
            write_index += 1

    return write_index
```

### æ—¶é—´ä¼˜åŒ–ï¼šç®—æ³•é€‰æ‹©

**æˆ‘çš„é€‰æ‹©ç­–ç•¥**ï¼š
```python
def choose_algorithm(problem_size, time_constraint):
    if problem_size <= 100:
        return "æš´åŠ›è§£æ³•"
    elif problem_size <= 10000:
        return "O(nÂ²) ç®—æ³•"
    elif problem_size <= 1000000:
        return "O(n log n) ç®—æ³•"
    else:
        return "O(n) ç®—æ³•"
```

**å®é™…æ¡ˆä¾‹**ï¼š
```python
# æ’åºç®—æ³•é€‰æ‹©
def sort_algorithm_choice(nums):
    n = len(nums)

    if n <= 10:
        return insertion_sort(nums)  # O(nÂ²)
    elif n <= 1000:
        return quick_sort(nums)      # O(n log n)
    else:
        return merge_sort(nums)      # O(n log n)
```

## å®æˆ˜æŠ€å·§ï¼šæˆ‘çš„åˆ·é¢˜æ–¹æ³•è®º

### è§£é¢˜æ­¥éª¤ï¼šä»ç†è§£åˆ°å®ç°

**æˆ‘çš„æ ‡å‡†æµç¨‹**ï¼š
1. **ç†è§£é—®é¢˜**ï¼šæ˜ç¡®è¾“å…¥è¾“å‡ºå’Œçº¦æŸæ¡ä»¶
2. **è®¾è®¡ç®—æ³•**ï¼šé€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„å’Œç®—æ³•
3. **åˆ†æå¤æ‚åº¦**ï¼šæ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
4. **ç¼–å†™ä»£ç **ï¼šå®ç°ç®—æ³•
5. **æµ‹è¯•éªŒè¯**ï¼šè¾¹ç•Œæ¡ä»¶å’Œç‰¹æ®Šæƒ…å†µ
6. **ä¼˜åŒ–æ”¹è¿›**ï¼šå¯»æ‰¾æ›´ä¼˜è§£æ³•

**å®é™…åº”ç”¨**ï¼š
```python
# ä»¥"ä¸¤æ•°ä¹‹å’Œ"ä¸ºä¾‹
def solve_two_sum():
    # 1. ç†è§£é—®é¢˜
    # è¾“å…¥ï¼šæ•°ç»„numsï¼Œç›®æ ‡å€¼target
    # è¾“å‡ºï¼šä¸¤ä¸ªæ•°çš„ç´¢å¼•ï¼Œä½¿å¾—nums[i] + nums[j] = target

    # 2. è®¾è®¡ç®—æ³•
    # æš´åŠ›è§£æ³•ï¼šO(nÂ²)
    # å“ˆå¸Œè¡¨ï¼šO(n)

    # 3. åˆ†æå¤æ‚åº¦
    # æ—¶é—´ï¼šO(n)ï¼Œç©ºé—´ï¼šO(n)

    # 4. ç¼–å†™ä»£ç 
    def two_sum(nums, target):
        hash_map = {}
        for i, num in enumerate(nums):
            complement = target - num
            if complement in hash_map:
                return [hash_map[complement], i]
            hash_map[num] = i
        return []

    # 5. æµ‹è¯•éªŒè¯
    assert two_sum([2, 7, 11, 15], 9) == [0, 1]
    assert two_sum([3, 2, 4], 6) == [1, 2]

    # 6. ä¼˜åŒ–æ”¹è¿›
    # å½“å‰è§£æ³•å·²ç»æ˜¯æœ€ä¼˜çš„
```

### è°ƒè¯•æŠ€å·§ï¼šä»é”™è¯¯ä¸­å­¦ä¹ 

**æˆ‘çš„è°ƒè¯•æ–¹æ³•**ï¼š
```python
def debug_algorithm(algorithm, test_cases):
    for i, (input_data, expected) in enumerate(test_cases):
        try:
            result = algorithm(*input_data)
            if result != expected:
                print(f"Test case {i} failed:")
                print(f"Input: {input_data}")
                print(f"Expected: {expected}")
                print(f"Got: {result}")
                # æ·»åŠ æ–­ç‚¹æˆ–æ‰“å°ä¸­é—´çŠ¶æ€
                break
        except Exception as e:
            print(f"Test case {i} error: {e}")
            break
```

**å¸¸è§é”™è¯¯ç±»å‹**ï¼š
1. **è¾¹ç•Œæ¡ä»¶**ï¼šç©ºæ•°ç»„ã€å•ä¸ªå…ƒç´ 
2. **æ•°æ®ç±»å‹**ï¼šæ•´æ•°æº¢å‡ºã€æµ®ç‚¹æ•°ç²¾åº¦
3. **é€»è¾‘é”™è¯¯**ï¼šæ¡ä»¶åˆ¤æ–­é”™è¯¯ã€å¾ªç¯è¾¹ç•Œé”™è¯¯
4. **æ€§èƒ½é—®é¢˜**ï¼šè¶…æ—¶ã€å†…å­˜æº¢å‡º

### è®°å¿†æŠ€å·§ï¼šæ¨¡å¼è¯†åˆ«ä¸æ€»ç»“

**æˆ‘çš„è®°å¿†æ–¹æ³•**ï¼š
```python
# ç®—æ³•æ¨¡å¼å¡ç‰‡
algorithm_patterns = {
    "æ•°ç»„æŸ¥æ‰¾": ["äºŒåˆ†æŸ¥æ‰¾", "åŒæŒ‡é’ˆ", "æ»‘åŠ¨çª—å£"],
    "å­—ç¬¦ä¸²å¤„ç†": ["KMP", "Rabin-Karp", "Trie"],
    "å›¾è®º": ["DFS", "BFS", "Dijkstra", "Floyd"],
    "åŠ¨æ€è§„åˆ’": ["èƒŒåŒ…é—®é¢˜", "LIS", "LCS", "ç¼–è¾‘è·ç¦»"],
    "å›æº¯": ["å…¨æ’åˆ—", "å­é›†", "Nçš‡å", "æ•°ç‹¬"]
}

# è§£é¢˜æ¨¡æ¿
solution_templates = {
    "äºŒåˆ†æŸ¥æ‰¾": """
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
    """,

    "æ»‘åŠ¨çª—å£": """
    left = 0
    for right in range(len(nums)):
        # æ‰©å¤§çª—å£
        # æ”¶ç¼©çª—å£
        while condition:
            left += 1
    """
}
```

## è¿›é˜¶æŠ€å·§ï¼šé«˜çº§ç®—æ³•æ€æƒ³

### åˆ†æ²»ï¼šå¤§é—®é¢˜åŒ–å°é—®é¢˜

**æ ¸å¿ƒæ€æƒ³**ï¼šå°†é—®é¢˜åˆ†è§£ä¸ºç‹¬ç«‹çš„å­é—®é¢˜

**ç»å…¸åº”ç”¨**ï¼š
```python
# å½’å¹¶æ’åº
def merge_sort(nums):
    if len(nums) <= 1:
        return nums

    mid = len(nums) // 2
    left = merge_sort(nums[:mid])
    right = merge_sort(nums[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

### è´ªå¿ƒï¼šå±€éƒ¨æœ€ä¼˜é€‰æ‹©

**æ ¸å¿ƒæ€æƒ³**ï¼šæ¯ä¸€æ­¥éƒ½é€‰æ‹©å½“å‰æœ€ä¼˜çš„é€‰æ‹©

**åº”ç”¨åœºæ™¯**ï¼š
```python
# æ´»åŠ¨é€‰æ‹©é—®é¢˜
def activity_selection(start, finish):
    n = len(start)
    selected = [0]  # é€‰æ‹©ç¬¬ä¸€ä¸ªæ´»åŠ¨
    j = 0

    for i in range(1, n):
        if start[i] >= finish[j]:
            selected.append(i)
            j = i

    return selected
```

### ä½è¿ç®—ï¼šåº•å±‚ä¼˜åŒ–

**æ ¸å¿ƒæ€æƒ³**ï¼šåˆ©ç”¨ä½è¿ç®—çš„ç‰¹æ€§è¿›è¡Œä¼˜åŒ–

**å¸¸ç”¨æŠ€å·§**ï¼š
```python
# åˆ¤æ–­å¥‡å¶
def is_even(n):
    return (n & 1) == 0

# è®¡ç®—2çš„å¹‚
def is_power_of_two(n):
    return n > 0 and (n & (n - 1)) == 0

# è®¡ç®—æ±‰æ˜è·ç¦»
def hamming_distance(x, y):
    xor = x ^ y
    distance = 0
    while xor:
        distance += xor & 1
        xor >>= 1
    return distance
```

## å­¦ä¹ è·¯å¾„ï¼šä»å…¥é—¨åˆ°ç²¾é€š

### åˆçº§é˜¶æ®µï¼šåŸºç¡€ç®—æ³•

**å­¦ä¹ ç›®æ ‡**ï¼š
- æŒæ¡åŸºæœ¬æ•°æ®ç»“æ„
- ç†è§£å¸¸è§ç®—æ³•æ€æƒ³
- èƒ½å¤Ÿå®ç°ç®€å•ç®—æ³•

**æ¨èé¢˜ç›®**ï¼š
1. æ•°ç»„ï¼šä¸¤æ•°ä¹‹å’Œã€æœ€å¤§å­æ•°ç»„å’Œ
2. é“¾è¡¨ï¼šåè½¬é“¾è¡¨ã€æ£€æµ‹ç¯
3. å­—ç¬¦ä¸²ï¼šå›æ–‡åˆ¤æ–­ã€å­—ç¬¦ä¸²åŒ¹é…
4. æ ‘ï¼šéå†ã€æ·±åº¦ã€å¹³è¡¡

### ä¸­çº§é˜¶æ®µï¼šç®—æ³•ä¼˜åŒ–

**å­¦ä¹ ç›®æ ‡**ï¼š
- æŒæ¡ä¼˜åŒ–æŠ€å·§
- ç†è§£å¤æ‚åº¦åˆ†æ
- èƒ½å¤Ÿé€‰æ‹©åˆé€‚ç®—æ³•

**æ¨èé¢˜ç›®**ï¼š
1. åŠ¨æ€è§„åˆ’ï¼šèƒŒåŒ…é—®é¢˜ã€LIS
2. å›æº¯ï¼šå…¨æ’åˆ—ã€Nçš‡å
3. å›¾è®ºï¼šDFSã€BFSã€æœ€çŸ­è·¯å¾„
4. é«˜çº§æ•°æ®ç»“æ„ï¼šå †ã€Trieã€å¹¶æŸ¥é›†

### é«˜çº§é˜¶æ®µï¼šç®—æ³•è®¾è®¡

**å­¦ä¹ ç›®æ ‡**ï¼š
- èƒ½å¤Ÿè®¾è®¡æ–°ç®—æ³•
- ç†è§£ç®—æ³•è¯æ˜
- æŒæ¡é«˜çº§æŠ€å·§

**æ¨èé¢˜ç›®**ï¼š
1. é«˜çº§åŠ¨æ€è§„åˆ’ï¼šçŠ¶æ€å‹ç¼©ã€æ•°ä½DP
2. ç½‘ç»œæµï¼šæœ€å¤§æµã€æœ€å°å‰²
3. è®¡ç®—å‡ ä½•ï¼šå‡¸åŒ…ã€æœ€è¿‘ç‚¹å¯¹
4. é«˜çº§æ•°æ®ç»“æ„ï¼šçº¿æ®µæ ‘ã€æ ‘çŠ¶æ•°ç»„

## æ€»ç»“ä¸åæ€

### æˆ‘çš„ç®—æ³•å­¦ä¹ å¿ƒå¾—

**ä»æš´åŠ›åˆ°ä¼˜é›…**ï¼š
- åˆæœŸï¼šè¿½æ±‚èƒ½è·‘é€šçš„è§£æ³•
- ä¸­æœŸï¼šè¿½æ±‚æ—¶é—´å¤æ‚åº¦çš„ä¼˜åŒ–
- ç°åœ¨ï¼šè¿½æ±‚ä»£ç çš„ä¼˜é›…å’Œå¯è¯»æ€§

**ä»æ¨¡ä»¿åˆ°åˆ›é€ **ï¼š
- åˆæœŸï¼šæ¨¡ä»¿åˆ«äººçš„è§£æ³•
- ä¸­æœŸï¼šç†è§£ç®—æ³•æ€æƒ³
- ç°åœ¨ï¼šèƒ½å¤Ÿè®¾è®¡æ–°ç®—æ³•

**ä»åˆ·é¢˜åˆ°æ€è€ƒ**ï¼š
- åˆæœŸï¼šè¿½æ±‚é¢˜ç›®æ•°é‡
- ä¸­æœŸï¼šè¿½æ±‚è§£é¢˜è´¨é‡
- ç°åœ¨ï¼šè¿½æ±‚æ€ç»´æ·±åº¦

### å…³é”®æ”¶è·

1. **ç®—æ³•æ€ç»´æ¯”ç®—æ³•çŸ¥è¯†æ›´é‡è¦**
   - é—®é¢˜åˆ†è§£èƒ½åŠ›
   - æ¨¡å¼è¯†åˆ«èƒ½åŠ›
   - ä¼˜åŒ–æ€ç»´èƒ½åŠ›

2. **å®è·µæ˜¯æœ€å¥½çš„è€å¸ˆ**
   - å¤šåšé¢˜ï¼Œå¤šæ€è€ƒ
   - ä»é”™è¯¯ä¸­å­¦ä¹ 
   - æ€»ç»“è§£é¢˜æ¨¡å¼

3. **æŒç»­å­¦ä¹ æ˜¯å¿…è¦çš„**
   - ç®—æ³•é¢†åŸŸå‘å±•å¾ˆå¿«
   - æ–°é—®é¢˜ä¸æ–­å‡ºç°
   - éœ€è¦ä¿æŒå­¦ä¹ çƒ­æƒ…

### ç»™å…¶ä»–å­¦ä¹ è€…çš„å»ºè®®

1. **æ‰“å¥½åŸºç¡€**
   - æŒæ¡åŸºæœ¬æ•°æ®ç»“æ„
   - ç†è§£å¸¸è§ç®—æ³•æ€æƒ³
   - ç»ƒä¹ åŸºç¡€é¢˜ç›®

2. **ç³»ç»Ÿå­¦ä¹ **
   - æŒ‰ä¸»é¢˜åˆ†ç±»å­¦ä¹ 
   - ç†è§£ç®—æ³•åŸç†
   - æ€»ç»“è§£é¢˜æ¨¡æ¿

3. **æŒç»­ç»ƒä¹ **
   - æ¯å¤©åˆ·é¢˜
   - å‚åŠ æ¯”èµ›
   - ä¸ä»–äººäº¤æµ

## å‚è€ƒèµ„æ–™

### ç»å…¸ä¹¦ç±
- [ã€Šç®—æ³•å¯¼è®ºã€‹](https://book.douban.com/subject/20432061/)ï¼šç®—æ³•å­¦ä¹ çš„åœ£ç»
- [ã€Šç¼–ç¨‹ç ç‘ã€‹](https://book.douban.com/subject/3227098/)ï¼šç®—æ³•æ€ç»´çš„ç»å…¸
- [ã€Šç®—æ³•ã€‹](https://book.douban.com/subject/19952400/)ï¼šJavaç‰ˆæœ¬çš„ç®—æ³•æ•™æ

### åœ¨çº¿èµ„æº
- [LeetCode](https://leetcode.com/)ï¼šç®—æ³•ç»ƒä¹ å¹³å°
- [HackerRank](https://www.hackerrank.com/)ï¼šç¼–ç¨‹æŒ‘æˆ˜å¹³å°
- [Codeforces](https://codeforces.com/)ï¼šç®—æ³•ç«èµ›å¹³å°

### å­¦ä¹ å·¥å…·
- [VisuAlgo](https://visualgo.net/)ï¼šç®—æ³•å¯è§†åŒ–
- [Algorithm Visualizer](https://algorithm-visualizer.org/)ï¼šç®—æ³•åŠ¨ç”»
- [Big-O Complexity Chart](https://www.bigocheatsheet.com/)ï¼šå¤æ‚åº¦å‚è€ƒ

## ç»“è¯­

ç®—æ³•å­¦ä¹ æ˜¯ä¸€ä¸ªé•¿æœŸçš„è¿‡ç¨‹ï¼Œéœ€è¦è€å¿ƒå’ŒåšæŒã€‚

ä»æš´åŠ›è§£æ³•åˆ°æœ€ä¼˜è§£ï¼Œä»O(nÂ²)åˆ°O(n log n)ï¼Œæ¯ä¸€æ¬¡ä¼˜åŒ–éƒ½è®©æˆ‘å¯¹ç®—æ³•æœ‰äº†æ›´æ·±çš„ç†è§£ã€‚

è®°ä½ï¼Œç®—æ³•ä¸ä»…ä»…æ˜¯è§£é¢˜æŠ€å·§ï¼Œæ›´æ˜¯ä¸€ç§æ€ç»´æ–¹å¼ã€‚å®ƒæ•™ä¼šäº†æˆ‘å¦‚ä½•åˆ†æé—®é¢˜ã€å¦‚ä½•è®¾è®¡è§£å†³æ–¹æ¡ˆã€å¦‚ä½•ä¼˜åŒ–æ€§èƒ½ã€‚

è™½ç„¶å­¦ä¹ è¿‡ç¨‹ä¸­é‡åˆ°äº†å¾ˆå¤šå›°éš¾ï¼Œä½†æ¯ä¸€æ¬¡"å¡å£³"éƒ½æ˜¯æˆé•¿çš„æœºä¼šã€‚ç°åœ¨ï¼Œç®—æ³•æ€ç»´å·²ç»æˆä¸ºæˆ‘è§£å†³é—®é¢˜çš„é‡è¦å·¥å…·ã€‚

---

> ğŸ’¡ **å®ç”¨å°è´´å£«**ï¼šå½“ä½ é‡åˆ°ç®—æ³•é¢˜æ—¶ï¼Œä¸è¦æ€¥äºå†™ä»£ç ã€‚å…ˆç†è§£é—®é¢˜ï¼Œå†è®¾è®¡ç®—æ³•ï¼Œæœ€åå®ç°ä»£ç ã€‚è®°ä½ï¼Œæ€è€ƒæ¯”ç¼–ç æ›´é‡è¦ï¼

*"åœ¨ç®—æ³•çš„ä¸–ç•Œé‡Œï¼Œè®©æŠ€æœ¯åºŸæŸ´ä¹Ÿèƒ½æˆä¸ºç®—æ³•ä¸“å®¶ï¼"* ğŸ’»
7:T4882,
# LeetCodeåˆ·é¢˜å®æˆ˜ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•è¿›é˜¶ä¹‹è·¯

> ä»"æš´åŠ›è§£æ³•"åˆ°"ä¼˜é›…ç®—æ³•"ï¼Œæˆ‘çš„LeetCodeåˆ·é¢˜è¿›åŒ–å²

## æˆ‘ä¸LeetCodeçš„"ç›¸çˆ±ç›¸æ€"

### ç¬¬ä¸€æ¬¡"ç¿»è½¦"ï¼šæš´åŠ›è§£æ³•çš„ç¾éš¾

è¿˜è®°å¾—ç¬¬ä¸€æ¬¡é‡åˆ°LeetCodeé¢˜ç›®æ—¶ï¼Œæˆ‘ä¿¡å¿ƒæ»¡æ»¡åœ°å¼€å§‹ç¼–ç ï¼š

```cpp
// æˆ‘çš„ç¬¬ä¸€ä¸ª"æ°ä½œ" - æš´åŠ›è§£æ³•
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;

        // æš´åŠ›æšä¸¾æ‰€æœ‰ç»„åˆ
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                if (nums[i] + nums[j] == target) {
                    result.push_back(i);
                    result.push_back(j);
                    return result;
                }
            }
        }

        return result;
    }
};
```

ç»“æœå‘¢ï¼Ÿæ—¶é—´å¤æ‚åº¦O(nÂ²)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ï¼Œå°æ•°ç»„è¿˜èƒ½è·‘ï¼Œå¤§æ•°ç»„ç›´æ¥è¶…æ—¶ã€‚å¯¼å¸ˆçœ‹åˆ°åç›´æ¥ç»™æˆ‘å‘äº†ä¸ª"ğŸ¤¦â€â™‚ï¸"çš„è¡¨æƒ…ï¼š"ä½ è¿™æ˜¯åœ¨åš'æš´åŠ›ç®—æ³•ç¾éš¾'å—ï¼Ÿ"

### ç¬¬äºŒæ¬¡å°è¯•ï¼šä¼˜åŒ–ç®—æ³•çš„è§‰é†’

å¥½ä¸å®¹æ˜“å­¦ä¼šäº†å“ˆå¸Œè¡¨ï¼Œæˆ‘åˆå¼€å§‹æŒ‘æˆ˜ä¼˜åŒ–ç®—æ³•ï¼š

```cpp
// æˆ‘çš„"ä¼˜åŒ–ç®—æ³•"æ°ä½œ
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> numMap;
        vector<int> result;

        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];

            if (numMap.find(complement) != numMap.end()) {
                result.push_back(numMap[complement]);
                result.push_back(i);
                return result;
            }

            numMap[nums[i]] = i;
        }

        return result;
    }
};
```

è¿™æ¬¡å¥½å¤šäº†ï¼æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ï¼Œä½†ä»£ç å¤æ‚åº¦ç›´çº¿ä¸Šå‡ï¼Œè°ƒè¯•å›°éš¾ã€‚æˆ‘çš„"ä¼˜åŒ–ç®—æ³•"å˜æˆäº†"å¤æ‚ä»£ç "ã€‚

### è§‰é†’æ—¶åˆ»ï¼šLeetCodeä¸æ˜¯åˆ·é¢˜ï¼Œæ˜¯æ€ç»´è®­ç»ƒ

ç»è¿‡æ— æ•°æ¬¡çš„"ç¿»è½¦"ç»å†ï¼Œæˆ‘ç»ˆäºæ˜ç™½ï¼šLeetCodeä¸ä»…ä»…æ˜¯åˆ·é¢˜ï¼Œæ›´æ˜¯ä¸€ç§æ€ç»´è®­ç»ƒã€‚å…³é”®æ˜¯è¦ç†è§£é—®é¢˜çš„æœ¬è´¨ï¼Œæ‰¾åˆ°æœ€ä¼˜çš„è§£å†³æ–¹æ¡ˆã€‚

## æ’åºç®—æ³•ï¼šä»åŸºç¡€åˆ°å®æˆ˜

### 1. é€‰æ‹©æ’åºï¼šç®€å•ä½†ä½æ•ˆ

**é—®é¢˜åœºæ™¯ï¼š** éœ€è¦ç†è§£æ’åºç®—æ³•çš„åŸºæœ¬æ€æƒ³

**æš´åŠ›è§£æ³•ï¼š**
```cpp
void selectionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        swap(arr[i], arr[minIndex]);
    }
}
```

**ä¼˜åŒ–æ€è·¯ï¼š**
- æ¯æ¬¡é€‰æ‹©æœ€å°å…ƒç´ æ”¾åˆ°å‰é¢
- æ—¶é—´å¤æ‚åº¦ï¼šO(nÂ²)
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)
- ç¨³å®šæ€§ï¼šä¸ç¨³å®š

**å®æˆ˜åº”ç”¨ï¼š**
```cpp
// LeetCode 912: æ’åºæ•°ç»„
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        selectionSort(nums);
        return nums;
    }

private:
    void selectionSort(vector<int>& arr) {
        int n = arr.size();
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            swap(arr[i], arr[minIndex]);
        }
    }
};
```

### 2. å†’æ³¡æ’åºï¼šç¨³å®šä½†ä½æ•ˆ

**é—®é¢˜åœºæ™¯ï¼š** éœ€è¦ç¨³å®šçš„æ’åºç®—æ³•

**åŸºç¡€å®ç°ï¼š**
```cpp
void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        bool swapped = false;
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        if (!swapped) break; // ä¼˜åŒ–ï¼šå¦‚æœæ²¡æœ‰äº¤æ¢ï¼Œè¯´æ˜å·²ç»æœ‰åº
    }
}
```

**ä¼˜åŒ–æŠ€å·§ï¼š**
- æ·»åŠ swappedæ ‡å¿—ï¼Œæå‰é€€å‡º
- è®°å½•æœ€åä¸€æ¬¡äº¤æ¢ä½ç½®
- åŒå‘å†’æ³¡ï¼ˆé¸¡å°¾é…’æ’åºï¼‰

**å®æˆ˜åº”ç”¨ï¼š**
```cpp
// LeetCode 283: ç§»åŠ¨é›¶
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // ä½¿ç”¨å†’æ³¡æ’åºçš„æ€æƒ³ï¼Œå°†éé›¶å…ƒç´ "å†’æ³¡"åˆ°å‰é¢
        int n = nums.size();
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (nums[j] == 0 && nums[j + 1] != 0) {
                    swap(nums[j], nums[j + 1]);
                }
            }
        }
    }
};
```

### 3. æ’å…¥æ’åºï¼šå°æ•°æ®é‡çš„ç‹è€…

**é—®é¢˜åœºæ™¯ï¼š** å°æ•°æ®é‡æˆ–éƒ¨åˆ†æœ‰åºæ•°æ®

**åŸºç¡€å®ç°ï¼š**
```cpp
void insertionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

**ä¼˜åŒ–æŠ€å·§ï¼š**
- äºŒåˆ†æŸ¥æ‰¾ä¼˜åŒ–æ’å…¥ä½ç½®
- å¸Œå°”æ’åºï¼ˆåˆ†ç»„æ’å…¥ï¼‰

**å®æˆ˜åº”ç”¨ï¼š**
```cpp
// LeetCode 147: å¯¹é“¾è¡¨è¿›è¡Œæ’å…¥æ’åº
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        if (!head || !head->next) return head;

        ListNode* dummy = new ListNode(0);
        ListNode* current = head;

        while (current) {
            ListNode* next = current->next;
            ListNode* prev = dummy;

            // æ‰¾åˆ°æ’å…¥ä½ç½®
            while (prev->next && prev->next->val < current->val) {
                prev = prev->next;
            }

            // æ’å…¥èŠ‚ç‚¹
            current->next = prev->next;
            prev->next = current;
            current = next;
        }

        return dummy->next;
    }
};
```

## ä½è¿ç®—ï¼šé«˜æ•ˆç®—æ³•çš„ç§˜å¯†æ­¦å™¨

### 1. å¼‚æˆ–è¿ç®—ï¼šæ¶ˆé™¤é‡å¤å…ƒç´ 

**æ ¸å¿ƒæ€§è´¨ï¼š**
- a âŠ• a = 0ï¼ˆç›¸åŒå…ƒç´ å¼‚æˆ–ä¸º0ï¼‰
- a âŠ• 0 = aï¼ˆä»»ä½•æ•°ä¸0å¼‚æˆ–ç­‰äºæœ¬èº«ï¼‰
- a âŠ• b âŠ• a = bï¼ˆäº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼‰

**å®æˆ˜åº”ç”¨ï¼š**
```cpp
// LeetCode 136: åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;  // å¼‚æˆ–è¿ç®—æ¶ˆé™¤é‡å¤å…ƒç´ 
        }
        return result;
    }
};

// LeetCode 268: ä¸¢å¤±çš„æ•°å­—
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int result = nums.size();  // ä»0åˆ°nï¼Œæ€»å…±n+1ä¸ªæ•°
        for (int i = 0; i < nums.size(); i++) {
            result ^= i ^ nums[i];  // å¼‚æˆ–è¿ç®—æ‰¾å‡ºç¼ºå¤±çš„æ•°å­—
        }
        return result;
    }
};
```

### 2. ä½è¿ç®—æŠ€å·§ï¼šçŠ¶æ€å‹ç¼©

**é—®é¢˜åœºæ™¯ï¼š** éœ€è¦è¡¨ç¤ºå¤šä¸ªçŠ¶æ€æˆ–ç»„åˆ

**åŸºç¡€æŠ€å·§ï¼š**
```cpp
// ä½è¿ç®—åŸºç¡€æ“ä½œ
class BitOperations {
public:
    // æ£€æŸ¥ç¬¬iä½æ˜¯å¦ä¸º1
    bool isSet(int num, int i) {
        return (num & (1 << i)) != 0;
    }

    // è®¾ç½®ç¬¬iä½ä¸º1
    int setBit(int num, int i) {
        return num | (1 << i);
    }

    // æ¸…é™¤ç¬¬iä½
    int clearBit(int num, int i) {
        return num & ~(1 << i);
    }

    // ç¿»è½¬ç¬¬iä½
    int toggleBit(int num, int i) {
        return num ^ (1 << i);
    }

    // è®¡ç®—1çš„ä¸ªæ•°
    int countOnes(int num) {
        int count = 0;
        while (num) {
            count += num & 1;
            num >>= 1;
        }
        return count;
    }

    // è®¡ç®—1çš„ä¸ªæ•°ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
    int countOnesOptimized(int num) {
        int count = 0;
        while (num) {
            num &= (num - 1);  // æ¸…é™¤æœ€ä½ä½çš„1
            count++;
        }
        return count;
    }
};
```

**å®æˆ˜åº”ç”¨ï¼š**
```cpp
// LeetCode 78: å­é›†
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> result;
        int n = nums.size();
        int total = 1 << n;  // 2^nä¸ªå­é›†

        for (int i = 0; i < total; i++) {
            vector<int> subset;
            for (int j = 0; j < n; j++) {
                if (i & (1 << j)) {  // æ£€æŸ¥ç¬¬jä½æ˜¯å¦ä¸º1
                    subset.push_back(nums[j]);
                }
            }
            result.push_back(subset);
        }

        return result;
    }
};

// LeetCode 338: æ¯”ç‰¹ä½è®¡æ•°
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> result(n + 1);
        for (int i = 0; i <= n; i++) {
            result[i] = countOnes(i);
        }
        return result;
    }

private:
    int countOnes(int num) {
        int count = 0;
        while (num) {
            count += num & 1;
            num >>= 1;
        }
        return count;
    }
};
```

## å“ˆå¸Œè¡¨ï¼šå¿«é€ŸæŸ¥æ‰¾çš„åˆ©å™¨

### 1. åŸºç¡€å“ˆå¸Œè¡¨æ“ä½œ

**C++ STLå“ˆå¸Œè¡¨ï¼š**
```cpp
// unordered_mapåŸºç¡€æ“ä½œ
class HashTableOperations {
public:
    // åŸºæœ¬æ“ä½œ
    void basicOperations() {
        unordered_map<int, int> hashMap;

        // æ’å…¥å…ƒç´ 
        hashMap[1] = 100;
        hashMap.insert({2, 200});
        hashMap.emplace(3, 300);

        // æŸ¥æ‰¾å…ƒç´ 
        if (hashMap.find(1) != hashMap.end()) {
            cout << "æ‰¾åˆ°å…ƒç´ : " << hashMap[1] << endl;
        }

        // åˆ é™¤å…ƒç´ 
        hashMap.erase(1);

        // éå†
        for (const auto& pair : hashMap) {
            cout << pair.first << ": " << pair.second << endl;
        }
    }

    // è®¡æ•°
    void countElements(vector<int>& nums) {
        unordered_map<int, int> count;
        for (int num : nums) {
            count[num]++;
        }

        // æ‰¾å‡ºå‡ºç°æ¬¡æ•°æœ€å¤šçš„å…ƒç´ 
        int maxCount = 0;
        int maxElement = 0;
        for (const auto& pair : count) {
            if (pair.second > maxCount) {
                maxCount = pair.second;
                maxElement = pair.first;
            }
        }
    }
};
```

### 2. å“ˆå¸Œè¡¨å®æˆ˜åº”ç”¨

**ä¸¤æ•°ä¹‹å’Œä¼˜åŒ–ï¼š**
```cpp
// LeetCode 1: ä¸¤æ•°ä¹‹å’Œï¼ˆä¼˜åŒ–ç‰ˆï¼‰
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> numMap;

        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];

            if (numMap.find(complement) != numMap.end()) {
                return {numMap[complement], i};
            }

            numMap[nums[i]] = i;
        }

        return {};
    }
};
```

**ä¸‰æ•°ä¹‹å’Œï¼š**
```cpp
// LeetCode 15: ä¸‰æ•°ä¹‹å’Œ
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        int n = nums.size();

        if (n < 3) return result;

        sort(nums.begin(), nums.end());  // æ’åº

        for (int i = 0; i < n - 2; i++) {
            // è·³è¿‡é‡å¤å…ƒç´ 
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int left = i + 1;
            int right = n - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if (sum == 0) {
                    result.push_back({nums[i], nums[left], nums[right]});

                    // è·³è¿‡é‡å¤å…ƒç´ 
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;

                    left++;
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }

        return result;
    }
};
```

## åˆ·é¢˜æŠ€å·§ï¼šä»æš´åŠ›åˆ°ä¼˜é›…

### 1. è§£é¢˜æ€è·¯æ¡†æ¶

**å››æ­¥è§£é¢˜æ³•ï¼š**
```cpp
class ProblemSolvingFramework {
public:
    vector<int> solveProblem(vector<int>& nums, int target) {
        // æ­¥éª¤1ï¼šç†è§£é—®é¢˜
        // - è¾“å…¥ï¼šæ•´æ•°æ•°ç»„numsï¼Œç›®æ ‡å€¼target
        // - è¾“å‡ºï¼šä¸¤ä¸ªæ•°çš„ç´¢å¼•ï¼Œä½¿å¾—å®ƒä»¬çš„å’Œç­‰äºtarget
        // - çº¦æŸï¼šæ¯ä¸ªè¾“å…¥åªæœ‰ä¸€ä¸ªç­”æ¡ˆï¼Œä¸èƒ½é‡å¤ä½¿ç”¨åŒä¸€ä¸ªå…ƒç´ 

        // æ­¥éª¤2ï¼šåˆ†æå¤æ‚åº¦è¦æ±‚
        // - æ—¶é—´å¤æ‚åº¦ï¼šO(n)æˆ–O(nÂ²)
        // - ç©ºé—´å¤æ‚åº¦ï¼šO(1)æˆ–O(n)

        // æ­¥éª¤3ï¼šé€‰æ‹©ç®—æ³•
        // - æš´åŠ›è§£æ³•ï¼šO(nÂ²)æ—¶é—´ï¼ŒO(1)ç©ºé—´
        // - å“ˆå¸Œè¡¨ï¼šO(n)æ—¶é—´ï¼ŒO(n)ç©ºé—´

        // æ­¥éª¤4ï¼šå®ç°ä»£ç 
        return twoSumOptimized(nums, target);
    }

private:
    // æš´åŠ›è§£æ³•
    vector<int> twoSumBruteForce(vector<int>& nums, int target) {
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};
    }

    // ä¼˜åŒ–è§£æ³•
    vector<int> twoSumOptimized(vector<int>& nums, int target) {
        unordered_map<int, int> numMap;

        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];

            if (numMap.find(complement) != numMap.end()) {
                return {numMap[complement], i};
            }

            numMap[nums[i]] = i;
        }

        return {};
    }
};
```

### 2. å¸¸è§ä¼˜åŒ–æŠ€å·§

**åŒæŒ‡é’ˆæŠ€å·§ï¼š**
```cpp
// åŒæŒ‡é’ˆæ¨¡æ¿
class TwoPointers {
public:
    // æœ‰åºæ•°ç»„çš„ä¸¤æ•°ä¹‹å’Œ
    vector<int> twoSumSorted(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;

        while (left < right) {
            int sum = nums[left] + nums[right];

            if (sum == target) {
                return {left, right};
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }

        return {};
    }

    // ç§»é™¤é‡å¤å…ƒç´ 
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) return 0;

        int slow = 0;
        for (int fast = 1; fast < nums.size(); fast++) {
            if (nums[fast] != nums[slow]) {
                slow++;
                nums[slow] = nums[fast];
            }
        }

        return slow + 1;
    }

    // ç››æœ€å¤šæ°´çš„å®¹å™¨
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int maxArea = 0;

        while (left < right) {
            int area = min(height[left], height[right]) * (right - left);
            maxArea = max(maxArea, area);

            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return maxArea;
    }
};
```

**æ»‘åŠ¨çª—å£æŠ€å·§ï¼š**
```cpp
// æ»‘åŠ¨çª—å£æ¨¡æ¿
class SlidingWindow {
public:
    // æœ€å°å­æ•°ç»„é•¿åº¦
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0;
        int sum = 0;
        int minLen = INT_MAX;

        for (int right = 0; right < nums.size(); right++) {
            sum += nums[right];

            while (sum >= target) {
                minLen = min(minLen, right - left + 1);
                sum -= nums[left];
                left++;
            }
        }

        return minLen == INT_MAX ? 0 : minLen;
    }

    // æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> charSet;
        int left = 0;
        int maxLen = 0;

        for (int right = 0; right < s.length(); right++) {
            while (charSet.find(s[right]) != charSet.end()) {
                charSet.erase(s[left]);
                left++;
            }

            charSet.insert(s[right]);
            maxLen = max(maxLen, right - left + 1);
        }

        return maxLen;
    }
};
```

## æ€»ç»“ä¸åæ€

### LeetCodeåˆ·é¢˜çš„ä»·å€¼

1. **ç®—æ³•æ€ç»´è®­ç»ƒ**ï¼šåŸ¹å…»é€»è¾‘æ€ç»´å’Œé—®é¢˜è§£å†³èƒ½åŠ›
2. **ç¼–ç¨‹æŠ€å·§æå‡**ï¼šæŒæ¡é«˜æ•ˆçš„ç¼–ç¨‹æŠ€å·§å’Œæ–¹æ³•
3. **é¢è¯•å‡†å¤‡**ï¼šä¸ºæŠ€æœ¯é¢è¯•æ‰“ä¸‹åšå®åŸºç¡€
4. **ä»£ç è´¨é‡**ï¼šæé«˜ä»£ç çš„å¯è¯»æ€§å’Œæ•ˆç‡

### æˆ‘çš„å­¦ä¹ å¿ƒå¾—

1. **ä»æš´åŠ›å¼€å§‹**ï¼šå…ˆå†™æš´åŠ›è§£æ³•ï¼Œå†ä¼˜åŒ–
2. **ç†è§£ç®—æ³•æœ¬è´¨**ï¼šä¸è¦æ­»è®°ç¡¬èƒŒï¼Œè¦ç†è§£åŸç†
3. **å¤šæ€»ç»“æ¨¡å¼**ï¼šæ€»ç»“å¸¸è§é¢˜å‹çš„è§£é¢˜æ¨¡å¼
4. **åšæŒç»ƒä¹ **ï¼šæ¯å¤©åˆ·é¢˜ï¼Œä¿æŒæ‰‹æ„Ÿ

### ç»™å…¶ä»–"åºŸæŸ´"çš„å»ºè®®

1. **ä¸è¦å®³æ€•å›°éš¾**ï¼šç®—æ³•å­¦ä¹ éœ€è¦æ—¶é—´å’Œè€å¿ƒ
2. **ä¿æŒç»ƒä¹ **ï¼šæ¯å¤©åˆ·é¢˜ï¼Œä¿æŒæ‰‹æ„Ÿ
3. **å­¦ä¹ ä»–äºº**ï¼šå‚è€ƒä¼˜ç§€çš„è§£é¢˜æ€è·¯å’Œä»£ç 
4. **å»ºç«‹ä½“ç³»**ï¼šå½¢æˆè‡ªå·±çš„ç®—æ³•çŸ¥è¯†ä½“ç³»

## å‚è€ƒèµ„æ–™

- [LeetCodeå®˜æ–¹](https://leetcode.com/)
- [LeetCodeä¸­æ–‡ç½‘](https://leetcode.cn/)
- [ç®—æ³•å¯è§†åŒ–](https://visualgo.net/)
- [C++ STLæ–‡æ¡£](https://en.cppreference.com/)

## ç»“è¯­

LeetCodeåˆ·é¢˜æ˜¯ä¸€ä¸ªå……æ»¡æŒ‘æˆ˜å’Œä¹è¶£çš„è¿‡ç¨‹ã€‚ä»æœ€åˆçš„"æš´åŠ›è§£æ³•"åˆ°åæ¥çš„"ä¼˜é›…ç®—æ³•"ï¼Œæ¯ä¸€æ­¥éƒ½æ˜¯æ€ç»´çš„æå‡ã€‚

è®°ä½ï¼Œå¥½çš„ç®—æ³•ä¸æ˜¯ä¸€è¹´è€Œå°±çš„ï¼Œè€Œæ˜¯é€šè¿‡ä¸æ–­ç»ƒä¹ å’Œæ€è€ƒå¾—æ¥çš„ã€‚ä¸è¦å®³æ€•çŠ¯é”™ï¼Œä¸è¦å®³æ€•å›°éš¾ï¼Œæ¯ä¸€æ¬¡å°è¯•éƒ½æ˜¯å­¦ä¹ çš„æœºä¼šã€‚

## å®ç”¨å°è´´å£«

### ğŸ¯ LeetCodeåˆ·é¢˜è·¯å¾„
- [ ] æŒæ¡åŸºç¡€æ•°æ®ç»“æ„ï¼ˆæ•°ç»„ã€é“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ï¼‰
- [ ] å­¦ä¹ åŸºæœ¬ç®—æ³•ï¼ˆæ’åºã€æŸ¥æ‰¾ã€é€’å½’ï¼‰
- [ ] ç†è§£é«˜çº§ç®—æ³•ï¼ˆåŠ¨æ€è§„åˆ’ã€è´ªå¿ƒã€åˆ†æ²»ï¼‰
- [ ] å®è·µå¤æ‚é—®é¢˜ï¼ˆå›¾è®ºã€å­—ç¬¦ä¸²ã€æ•°å­¦ï¼‰
- [ ] ä¼˜åŒ–ç®—æ³•æ€§èƒ½ï¼ˆæ—¶é—´å¤æ‚åº¦ã€ç©ºé—´å¤æ‚åº¦ï¼‰

### ğŸš€ å¿«é€Ÿå¼€å§‹
```cpp
// 1. ç†è§£é—®é¢˜
// 2. åˆ†æå¤æ‚åº¦
// 3. é€‰æ‹©ç®—æ³•
// 4. ç¼–å†™ä»£ç 
// 5. æµ‹è¯•ä¼˜åŒ–

// ç¤ºä¾‹ï¼šä¸¤æ•°ä¹‹å’Œ
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> numMap;
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            if (numMap.find(complement) != numMap.end()) {
                return {numMap[complement], i};
            }
            numMap[nums[i]] = i;
        }
        return {};
    }
};
```

### ğŸ’¡ è¿›é˜¶æŠ€å·§
- æŒæ¡å¸¸è§ç®—æ³•æ¨¡æ¿
- ç†è§£ç®—æ³•æ€æƒ³æœ¬è´¨
- å­¦ä¼šå¤æ‚åº¦åˆ†æ
- åŸ¹å…»è§£é¢˜ç›´è§‰
- å»ºç«‹çŸ¥è¯†ä½“ç³»

9:["ç®—æ³•","æ•°æ®ç»“æ„","ç¼–ç¨‹æŠ€å·§","å­¦ä¹ ç¬”è®°","åŠ¨æ€è§„åˆ’","æ’åºç®—æ³•","è·¨ç•Œæ¢ç´¢"]
a:T900f,
# ç®—æ³•å­¦ä¹ ç¬”è®°ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•æ€ç»´è¿›åŒ–å²

> ä»"æš´åŠ›è§£æ³•"åˆ°"ä¼˜é›…ç®—æ³•"ï¼Œæˆ‘çš„ç®—æ³•æ€ç»´è¿›åŒ–ä¹‹è·¯

## æˆ‘ä¸ç®—æ³•çš„"ç›¸çˆ±ç›¸æ€"

### ç¬¬ä¸€æ¬¡"ç¿»è½¦"ï¼šæš´åŠ›è§£æ³•çš„ç¾éš¾

è¿˜è®°å¾—ç¬¬ä¸€æ¬¡é‡åˆ°ç®—æ³•é¢˜æ—¶ï¼Œæˆ‘ä¿¡å¿ƒæ»¡æ»¡åœ°å¼€å§‹ç¼–ç ï¼š

```python
# æˆ‘çš„ç¬¬ä¸€ä¸ª"æ°ä½œ" - æš´åŠ›è§£æ³•
def find_max_subarray(arr):
    max_sum = float('-inf')
    max_start = 0
    max_end = 0

    # æš´åŠ›æšä¸¾æ‰€æœ‰å­æ•°ç»„
    for i in range(len(arr)):
        for j in range(i, len(arr)):
            current_sum = sum(arr[i:j+1])  # æ¯æ¬¡éƒ½é‡æ–°è®¡ç®—
            if current_sum > max_sum:
                max_sum = current_sum
                max_start = i
                max_end = j

    return max_sum, max_start, max_end

# æµ‹è¯•
arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
result = find_max_subarray(arr)
print(f"æœ€å¤§å­æ•°ç»„å’Œ: {result[0]}, èµ·å§‹ä½ç½®: {result[1]}, ç»“æŸä½ç½®: {result[2]}")
```

ç»“æœå‘¢ï¼Ÿæ—¶é—´å¤æ‚åº¦O(nÂ³)ï¼Œç©ºé—´å¤æ‚åº¦O(1)ï¼Œå°æ•°ç»„è¿˜èƒ½è·‘ï¼Œå¤§æ•°ç»„ç›´æ¥è¶…æ—¶ã€‚å¯¼å¸ˆçœ‹åˆ°åç›´æ¥ç»™æˆ‘å‘äº†ä¸ª"ğŸ¤¦â€â™‚ï¸"çš„è¡¨æƒ…ï¼š"ä½ è¿™æ˜¯åœ¨åš'æš´åŠ›ç®—æ³•ç¾éš¾'å—ï¼Ÿ"

### ç¬¬äºŒæ¬¡å°è¯•ï¼šä¼˜åŒ–ç®—æ³•çš„è§‰é†’

å¥½ä¸å®¹æ˜“å­¦ä¼šäº†åŠ¨æ€è§„åˆ’ï¼Œæˆ‘åˆå¼€å§‹æŒ‘æˆ˜ä¼˜åŒ–ç®—æ³•ï¼š

```python
# æˆ‘çš„"ä¼˜åŒ–ç®—æ³•"æ°ä½œ
def find_max_subarray_dp(arr):
    if not arr:
        return 0, -1, -1

    n = len(arr)
    dp = [0] * n  # dp[i]è¡¨ç¤ºä»¥arr[i]ç»“å°¾çš„æœ€å¤§å­æ•°ç»„å’Œ
    dp[0] = arr[0]

    max_sum = dp[0]
    max_end = 0

    # åŠ¨æ€è§„åˆ’
    for i in range(1, n):
        dp[i] = max(arr[i], dp[i-1] + arr[i])
        if dp[i] > max_sum:
            max_sum = dp[i]
            max_end = i

    # å›æº¯æ‰¾åˆ°èµ·å§‹ä½ç½®
    max_start = max_end
    current_sum = max_sum
    while max_start > 0 and current_sum > 0:
        current_sum -= arr[max_start]
        max_start -= 1

    return max_sum, max_start + 1, max_end

# æµ‹è¯•
arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
result = find_max_subarray_dp(arr)
print(f"æœ€å¤§å­æ•°ç»„å’Œ: {result[0]}, èµ·å§‹ä½ç½®: {result[1]}, ç»“æŸä½ç½®: {result[2]}")
```

è¿™æ¬¡å¥½å¤šäº†ï¼æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)ï¼Œä½†ä»£ç å¤æ‚åº¦ç›´çº¿ä¸Šå‡ï¼Œè°ƒè¯•å›°éš¾ã€‚æˆ‘çš„"ä¼˜åŒ–ç®—æ³•"å˜æˆäº†"å¤æ‚ä»£ç "ã€‚

### è§‰é†’æ—¶åˆ»ï¼šç®—æ³•ä¸æ˜¯ä»£ç ï¼Œæ˜¯æ€ç»´

ç»è¿‡æ— æ•°æ¬¡çš„"ç¿»è½¦"ç»å†ï¼Œæˆ‘ç»ˆäºæ˜ç™½ï¼šç®—æ³•ä¸ä»…ä»…æ˜¯ä»£ç ï¼Œæ›´æ˜¯ä¸€ç§æ€ç»´æ–¹å¼ã€‚å…³é”®æ˜¯è¦ç†è§£é—®é¢˜çš„æœ¬è´¨ï¼Œæ‰¾åˆ°æœ€ä¼˜çš„è§£å†³æ–¹æ¡ˆã€‚

## ç®—æ³•æ€ç»´ï¼šä»é—®é¢˜åˆ°è§£å†³æ–¹æ¡ˆ

### 1. é—®é¢˜åˆ†æï¼šç†è§£é—®é¢˜çš„æœ¬è´¨

#### é—®é¢˜åˆ†ç±»æ€ç»´

**å¸¸è§é—®é¢˜ç±»å‹ï¼š**
```python
# é—®é¢˜åˆ†ç±»æ¡†æ¶
class ProblemAnalyzer:
    def __init__(self):
        self.problem_types = {
            'array': ['æ’åº', 'æŸ¥æ‰¾', 'å­æ•°ç»„', 'æ’åˆ—ç»„åˆ'],
            'string': ['åŒ¹é…', 'ç¼–è¾‘è·ç¦»', 'å›æ–‡', 'å­åºåˆ—'],
            'tree': ['éå†', 'è·¯å¾„', 'æ„é€ ', 'éªŒè¯'],
            'graph': ['æœç´¢', 'æœ€çŸ­è·¯å¾„', 'è¿é€šæ€§', 'æ‹“æ‰‘æ’åº'],
            'dynamic_programming': ['èƒŒåŒ…', 'åºåˆ—', 'çŸ©é˜µ', 'çŠ¶æ€å‹ç¼©']
        }

    def classify_problem(self, problem_description):
        """æ ¹æ®é—®é¢˜æè¿°åˆ†ç±»é—®é¢˜ç±»å‹"""
        keywords = problem_description.lower().split()

        for category, types in self.problem_types.items():
            for problem_type in types:
                if any(keyword in problem_type for keyword in keywords):
                    return category, problem_type

        return 'unknown', 'unknown'

    def suggest_approach(self, category, problem_type):
        """æ ¹æ®é—®é¢˜ç±»å‹å»ºè®®è§£é¢˜æ€è·¯"""
        approaches = {
            'array': {
                'æ’åº': ['å¿«é€Ÿæ’åº', 'å½’å¹¶æ’åº', 'å †æ’åº'],
                'æŸ¥æ‰¾': ['äºŒåˆ†æŸ¥æ‰¾', 'å“ˆå¸Œè¡¨', 'åŒæŒ‡é’ˆ'],
                'å­æ•°ç»„': ['æ»‘åŠ¨çª—å£', 'å‰ç¼€å’Œ', 'åŠ¨æ€è§„åˆ’'],
                'æ’åˆ—ç»„åˆ': ['å›æº¯', 'é€’å½’', 'æ•°å­¦å…¬å¼']
            },
            'string': {
                'åŒ¹é…': ['KMPç®—æ³•', 'Rabin-Karp', 'æ­£åˆ™è¡¨è¾¾å¼'],
                'ç¼–è¾‘è·ç¦»': ['åŠ¨æ€è§„åˆ’', 'çŠ¶æ€è½¬ç§»'],
                'å›æ–‡': ['ä¸­å¿ƒæ‰©å±•', 'Manacherç®—æ³•'],
                'å­åºåˆ—': ['åŠ¨æ€è§„åˆ’', 'LCSç®—æ³•']
            },
            'tree': {
                'éå†': ['DFS', 'BFS', 'ä¸­åºéå†'],
                'è·¯å¾„': ['æ·±åº¦ä¼˜å…ˆæœç´¢', 'è·¯å¾„è®°å½•'],
                'æ„é€ ': ['é€’å½’æ„é€ ', 'åˆ†æ²»æ€æƒ³'],
                'éªŒè¯': ['æ€§è´¨éªŒè¯', 'éå†éªŒè¯']
            }
        }

        return approaches.get(category, {}).get(problem_type, ['æš´åŠ›è§£æ³•'])

# ä½¿ç”¨ç¤ºä¾‹
analyzer = ProblemAnalyzer()
problem = "ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°å’Œæœ€å¤§çš„è¿ç»­å­æ•°ç»„"
category, problem_type = analyzer.classify_problem(problem)
approaches = analyzer.suggest_approach(category, problem_type)
print(f"é—®é¢˜ç±»å‹: {category} - {problem_type}")
print(f"å»ºè®®æ€è·¯: {approaches}")
```

#### å¤æ‚åº¦åˆ†ææ€ç»´

**ç®—æ³•å¤æ‚åº¦è¯„ä¼°ï¼š**
```python
# å¤æ‚åº¦åˆ†æå·¥å…·
class ComplexityAnalyzer:
    def __init__(self):
        self.complexity_patterns = {
            'O(1)': ['å¸¸æ•°æ—¶é—´', 'å“ˆå¸Œè¡¨æŸ¥æ‰¾', 'æ•°ç»„ç´¢å¼•'],
            'O(log n)': ['äºŒåˆ†æŸ¥æ‰¾', 'æ ‘çš„é«˜åº¦', 'åˆ†æ²»ç®—æ³•'],
            'O(n)': ['çº¿æ€§éå†', 'æ»‘åŠ¨çª—å£', 'åŒæŒ‡é’ˆ'],
            'O(n log n)': ['æ’åºç®—æ³•', 'åˆ†æ²»+åˆå¹¶'],
            'O(nÂ²)': ['åŒé‡å¾ªç¯', 'æš´åŠ›è§£æ³•', 'å†’æ³¡æ’åº'],
            'O(2â¿)': ['é€’å½’', 'å›æº¯', 'ç»„åˆé—®é¢˜'],
            'O(n!)': ['æ’åˆ—', 'å…¨æ’åˆ—', 'æ—…è¡Œå•†é—®é¢˜']
        }

    def analyze_time_complexity(self, code):
        """åˆ†æä»£ç çš„æ—¶é—´å¤æ‚åº¦"""
        lines = code.split('\n')
        max_nested_loops = 0
        current_nesting = 0

        for line in lines:
            if 'for' in line or 'while' in line:
                current_nesting += 1
                max_nested_loops = max(max_nested_loops, current_nesting)
            elif line.strip().startswith('}'):
                current_nesting = max(0, current_nesting - 1)

        complexity_map = {
            0: 'O(1)',
            1: 'O(n)',
            2: 'O(nÂ²)',
            3: 'O(nÂ³)'
        }

        return complexity_map.get(max_nested_loops, f'O(n^{max_nested_loops})')

    def analyze_space_complexity(self, code):
        """åˆ†æä»£ç çš„ç©ºé—´å¤æ‚åº¦"""
        # ç®€å•çš„ç©ºé—´å¤æ‚åº¦åˆ†æ
        if 'dp = [0] * n' in code or 'memo = {}' in code:
            return 'O(n)'
        elif 'matrix = [[0] * n for _ in range(n)]' in code:
            return 'O(nÂ²)'
        elif 'stack = []' in code or 'queue = []' in code:
            return 'O(n)'
        else:
            return 'O(1)'

# ä½¿ç”¨ç¤ºä¾‹
analyzer = ComplexityAnalyzer()
code = """
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
"""

time_complexity = analyzer.analyze_time_complexity(code)
space_complexity = analyzer.analyze_space_complexity(code)
print(f"æ—¶é—´å¤æ‚åº¦: {time_complexity}")
print(f"ç©ºé—´å¤æ‚åº¦: {space_complexity}")
```

### 2. è§£é¢˜ç­–ç•¥ï¼šä»æš´åŠ›åˆ°ä¼˜åŒ–

#### æš´åŠ›è§£æ³•ï¼šç†è§£é—®é¢˜çš„ç¬¬ä¸€æ­¥

**æš´åŠ›è§£æ³•çš„ä»·å€¼ï¼š**
```python
# æš´åŠ›è§£æ³•æ¨¡æ¿
class BruteForceSolver:
    def __init__(self):
        self.solutions = []

    def solve_two_sum_brute(self, nums, target):
        """ä¸¤æ•°ä¹‹å’Œ - æš´åŠ›è§£æ³•"""
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] + nums[j] == target:
                    return [i, j]
        return []

    def solve_three_sum_brute(self, nums):
        """ä¸‰æ•°ä¹‹å’Œ - æš´åŠ›è§£æ³•"""
        n = len(nums)
        result = []

        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j + 1, n):
                    if nums[i] + nums[j] + nums[k] == 0:
                        triplet = sorted([nums[i], nums[j], nums[k]])
                        if triplet not in result:
                            result.append(triplet)

        return result

    def solve_permutations_brute(self, nums):
        """å…¨æ’åˆ— - æš´åŠ›è§£æ³•"""
        if len(nums) <= 1:
            return [nums]

        result = []
        for i in range(len(nums)):
            current = nums[i]
            remaining = nums[:i] + nums[i+1:]

            for perm in self.solve_permutations_brute(remaining):
                result.append([current] + perm)

        return result

# æš´åŠ›è§£æ³•çš„ä»·å€¼
def demonstrate_brute_force_value():
    """æ¼”ç¤ºæš´åŠ›è§£æ³•çš„ä»·å€¼"""
    solver = BruteForceSolver()

    # 1. ç†è§£é—®é¢˜
    print("=== ç†è§£é—®é¢˜ ===")
    nums = [2, 7, 11, 15]
    target = 9
    result = solver.solve_two_sum_brute(nums, target)
    print(f"ä¸¤æ•°ä¹‹å’Œ: {nums}, ç›®æ ‡: {target}, ç»“æœ: {result}")

    # 2. éªŒè¯æ­£ç¡®æ€§
    print("\n=== éªŒè¯æ­£ç¡®æ€§ ===")
    test_cases = [
        ([2, 7, 11, 15], 9),
        ([3, 2, 4], 6),
        ([3, 3], 6)
    ]

    for nums, target in test_cases:
        result = solver.solve_two_sum_brute(nums, target)
        if result:
            actual_sum = nums[result[0]] + nums[result[1]]
            print(f"è¾“å…¥: {nums}, ç›®æ ‡: {target}, ç»“æœ: {result}, éªŒè¯: {actual_sum == target}")

    # 3. æ€§èƒ½åŸºå‡†
    print("\n=== æ€§èƒ½åŸºå‡† ===")
    import time
    large_nums = list(range(1000))
    start_time = time.time()
    result = solver.solve_two_sum_brute(large_nums, 1998)
    end_time = time.time()
    print(f"å¤§æ•°ç»„æš´åŠ›è§£æ³•è€—æ—¶: {end_time - start_time:.4f}ç§’")

demonstrate_brute_force_value()
```

#### ä¼˜åŒ–ç­–ç•¥ï¼šä»æš´åŠ›åˆ°ä¼˜é›…

**å¸¸è§ä¼˜åŒ–ç­–ç•¥ï¼š**
```python
# ä¼˜åŒ–ç­–ç•¥æ¨¡æ¿
class OptimizationStrategies:
    def __init__(self):
        self.strategies = {
            'two_pointers': 'åŒæŒ‡é’ˆæŠ€å·§',
            'sliding_window': 'æ»‘åŠ¨çª—å£',
            'binary_search': 'äºŒåˆ†æŸ¥æ‰¾',
            'dynamic_programming': 'åŠ¨æ€è§„åˆ’',
            'greedy': 'è´ªå¿ƒç®—æ³•',
            'divide_conquer': 'åˆ†æ²»ç®—æ³•'
        }

    def two_sum_optimized(self, nums, target):
        """ä¸¤æ•°ä¹‹å’Œ - å“ˆå¸Œè¡¨ä¼˜åŒ–"""
        num_map = {}

        for i, num in enumerate(nums):
            complement = target - num
            if complement in num_map:
                return [num_map[complement], i]
            num_map[num] = i

        return []

    def three_sum_optimized(self, nums):
        """ä¸‰æ•°ä¹‹å’Œ - åŒæŒ‡é’ˆä¼˜åŒ–"""
        nums.sort()
        result = []
        n = len(nums)

        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            left, right = i + 1, n - 1
            while left < right:
                total = nums[i] + nums[left] + nums[right]

                if total == 0:
                    result.append([nums[i], nums[left], nums[right]])

                    # è·³è¿‡é‡å¤å…ƒç´ 
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1

                    left += 1
                    right -= 1
                elif total < 0:
                    left += 1
                else:
                    right -= 1

        return result

    def max_subarray_optimized(self, nums):
        """æœ€å¤§å­æ•°ç»„å’Œ - Kadaneç®—æ³•"""
        if not nums:
            return 0

        max_sum = current_sum = nums[0]

        for num in nums[1:]:
            current_sum = max(num, current_sum + num)
            max_sum = max(max_sum, current_sum)

        return max_sum

    def longest_increasing_subsequence(self, nums):
        """æœ€é•¿é€’å¢å­åºåˆ— - åŠ¨æ€è§„åˆ’ä¼˜åŒ–"""
        if not nums:
            return 0

        n = len(nums)
        dp = [1] * n

        for i in range(1, n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)

        return max(dp)

# ä¼˜åŒ–æ•ˆæœå¯¹æ¯”
def compare_optimization_effects():
    """å¯¹æ¯”ä¼˜åŒ–æ•ˆæœ"""
    strategies = OptimizationStrategies()

    # ä¸¤æ•°ä¹‹å’Œå¯¹æ¯”
    print("=== ä¸¤æ•°ä¹‹å’Œä¼˜åŒ–å¯¹æ¯” ===")
    nums = list(range(10000))
    target = 19998

    import time

    # æš´åŠ›è§£æ³•
    start_time = time.time()
    result1 = strategies.two_sum_optimized(nums, target)  # ä½¿ç”¨ä¼˜åŒ–ç‰ˆæœ¬
    end_time = time.time()
    print(f"ä¼˜åŒ–è§£æ³•è€—æ—¶: {end_time - start_time:.6f}ç§’")

    # æœ€å¤§å­æ•°ç»„å’Œå¯¹æ¯”
    print("\n=== æœ€å¤§å­æ•°ç»„å’Œä¼˜åŒ–å¯¹æ¯” ===")
    nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
    result = strategies.max_subarray_optimized(nums)
    print(f"æ•°ç»„: {nums}")
    print(f"æœ€å¤§å­æ•°ç»„å’Œ: {result}")

    # ä¸‰æ•°ä¹‹å’Œå¯¹æ¯”
    print("\n=== ä¸‰æ•°ä¹‹å’Œä¼˜åŒ–å¯¹æ¯” ===")
    nums = [-1, 0, 1, 2, -1, -4]
    result = strategies.three_sum_optimized(nums)
    print(f"æ•°ç»„: {nums}")
    print(f"ä¸‰æ•°ä¹‹å’Œä¸º0çš„ç»„åˆ: {result}")

compare_optimization_effects()
```

### 3. æ•°æ®ç»“æ„ï¼šç®—æ³•çš„åŸºçŸ³

#### åŸºç¡€æ•°æ®ç»“æ„ï¼šç†è§£ä¸åº”ç”¨

**å¸¸ç”¨æ•°æ®ç»“æ„å®ç°ï¼š**
```python
# åŸºç¡€æ•°æ®ç»“æ„å®ç°
class DataStructures:
    def __init__(self):
        self.data_structures = {
            'array': 'æ•°ç»„',
            'linked_list': 'é“¾è¡¨',
            'stack': 'æ ˆ',
            'queue': 'é˜Ÿåˆ—',
            'tree': 'æ ‘',
            'graph': 'å›¾',
            'heap': 'å †',
            'hash_table': 'å“ˆå¸Œè¡¨'
        }

    # é“¾è¡¨èŠ‚ç‚¹
    class ListNode:
        def __init__(self, val=0, next=None):
            self.val = val
            self.next = next

    # é“¾è¡¨æ“ä½œ
    def create_linked_list(self, values):
        """åˆ›å»ºé“¾è¡¨"""
        if not values:
            return None

        head = self.ListNode(values[0])
        current = head

        for val in values[1:]:
            current.next = self.ListNode(val)
            current = current.next

        return head

    def reverse_linked_list(self, head):
        """åè½¬é“¾è¡¨"""
        prev = None
        current = head

        while current:
            next_temp = current.next
            current.next = prev
            prev = current
            current = next_temp

        return prev

    def detect_cycle(self, head):
        """æ£€æµ‹é“¾è¡¨ç¯"""
        if not head or not head.next:
            return False

        slow = fast = head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

            if slow == fast:
                return True

        return False

    # æ ˆå®ç°
    class Stack:
        def __init__(self):
            self.items = []

        def push(self, item):
            self.items.append(item)

        def pop(self):
            if not self.is_empty():
                return self.items.pop()
            raise IndexError("Stack is empty")

        def peek(self):
            if not self.is_empty():
                return self.items[-1]
            raise IndexError("Stack is empty")

        def is_empty(self):
            return len(self.items) == 0

        def size(self):
            return len(self.items)

    # é˜Ÿåˆ—å®ç°
    class Queue:
        def __init__(self):
            self.items = []

        def enqueue(self, item):
            self.items.append(item)

        def dequeue(self):
            if not self.is_empty():
                return self.items.pop(0)
            raise IndexError("Queue is empty")

        def front(self):
            if not self.is_empty():
                return self.items[0]
            raise IndexError("Queue is empty")

        def is_empty(self):
            return len(self.items) == 0

        def size(self):
            return len(self.items)

    # äºŒå‰æ ‘èŠ‚ç‚¹
    class TreeNode:
        def __init__(self, val=0, left=None, right=None):
            self.val = val
            self.left = left
            self.right = right

    # äºŒå‰æ ‘éå†
    def inorder_traversal(self, root):
        """ä¸­åºéå†"""
        result = []

        def inorder(node):
            if node:
                inorder(node.left)
                result.append(node.val)
                inorder(node.right)

        inorder(root)
        return result

    def preorder_traversal(self, root):
        """å‰åºéå†"""
        result = []

        def preorder(node):
            if node:
                result.append(node.val)
                preorder(node.left)
                preorder(node.right)

        preorder(root)
        return result

    def postorder_traversal(self, root):
        """ååºéå†"""
        result = []

        def postorder(node):
            if node:
                postorder(node.left)
                postorder(node.right)
                result.append(node.val)

        postorder(root)
        return result

    def level_order_traversal(self, root):
        """å±‚åºéå†"""
        if not root:
            return []

        result = []
        queue = [root]

        while queue:
            level = []
            level_size = len(queue)

            for _ in range(level_size):
                node = queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(level)

        return result

# æ•°æ®ç»“æ„åº”ç”¨ç¤ºä¾‹
def demonstrate_data_structures():
    """æ¼”ç¤ºæ•°æ®ç»“æ„åº”ç”¨"""
    ds = DataStructures()

    # é“¾è¡¨åº”ç”¨
    print("=== é“¾è¡¨åº”ç”¨ ===")
    values = [1, 2, 3, 4, 5]
    head = ds.create_linked_list(values)

    # åè½¬é“¾è¡¨
    reversed_head = ds.reverse_linked_list(head)
    print(f"åŸé“¾è¡¨: {values}")

    # æ£€æµ‹ç¯
    has_cycle = ds.detect_cycle(head)
    print(f"æ˜¯å¦æœ‰ç¯: {has_cycle}")

    # æ ˆåº”ç”¨
    print("\n=== æ ˆåº”ç”¨ ===")
    stack = ds.Stack()
    stack.push(1)
    stack.push(2)
    stack.push(3)
    print(f"æ ˆé¡¶å…ƒç´ : {stack.peek()}")
    print(f"å¼¹å‡ºå…ƒç´ : {stack.pop()}")
    print(f"æ ˆå¤§å°: {stack.size()}")

    # é˜Ÿåˆ—åº”ç”¨
    print("\n=== é˜Ÿåˆ—åº”ç”¨ ===")
    queue = ds.Queue()
    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(3)
    print(f"é˜Ÿé¦–å…ƒç´ : {queue.front()}")
    print(f"å‡ºé˜Ÿå…ƒç´ : {queue.dequeue()}")
    print(f"é˜Ÿåˆ—å¤§å°: {queue.size()}")

    # äºŒå‰æ ‘åº”ç”¨
    print("\n=== äºŒå‰æ ‘åº”ç”¨ ===")
    root = ds.TreeNode(1)
    root.left = ds.TreeNode(2)
    root.right = ds.TreeNode(3)
    root.left.left = ds.TreeNode(4)
    root.left.right = ds.TreeNode(5)

    print(f"ä¸­åºéå†: {ds.inorder_traversal(root)}")
    print(f"å‰åºéå†: {ds.preorder_traversal(root)}")
    print(f"ååºéå†: {ds.postorder_traversal(root)}")
    print(f"å±‚åºéå†: {ds.level_order_traversal(root)}")

demonstrate_data_structures()
```

### 4. é«˜çº§ç®—æ³•ï¼šæ€ç»´çš„è‰ºæœ¯

#### åŠ¨æ€è§„åˆ’ï¼šçŠ¶æ€ä¸è½¬ç§»

**åŠ¨æ€è§„åˆ’æ€ç»´æ¡†æ¶ï¼š**
```python
# åŠ¨æ€è§„åˆ’æ¨¡æ¿
class DynamicProgramming:
    def __init__(self):
        self.memo = {}

    def fibonacci_dp(self, n):
        """æ–æ³¢é‚£å¥‘æ•°åˆ— - åŠ¨æ€è§„åˆ’"""
        if n <= 1:
            return n

        if n in self.memo:
            return self.memo[n]

        self.memo[n] = self.fibonacci_dp(n - 1) + self.fibonacci_dp(n - 2)
        return self.memo[n]

    def fibonacci_iterative(self, n):
        """æ–æ³¢é‚£å¥‘æ•°åˆ— - è¿­ä»£ä¼˜åŒ–"""
        if n <= 1:
            return n

        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b

        return b

    def longest_common_subsequence(self, text1, text2):
        """æœ€é•¿å…¬å…±å­åºåˆ—"""
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

        return dp[m][n]

    def coin_change(self, coins, amount):
        """é›¶é’±å…‘æ¢"""
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0

        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] = min(dp[i], dp[i - coin] + 1)

        return dp[amount] if dp[amount] != float('inf') else -1

    def knapsack_01(self, weights, values, capacity):
        """0-1èƒŒåŒ…é—®é¢˜"""
        n = len(weights)
        dp = [[0] * (capacity + 1) for _ in range(n + 1)]

        for i in range(1, n + 1):
            for w in range(capacity + 1):
                if weights[i - 1] <= w:
                    dp[i][w] = max(dp[i - 1][w],
                                  dp[i - 1][w - weights[i - 1]] + values[i - 1])
                else:
                    dp[i][w] = dp[i - 1][w]

        return dp[n][capacity]

# åŠ¨æ€è§„åˆ’åº”ç”¨ç¤ºä¾‹
def demonstrate_dynamic_programming():
    """æ¼”ç¤ºåŠ¨æ€è§„åˆ’åº”ç”¨"""
    dp = DynamicProgramming()

    # æ–æ³¢é‚£å¥‘æ•°åˆ—
    print("=== æ–æ³¢é‚£å¥‘æ•°åˆ— ===")
    n = 10
    fib_dp = dp.fibonacci_dp(n)
    fib_iter = dp.fibonacci_iterative(n)
    print(f"F({n}) = {fib_dp} (DP), {fib_iter} (è¿­ä»£)")

    # æœ€é•¿å…¬å…±å­åºåˆ—
    print("\n=== æœ€é•¿å…¬å…±å­åºåˆ— ===")
    text1 = "abcde"
    text2 = "ace"
    lcs = dp.longest_common_subsequence(text1, text2)
    print(f"æ–‡æœ¬1: {text1}")
    print(f"æ–‡æœ¬2: {text2}")
    print(f"æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦: {lcs}")

    # é›¶é’±å…‘æ¢
    print("\n=== é›¶é’±å…‘æ¢ ===")
    coins = [1, 2, 5]
    amount = 11
    min_coins = dp.coin_change(coins, amount)
    print(f"ç¡¬å¸: {coins}")
    print(f"ç›®æ ‡é‡‘é¢: {amount}")
    print(f"æœ€å°‘ç¡¬å¸æ•°: {min_coins}")

    # 0-1èƒŒåŒ…é—®é¢˜
    print("\n=== 0-1èƒŒåŒ…é—®é¢˜ ===")
    weights = [2, 1, 3, 2]
    values = [12, 10, 20, 15]
    capacity = 5
    max_value = dp.knapsack_01(weights, values, capacity)
    print(f"é‡é‡: {weights}")
    print(f"ä»·å€¼: {values}")
    print(f"èƒŒåŒ…å®¹é‡: {capacity}")
    print(f"æœ€å¤§ä»·å€¼: {max_value}")

demonstrate_dynamic_programming()
```

#### è´ªå¿ƒç®—æ³•ï¼šå±€éƒ¨æœ€ä¼˜çš„é€‰æ‹©

**è´ªå¿ƒç®—æ³•æ€ç»´ï¼š**
```python
# è´ªå¿ƒç®—æ³•æ¨¡æ¿
class GreedyAlgorithms:
    def __init__(self):
        self.greedy_strategies = {
            'activity_selection': 'æ´»åŠ¨é€‰æ‹©',
            'fractional_knapsack': 'åˆ†æ•°èƒŒåŒ…',
            'huffman_coding': 'å“ˆå¤«æ›¼ç¼–ç ',
            'dijkstra': 'æœ€çŸ­è·¯å¾„',
            'kruskal': 'æœ€å°ç”Ÿæˆæ ‘'
        }

    def activity_selection(self, activities):
        """æ´»åŠ¨é€‰æ‹©é—®é¢˜"""
        if not activities:
            return []

        # æŒ‰ç»“æŸæ—¶é—´æ’åº
        activities.sort(key=lambda x: x[1])

        selected = [activities[0]]
        last_end = activities[0][1]

        for start, end in activities[1:]:
            if start >= last_end:
                selected.append((start, end))
                last_end = end

        return selected

    def fractional_knapsack(self, weights, values, capacity):
        """åˆ†æ•°èƒŒåŒ…é—®é¢˜"""
        items = list(zip(weights, values))
        # æŒ‰å•ä½ä»·å€¼æ’åº
        items.sort(key=lambda x: x[1] / x[0], reverse=True)

        total_value = 0
        remaining_capacity = capacity

        for weight, value in items:
            if remaining_capacity >= weight:
                total_value += value
                remaining_capacity -= weight
            else:
                fraction = remaining_capacity / weight
                total_value += value * fraction
                break

        return total_value

    def minimum_platforms(self, arrivals, departures):
        """æœ€å°‘ç«™å°æ•°é—®é¢˜"""
        arrivals.sort()
        departures.sort()

        platforms_needed = 1
        max_platforms = 1
        i = 1
        j = 0

        while i < len(arrivals) and j < len(departures):
            if arrivals[i] <= departures[j]:
                platforms_needed += 1
                i += 1
            else:
                platforms_needed -= 1
                j += 1

            max_platforms = max(max_platforms, platforms_needed)

        return max_platforms

    def job_scheduling(self, jobs):
        """ä½œä¸šè°ƒåº¦é—®é¢˜"""
        # æŒ‰æˆªæ­¢æ—¶é—´æ’åº
        jobs.sort(key=lambda x: x[1])

        scheduled = []
        current_time = 0

        for job_id, deadline, profit in jobs:
            if current_time < deadline:
                scheduled.append(job_id)
                current_time += 1

        return scheduled

# è´ªå¿ƒç®—æ³•åº”ç”¨ç¤ºä¾‹
def demonstrate_greedy_algorithms():
    """æ¼”ç¤ºè´ªå¿ƒç®—æ³•åº”ç”¨"""
    greedy = GreedyAlgorithms()

    # æ´»åŠ¨é€‰æ‹©
    print("=== æ´»åŠ¨é€‰æ‹©é—®é¢˜ ===")
    activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11)]
    selected_activities = greedy.activity_selection(activities)
    print(f"æ‰€æœ‰æ´»åŠ¨: {activities}")
    print(f"é€‰æ‹©çš„æ´»åŠ¨: {selected_activities}")
    print(f"æœ€å¤§æ´»åŠ¨æ•°: {len(selected_activities)}")

    # åˆ†æ•°èƒŒåŒ…
    print("\n=== åˆ†æ•°èƒŒåŒ…é—®é¢˜ ===")
    weights = [10, 20, 30]
    values = [60, 100, 120]
    capacity = 50
    max_value = greedy.fractional_knapsack(weights, values, capacity)
    print(f"é‡é‡: {weights}")
    print(f"ä»·å€¼: {values}")
    print(f"èƒŒåŒ…å®¹é‡: {capacity}")
    print(f"æœ€å¤§ä»·å€¼: {max_value}")

    # æœ€å°‘ç«™å°æ•°
    print("\n=== æœ€å°‘ç«™å°æ•°é—®é¢˜ ===")
    arrivals = [900, 940, 950, 1100, 1500, 1800]
    departures = [910, 1200, 1120, 1130, 1900, 2000]
    platforms = greedy.minimum_platforms(arrivals, departures)
    print(f"åˆ°è¾¾æ—¶é—´: {arrivals}")
    print(f"ç¦»å¼€æ—¶é—´: {departures}")
    print(f"æœ€å°‘ç«™å°æ•°: {platforms}")

demonstrate_greedy_algorithms()
```

## ç®—æ³•å­¦ä¹ ç­–ç•¥ï¼šä»å…¥é—¨åˆ°ç²¾é€š

### 1. å­¦ä¹ è·¯å¾„è§„åˆ’

**é˜¶æ®µæ€§å­¦ä¹ è®¡åˆ’ï¼š**
```python
# å­¦ä¹ è·¯å¾„è§„åˆ’å™¨
class LearningPathPlanner:
    def __init__(self):
        self.learning_stages = {
            'beginner': {
                'duration': '1-2ä¸ªæœˆ',
                'topics': ['åŸºç¡€æ•°æ®ç»“æ„', 'ç®€å•æ’åº', 'åŸºæœ¬æŸ¥æ‰¾'],
                'target': 'ç†è§£åŸºæœ¬æ¦‚å¿µï¼Œèƒ½å†™ç®€å•ç®—æ³•'
            },
            'intermediate': {
                'duration': '2-3ä¸ªæœˆ',
                'topics': ['åŠ¨æ€è§„åˆ’', 'è´ªå¿ƒç®—æ³•', 'å›¾è®ºåŸºç¡€'],
                'target': 'æŒæ¡å¸¸è§ç®—æ³•æ€æƒ³ï¼Œèƒ½è§£å†³ä¸­ç­‰éš¾åº¦é—®é¢˜'
            },
            'advanced': {
                'duration': '3-6ä¸ªæœˆ',
                'topics': ['é«˜çº§æ•°æ®ç»“æ„', 'å¤æ‚ç®—æ³•', 'ç®—æ³•ä¼˜åŒ–'],
                'target': 'èƒ½è§£å†³å›°éš¾é—®é¢˜ï¼Œç†è§£ç®—æ³•æœ¬è´¨'
            }
        }

    def create_learning_plan(self, current_level, target_level):
        """åˆ›å»ºå­¦ä¹ è®¡åˆ’"""
        plan = {
            'current_level': current_level,
            'target_level': target_level,
            'timeline': [],
            'resources': [],
            'practice_problems': []
        }

        # æ ¹æ®ç›®æ ‡çº§åˆ«åˆ¶å®šè®¡åˆ’
        if target_level == 'beginner':
            plan['timeline'] = [
                {'week': 1, 'focus': 'æ•°ç»„å’Œå­—ç¬¦ä¸²åŸºç¡€'},
                {'week': 2, 'focus': 'é“¾è¡¨å’Œæ ˆé˜Ÿåˆ—'},
                {'week': 3, 'focus': 'ç®€å•æ’åºç®—æ³•'},
                {'week': 4, 'focus': 'åŸºç¡€æŸ¥æ‰¾ç®—æ³•'}
            ]
        elif target_level == 'intermediate':
            plan['timeline'] = [
                {'week': 1-2, 'focus': 'åŠ¨æ€è§„åˆ’åŸºç¡€'},
                {'week': 3-4, 'focus': 'è´ªå¿ƒç®—æ³•'},
                {'week': 5-6, 'focus': 'å›¾è®ºåŸºç¡€'},
                {'week': 7-8, 'focus': 'æ ‘å’ŒäºŒå‰æ ‘'}
            ]

        return plan

    def recommend_problems(self, level, topic):
        """æ¨èç»ƒä¹ é¢˜"""
        problem_sets = {
            'beginner': {
                'array': ['ä¸¤æ•°ä¹‹å’Œ', 'æœ€å¤§å­æ•°ç»„å’Œ', 'ç§»åŠ¨é›¶'],
                'string': ['åè½¬å­—ç¬¦ä¸²', 'æœ‰æ•ˆæ‹¬å·', 'æœ€é•¿å…¬å…±å‰ç¼€'],
                'linked_list': ['åè½¬é“¾è¡¨', 'æ£€æµ‹ç¯', 'åˆå¹¶æœ‰åºé“¾è¡¨']
            },
            'intermediate': {
                'dp': ['çˆ¬æ¥¼æ¢¯', 'é›¶é’±å…‘æ¢', 'æœ€é•¿é€’å¢å­åºåˆ—'],
                'greedy': ['æ´»åŠ¨é€‰æ‹©', 'åˆ†æ•°èƒŒåŒ…', 'æœ€å°‘ç«™å°æ•°'],
                'tree': ['äºŒå‰æ ‘éå†', 'æœ€å¤§æ·±åº¦', 'è·¯å¾„å’Œ']
            }
        }

        return problem_sets.get(level, {}).get(topic, [])

# å­¦ä¹ è®¡åˆ’ç¤ºä¾‹
def create_personal_learning_plan():
    """åˆ›å»ºä¸ªäººå­¦ä¹ è®¡åˆ’"""
    planner = LearningPathPlanner()

    # åˆå­¦è€…è®¡åˆ’
    beginner_plan = planner.create_learning_plan('none', 'beginner')
    print("=== åˆå­¦è€…å­¦ä¹ è®¡åˆ’ ===")
    print(f"ç›®æ ‡: {beginner_plan['target_level']}")
    for milestone in beginner_plan['timeline']:
        print(f"ç¬¬{milestone['week']}å‘¨: {milestone['focus']}")

    # æ¨èç»ƒä¹ é¢˜
    print("\n=== æ¨èç»ƒä¹ é¢˜ ===")
    array_problems = planner.recommend_problems('beginner', 'array')
    print(f"æ•°ç»„åŸºç¡€é¢˜: {array_problems}")

create_personal_learning_plan()
```

### 2. å®è·µæŠ€å·§ï¼šä»ç†è®ºåˆ°åº”ç”¨

**åˆ·é¢˜ç­–ç•¥ï¼š**
```python
# åˆ·é¢˜ç­–ç•¥ç®¡ç†å™¨
class ProblemSolvingStrategy:
    def __init__(self):
        self.strategies = {
            'understanding': 'ç†è§£é—®é¢˜',
            'planning': 'åˆ¶å®šè®¡åˆ’',
            'coding': 'ç¼–å†™ä»£ç ',
            'testing': 'æµ‹è¯•éªŒè¯',
            'optimizing': 'ä¼˜åŒ–æ”¹è¿›'
        }

    def solve_problem_step_by_step(self, problem_description):
        """åˆ†æ­¥éª¤è§£å†³é—®é¢˜"""
        steps = []

        # æ­¥éª¤1ï¼šç†è§£é—®é¢˜
        steps.append({
            'step': 1,
            'action': 'ç†è§£é—®é¢˜',
            'questions': [
                'è¾“å…¥æ˜¯ä»€ä¹ˆï¼Ÿ',
                'è¾“å‡ºæ˜¯ä»€ä¹ˆï¼Ÿ',
                'æœ‰ä»€ä¹ˆçº¦æŸæ¡ä»¶ï¼Ÿ',
                'è¾¹ç•Œæƒ…å†µæ˜¯ä»€ä¹ˆï¼Ÿ'
            ]
        })

        # æ­¥éª¤2ï¼šåˆ¶å®šè®¡åˆ’
        steps.append({
            'step': 2,
            'action': 'åˆ¶å®šè®¡åˆ’',
            'questions': [
                'å¯ä»¥ç”¨ä»€ä¹ˆç®—æ³•ï¼Ÿ',
                'æ—¶é—´å¤æ‚åº¦è¦æ±‚ï¼Ÿ',
                'ç©ºé—´å¤æ‚åº¦è¦æ±‚ï¼Ÿ',
                'å¦‚ä½•åˆ†è§£é—®é¢˜ï¼Ÿ'
            ]
        })

        # æ­¥éª¤3ï¼šç¼–å†™ä»£ç 
        steps.append({
            'step': 3,
            'action': 'ç¼–å†™ä»£ç ',
            'tips': [
                'å…ˆå†™ä¼ªä»£ç ',
                'è€ƒè™‘è¾¹ç•Œæƒ…å†µ',
                'æ³¨æ„ä»£ç è§„èŒƒ',
                'æ·»åŠ å¿…è¦æ³¨é‡Š'
            ]
        })

        # æ­¥éª¤4ï¼šæµ‹è¯•éªŒè¯
        steps.append({
            'step': 4,
            'action': 'æµ‹è¯•éªŒè¯',
            'test_cases': [
                'æ­£å¸¸æƒ…å†µ',
                'è¾¹ç•Œæƒ…å†µ',
                'å¼‚å¸¸æƒ…å†µ',
                'æ€§èƒ½æµ‹è¯•'
            ]
        })

        # æ­¥éª¤5ï¼šä¼˜åŒ–æ”¹è¿›
        steps.append({
            'step': 5,
            'action': 'ä¼˜åŒ–æ”¹è¿›',
            'optimizations': [
                'æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–',
                'ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–',
                'ä»£ç å¯è¯»æ€§ä¼˜åŒ–',
                'ç®—æ³•é€‰æ‹©ä¼˜åŒ–'
            ]
        })

        return steps

    def analyze_problem_pattern(self, problem_description):
        """åˆ†æé—®é¢˜æ¨¡å¼"""
        patterns = {
            'array_manipulation': ['æ•°ç»„', 'å­æ•°ç»„', 'æ’åº', 'æŸ¥æ‰¾'],
            'string_processing': ['å­—ç¬¦ä¸²', 'åŒ¹é…', 'ç¼–è¾‘', 'å›æ–‡'],
            'tree_traversal': ['æ ‘', 'éå†', 'è·¯å¾„', 'æ·±åº¦'],
            'graph_search': ['å›¾', 'æœç´¢', 'è·¯å¾„', 'è¿é€š'],
            'dynamic_programming': ['æœ€å¤§', 'æœ€å°', 'æ•°é‡', 'æ–¹æ¡ˆ'],
            'greedy_choice': ['é€‰æ‹©', 'å®‰æ’', 'è°ƒåº¦', 'åˆ†é…']
        }

        matched_patterns = []
        for pattern, keywords in patterns.items():
            if any(keyword in problem_description for keyword in keywords):
                matched_patterns.append(pattern)

        return matched_patterns

# è§£é¢˜ç­–ç•¥ç¤ºä¾‹
def demonstrate_problem_solving():
    """æ¼”ç¤ºè§£é¢˜ç­–ç•¥"""
    strategy = ProblemSolvingStrategy()

    # åˆ†æ­¥éª¤è§£é¢˜
    problem = "ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°å’Œæœ€å¤§çš„è¿ç»­å­æ•°ç»„"
    steps = strategy.solve_problem_step_by_step(problem)

    print("=== è§£é¢˜æ­¥éª¤ ===")
    for step in steps:
        print(f"\næ­¥éª¤{step['step']}: {step['action']}")
        if 'questions' in step:
            for question in step['questions']:
                print(f"  - {question}")
        elif 'tips' in step:
            for tip in step['tips']:
                print(f"  - {tip}")
        elif 'test_cases' in step:
            for test_case in step['test_cases']:
                print(f"  - {test_case}")
        elif 'optimizations' in step:
            for optimization in step['optimizations']:
                print(f"  - {optimization}")

    # é—®é¢˜æ¨¡å¼åˆ†æ
    patterns = strategy.analyze_problem_pattern(problem)
    print(f"\né—®é¢˜æ¨¡å¼: {patterns}")

demonstrate_problem_solving()
```

## æ€»ç»“ä¸åæ€

### ç®—æ³•å­¦ä¹ çš„ä»·å€¼

1. **æ€ç»´è®­ç»ƒ**ï¼šåŸ¹å…»é€»è¾‘æ€ç»´å’Œé—®é¢˜è§£å†³èƒ½åŠ›
2. **ç¼–ç¨‹åŸºç¡€**ï¼šæŒæ¡é«˜æ•ˆçš„ç¼–ç¨‹æŠ€å·§å’Œæ–¹æ³•
3. **é¢è¯•å‡†å¤‡**ï¼šä¸ºæŠ€æœ¯é¢è¯•æ‰“ä¸‹åšå®åŸºç¡€
4. **èŒä¸šå‘å±•**ï¼šæå‡æŠ€æœ¯æ°´å¹³å’Œç«äº‰åŠ›

### æˆ‘çš„å­¦ä¹ å¿ƒå¾—

1. **ä»åŸºç¡€å¼€å§‹**ï¼šå…ˆæŒæ¡åŸºæœ¬æ¦‚å¿µï¼Œå†å­¦ä¹ é«˜çº§ç®—æ³•
2. **å®è·µä¸ºä¸»**ï¼šç†è®ºç»“åˆå®è·µï¼Œå¤šåšé¢˜å¤šæ€è€ƒ
3. **æŒç»­å­¦ä¹ **ï¼šç®—æ³•å­¦ä¹ æ˜¯ä¸€ä¸ªé•¿æœŸè¿‡ç¨‹
4. **æ€»ç»“åæ€**ï¼šåŠæ—¶æ€»ç»“ç»éªŒå’Œæ•™è®­

### ç»™å…¶ä»–"åºŸæŸ´"çš„å»ºè®®

1. **ä¸è¦å®³æ€•å›°éš¾**ï¼šç®—æ³•å­¦ä¹ éœ€è¦æ—¶é—´å’Œè€å¿ƒ
2. **ä¿æŒç»ƒä¹ **ï¼šæ¯å¤©åˆ·é¢˜ï¼Œä¿æŒæ‰‹æ„Ÿ
3. **å­¦ä¹ ä»–äºº**ï¼šå‚è€ƒä¼˜ç§€çš„è§£é¢˜æ€è·¯å’Œä»£ç 
4. **å»ºç«‹ä½“ç³»**ï¼šå½¢æˆè‡ªå·±çš„ç®—æ³•çŸ¥è¯†ä½“ç³»

## å‚è€ƒèµ„æ–™

- [ç®—æ³•å¯¼è®º](https://book.douban.com/subject/20432061/)
- [ç¼–ç¨‹ç ç‘](https://book.douban.com/subject/3227098/)
- [LeetCode](https://leetcode.com/)
- [ç®—æ³•å¯è§†åŒ–](https://visualgo.net/)

## ç»“è¯­

ç®—æ³•å­¦ä¹ æ˜¯ä¸€ä¸ªå……æ»¡æŒ‘æˆ˜å’Œä¹è¶£çš„è¿‡ç¨‹ã€‚ä»æœ€åˆçš„"æš´åŠ›è§£æ³•"åˆ°åæ¥çš„"ä¼˜é›…ç®—æ³•"ï¼Œæ¯ä¸€æ­¥éƒ½æ˜¯æ€ç»´çš„æå‡ã€‚

è®°ä½ï¼Œå¥½çš„ç®—æ³•ä¸æ˜¯ä¸€è¹´è€Œå°±çš„ï¼Œè€Œæ˜¯é€šè¿‡ä¸æ–­ç»ƒä¹ å’Œæ€è€ƒå¾—æ¥çš„ã€‚ä¸è¦å®³æ€•çŠ¯é”™ï¼Œä¸è¦å®³æ€•å›°éš¾ï¼Œæ¯ä¸€æ¬¡å°è¯•éƒ½æ˜¯å­¦ä¹ çš„æœºä¼šã€‚

## å®ç”¨å°è´´å£«

### ğŸ¯ ç®—æ³•å­¦ä¹ è·¯å¾„
- [ ] æŒæ¡åŸºç¡€æ•°æ®ç»“æ„ï¼ˆæ•°ç»„ã€é“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ï¼‰
- [ ] å­¦ä¹ åŸºæœ¬ç®—æ³•ï¼ˆæ’åºã€æŸ¥æ‰¾ã€é€’å½’ï¼‰
- [ ] ç†è§£é«˜çº§ç®—æ³•ï¼ˆåŠ¨æ€è§„åˆ’ã€è´ªå¿ƒã€åˆ†æ²»ï¼‰
- [ ] å®è·µå¤æ‚é—®é¢˜ï¼ˆå›¾è®ºã€å­—ç¬¦ä¸²ã€æ•°å­¦ï¼‰
- [ ] ä¼˜åŒ–ç®—æ³•æ€§èƒ½ï¼ˆæ—¶é—´å¤æ‚åº¦ã€ç©ºé—´å¤æ‚åº¦ï¼‰

### ğŸš€ å¿«é€Ÿå¼€å§‹
```python
# 1. ç†è§£é—®é¢˜
# 2. åˆ†æå¤æ‚åº¦
# 3. é€‰æ‹©ç®—æ³•
# 4. ç¼–å†™ä»£ç 
# 5. æµ‹è¯•ä¼˜åŒ–

# ç¤ºä¾‹ï¼šä¸¤æ•°ä¹‹å’Œ
def two_sum(nums, target):
    num_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_map:
            return [num_map[complement], i]
        num_map[num] = i
    return []
```

### ğŸ’¡ è¿›é˜¶æŠ€å·§
- æŒæ¡å¸¸è§ç®—æ³•æ¨¡æ¿
- ç†è§£ç®—æ³•æ€æƒ³æœ¬è´¨
- å­¦ä¼šå¤æ‚åº¦åˆ†æ
- åŸ¹å…»è§£é¢˜ç›´è§‰
- å»ºç«‹çŸ¥è¯†ä½“ç³»
8:{"id":"algorithm-learning-notes","title":"ğŸ“š ç®—æ³•å­¦ä¹ ç¬”è®°ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•æ€ç»´è¿›åŒ–å²","description":"ä»\"æš´åŠ›è§£æ³•\"åˆ°\"ä¼˜é›…ç®—æ³•\"ï¼Œåˆ†äº«æˆ‘åœ¨ç®—æ³•å­¦ä¹ è¿‡ç¨‹ä¸­çš„æ€ç»´è½¬å˜å’Œå®ç”¨æŠ€å·§ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨ç®—æ³•é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚","date":"2023-12-25","readTime":"25åˆ†é’Ÿ","tags":"$9","category":"ç®—æ³•å­¦ä¹ ","slug":"algorithm-learning-notes","featured":true,"author":"LJoson","status":"published","content":"$a","excerpt":"\r\n ç®—æ³•å­¦ä¹ ç¬”è®°ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•æ€ç»´è¿›åŒ–å²\r\n\r\n> ä»\"æš´åŠ›è§£æ³•\"åˆ°\"ä¼˜é›…ç®—æ³•\"ï¼Œæˆ‘çš„ç®—æ³•æ€ç»´è¿›åŒ–ä¹‹è·¯\r\n\r\n æˆ‘ä¸ç®—æ³•çš„\"ç›¸çˆ±ç›¸æ€\"\r\n\r\n ç¬¬ä¸€æ¬¡\"ç¿»è½¦\"ï¼šæš´åŠ›è§£æ³•çš„ç¾éš¾\r\n\r\nè¿˜è®°å¾—ç¬¬ä¸€æ¬¡é‡åˆ°ç®—æ³•é¢˜æ—¶ï¼Œæˆ‘ä¿¡å¿ƒæ»¡æ»¡åœ°å¼€å§‹ç¼–ç ï¼š\r\n\r\npython\r\n æˆ‘çš„ç¬¬ä¸€ä¸ª\"æ°ä½œ\" - æš´åŠ›è§£æ³•\r\ndef find_max_subarray(arr):\r\n    max_sum = float('-i..."}
c:["slug","algorithm-learning-notes","d"]
0:["build-1756572638459",[[["",{"children":["blog",{"children":[["slug","algorithm-learning-notes","d"],{"children":["__PAGE__?{\"slug\":\"algorithm-learning-notes\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["blog",{"children":[["slug","algorithm-learning-notes","d"],{"children":["__PAGE__",{},[["$L1",["$","div",null,{"className":"min-h-screen bg-cyber-bg-900","children":["$","div",null,{"className":"relative overflow-hidden","children":[["$","div",null,{"className":"absolute inset-0 bg-gradient-to-br from-fail-red/5 via-fail-orange/3 to-fail-purple/5"}],["$","div",null,{"className":"relative z-10","children":[["$","div",null,{"className":"max-w-7xl mx-auto px-4 py-8","children":["$","div",null,{"className":"grid grid-cols-1 lg:grid-cols-4 gap-8","children":[["$","div",null,{"className":"lg:col-span-3 w-full","children":["$","$L2",null,{"post":{"id":"algorithm-learning-notes","title":"ğŸ“š ç®—æ³•å­¦ä¹ ç¬”è®°ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•æ€ç»´è¿›åŒ–å²","description":"ä»\"æš´åŠ›è§£æ³•\"åˆ°\"ä¼˜é›…ç®—æ³•\"ï¼Œåˆ†äº«æˆ‘åœ¨ç®—æ³•å­¦ä¹ è¿‡ç¨‹ä¸­çš„æ€ç»´è½¬å˜å’Œå®ç”¨æŠ€å·§ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨ç®—æ³•é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚","date":"2023-12-25","readTime":"25åˆ†é’Ÿ","tags":["ç®—æ³•","æ•°æ®ç»“æ„","ç¼–ç¨‹æŠ€å·§","å­¦ä¹ ç¬”è®°","åŠ¨æ€è§„åˆ’","æ’åºç®—æ³•","è·¨ç•Œæ¢ç´¢"],"category":"ç®—æ³•å­¦ä¹ ","slug":"algorithm-learning-notes","featured":true,"author":"LJoson","status":"published","content":"$3","excerpt":"\r\n ç®—æ³•å­¦ä¹ ç¬”è®°ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•æ€ç»´è¿›åŒ–å²\r\n\r\n> ä»\"æš´åŠ›è§£æ³•\"åˆ°\"ä¼˜é›…ç®—æ³•\"ï¼Œæˆ‘çš„ç®—æ³•æ€ç»´è¿›åŒ–ä¹‹è·¯\r\n\r\n æˆ‘ä¸ç®—æ³•çš„\"ç›¸çˆ±ç›¸æ€\"\r\n\r\n ç¬¬ä¸€æ¬¡\"ç¿»è½¦\"ï¼šæš´åŠ›è§£æ³•çš„ç¾éš¾\r\n\r\nè¿˜è®°å¾—ç¬¬ä¸€æ¬¡é‡åˆ°ç®—æ³•é¢˜æ—¶ï¼Œæˆ‘ä¿¡å¿ƒæ»¡æ»¡åœ°å¼€å§‹ç¼–ç ï¼š\r\n\r\npython\r\n æˆ‘çš„ç¬¬ä¸€ä¸ª\"æ°ä½œ\" - æš´åŠ›è§£æ³•\r\ndef find_max_subarray(arr):\r\n    max_sum = float('-i..."}}]}],["$","div",null,{"className":"lg:col-span-1","children":["$","div",null,{"className":"sticky top-24","children":["$","$L4",null,{}]}]}]]}]}],["$","div",null,{"className":"max-w-7xl mx-auto px-4 pb-16","children":["$","$L5",null,{"posts":[{"id":"leetcode-brushing-guide","title":"ğŸ’» LeetCodeåˆ·é¢˜æŒ‡å—ï¼šä¸€ä¸ªæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•å­¦ä¹ ä¹‹è·¯","description":"ä»æš´åŠ›è§£æ³•åˆ°æœ€ä¼˜è§£ï¼Œåˆ†äº«æˆ‘åœ¨ç®—æ³•å­¦ä¹ è¿‡ç¨‹ä¸­çš„æ·±åº¦æ€è€ƒå’Œå®ç”¨æŠ€å·§ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨ç®—æ³•é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚","date":"2020-06-21","readTime":"20åˆ†é’Ÿ","tags":["ç®—æ³•","LeetCode","æ•°æ®ç»“æ„","æ’åºç®—æ³•","ä½è¿ç®—","å“ˆå¸Œè¡¨","åŠ¨æ€è§„åˆ’","æŠ€æœ¯åºŸæŸ´","åˆ·é¢˜æŒ‡å—","è·¨ç•Œæ¢ç´¢"],"category":"ç®—æ³•å­¦ä¹ ","slug":"leetcode-brushing-guide","featured":false,"author":"LJoson","status":"published","content":"$6","excerpt":"\r\n ğŸ’» LeetCodeåˆ·é¢˜æŒ‡å—ï¼šä¸€ä¸ªæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•å­¦ä¹ ä¹‹è·¯\r\n\r\n ç®—æ³•å­¦ä¹ çš„æœ¬è´¨æ€è€ƒ\r\n\r\nç®—æ³•å­¦ä¹ ï¼Œæœ¬è´¨ä¸Šæ˜¯å¯¹é—®é¢˜è§£å†³æ€ç»´çš„è®­ç»ƒã€‚\r\n\r\nå½“æˆ‘ç¬¬ä¸€æ¬¡æ¥è§¦LeetCodeæ—¶ï¼Œæˆ‘ä»¥ä¸ºè¿™åªæ˜¯ä¸€ä¸ª\"åˆ·é¢˜\"çš„å¹³å°ã€‚ä½†éšç€æ·±å…¥ï¼Œæˆ‘å‘ç°å®ƒæ›´åƒæ˜¯ä¸€é¢é•œå­ï¼Œç…§å‡ºäº†æˆ‘åœ¨é—®é¢˜è§£å†³èƒ½åŠ›ä¸Šçš„ä¸è¶³ã€‚\r\n\r\nä»æš´åŠ›è§£æ³•åˆ°æœ€ä¼˜è§£ï¼Œä»O(nÂ²)åˆ°O(n log n)ï¼Œæ¯ä¸€æ¬¡ä¼˜åŒ–éƒ½è®©æˆ‘å¯¹ç®—æ³•æœ‰äº†æ›´æ·±çš„ç†è§£ã€‚\r\n\r\n ç®—æ³•æ€..."},{"id":"leetcode-series-part1","title":"ğŸ“š LeetCodeåˆ·é¢˜å®æˆ˜ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•è¿›é˜¶ä¹‹è·¯","description":"ä»\"æš´åŠ›è§£æ³•\"åˆ°\"ä¼˜é›…ç®—æ³•\"ï¼Œåˆ†äº«æˆ‘åœ¨LeetCodeåˆ·é¢˜è¿‡ç¨‹ä¸­çš„å®ç”¨æŠ€å·§å’Œè§£é¢˜æ€è·¯ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨ç®—æ³•é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚","date":"2020-06-21","readTime":"15åˆ†é’Ÿ","tags":["LeetCode","ç®—æ³•","æ•°æ®ç»“æ„","C++","æ’åº","ä½è¿ç®—","å“ˆå¸Œè¡¨","æŠ€æœ¯åºŸæŸ´","åˆ·é¢˜æŠ€å·§","è·¨ç•Œæ¢ç´¢"],"category":"ç®—æ³•å­¦ä¹ ","slug":"leetcode-series-part1","featured":false,"author":"LJoson","status":"published","content":"$7","excerpt":"\r\n LeetCodeåˆ·é¢˜å®æˆ˜ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•è¿›é˜¶ä¹‹è·¯\r\n\r\n> ä»\"æš´åŠ›è§£æ³•\"åˆ°\"ä¼˜é›…ç®—æ³•\"ï¼Œæˆ‘çš„LeetCodeåˆ·é¢˜è¿›åŒ–å²\r\n\r\n æˆ‘ä¸LeetCodeçš„\"ç›¸çˆ±ç›¸æ€\"\r\n\r\n ç¬¬ä¸€æ¬¡\"ç¿»è½¦\"ï¼šæš´åŠ›è§£æ³•çš„ç¾éš¾\r\n\r\nè¿˜è®°å¾—ç¬¬ä¸€æ¬¡é‡åˆ°LeetCodeé¢˜ç›®æ—¶ï¼Œæˆ‘ä¿¡å¿ƒæ»¡æ»¡åœ°å¼€å§‹ç¼–ç ï¼š\r\n\r\ncpp\r\n// æˆ‘çš„ç¬¬ä¸€ä¸ª\"æ°ä½œ\" - æš´åŠ›è§£æ³•\r\nclass Solution {\r\npublic:\r\n   ..."}],"currentPost":"$8"}]}]]}]]}]}],null],null],null]},[null,["$","$Lb",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","$c","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Ld",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$Lb",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Ld",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/3689037f0d92e8a5.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"zh-CN","className":"scroll-smooth","children":[["$","head",null,{"children":[["$","link",null,{"rel":"icon","href":"/favicon.svg"}],["$","link",null,{"rel":"apple-touch-icon","href":"/apple-touch-icon.svg"}],["$","link",null,{"rel":"manifest","href":"/manifest.json"}],["$","meta",null,{"name":"theme-color","content":"#ff6b6b"}],["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"WebSite\",\"name\":\"LJoson çš„åºŸæŸ´å°çª\",\"description\":\"ä»æŠ€æœ¯åºŸæŸ´åˆ°è·¨ç•Œæ¢ç´¢è€…çš„è¿›åŒ–ä¹‹è·¯\",\"url\":\"https://ljoson.com\",\"author\":{\"@type\":\"Person\",\"name\":\"LJoson\",\"url\":\"https://ljoson.com\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"GlimmerLab\",\"url\":\"https://glimmerlab.com\"}}"}}]]}],["$","body",null,{"className":"bg-cyber-bg-900 text-white antialiased font-sans selection:bg-fail-red/20 selection:text-white","children":[["$","$Le",null,{"children":["$","$Lf",null,{"children":["$","$L10",null,{"children":["$","div",null,{"className":"min-h-screen flex flex-col relative","children":[["$","div",null,{"className":"fixed inset-0 pointer-events-none","children":[["$","div",null,{"className":"absolute inset-0 bg-gradient-to-br from-fail-red/5 via-transparent to-fail-purple/5"}],["$","div",null,{"className":"absolute top-0 left-0 w-full h-full bg-[radial-gradient(circle_at_50%_50%,rgba(255,107,107,0.1),transparent_50%)]"}]]}],["$","div",null,{"className":"relative z-10 flex flex-col min-h-screen","children":[["$","$L11",null,{}],["$","main",null,{"className":"flex-1 relative","children":["$","$Lb",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$12","errorStyles":[],"errorScripts":[],"template":["$","$Ld",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","$L13",null,{}],"notFoundStyles":[]}]}],["$","$L14",null,{}]]}]]}]}]}]}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              // æ€§èƒ½ç›‘æ§\n              if (typeof window !== 'undefined') {\n                window.addEventListener('load', () => {\n                  if ('performance' in window) {\n                    const perfData = performance.getEntriesByType('navigation')[0];\n                    if (perfData) {\n                      console.log('é¡µé¢åŠ è½½æ€§èƒ½:', {\n                        'DOMå†…å®¹åŠ è½½': perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart + 'ms',\n                        'é¡µé¢å®Œå…¨åŠ è½½': perfData.loadEventEnd - perfData.loadEventStart + 'ms',\n                        'é¦–æ¬¡å†…å®¹ç»˜åˆ¶': performance.getEntriesByName('first-contentful-paint')[0]?.startTime + 'ms'\n                      });\n                    }\n                  }\n                });\n              }\n            "}}]]}]]}]],null],[["$","$L15",null,{}],[],[]]],["$L16",null]]]]
16:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"ğŸ“š ç®—æ³•å­¦ä¹ ç¬”è®°ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•æ€ç»´è¿›åŒ–å² - LJoson çš„\"åºŸæŸ´\"å°çª | LJoson çš„\"åºŸæŸ´\"å°çª"}],["$","meta","3",{"name":"description","content":"ä»\"æš´åŠ›è§£æ³•\"åˆ°\"ä¼˜é›…ç®—æ³•\"ï¼Œåˆ†äº«æˆ‘åœ¨ç®—æ³•å­¦ä¹ è¿‡ç¨‹ä¸­çš„æ€ç»´è½¬å˜å’Œå®ç”¨æŠ€å·§ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨ç®—æ³•é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚"}],["$","meta","4",{"name":"author","content":"LJoson"}],["$","meta","5",{"name":"keywords","content":"ç®—æ³•, æ•°æ®ç»“æ„, ç¼–ç¨‹æŠ€å·§, å­¦ä¹ ç¬”è®°, åŠ¨æ€è§„åˆ’, æ’åºç®—æ³•, è·¨ç•Œæ¢ç´¢"}],["$","meta","6",{"name":"creator","content":"LJoson"}],["$","meta","7",{"name":"publisher","content":"LJoson"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","meta","10",{"name":"theme-color","content":"#ff6b6b"}],["$","meta","11",{"name":"color-scheme","content":"dark"}],["$","meta","12",{"name":"viewport-fit","content":"cover"}],["$","link","13",{"rel":"canonical","href":"https://ljoson.com/"}],["$","meta","14",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","15",{"name":"google-site-verification","content":"your-google-verification-code"}],["$","meta","16",{"property":"og:title","content":"ğŸ“š ç®—æ³•å­¦ä¹ ç¬”è®°ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•æ€ç»´è¿›åŒ–å²"}],["$","meta","17",{"property":"og:description","content":"ä»\"æš´åŠ›è§£æ³•\"åˆ°\"ä¼˜é›…ç®—æ³•\"ï¼Œåˆ†äº«æˆ‘åœ¨ç®—æ³•å­¦ä¹ è¿‡ç¨‹ä¸­çš„æ€ç»´è½¬å˜å’Œå®ç”¨æŠ€å·§ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨ç®—æ³•é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚"}],["$","meta","18",{"property":"og:image","content":"https://ljoson.com/api/og?title=%F0%9F%93%9A%20%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8A%80%E6%9C%AF%E5%BA%9F%E6%9F%B4%E7%9A%84%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E8%BF%9B%E5%8C%96%E5%8F%B2&description=%E4%BB%8E%22%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95%22%E5%88%B0%22%E4%BC%98%E9%9B%85%E7%AE%97%E6%B3%95%22%EF%BC%8C%E5%88%86%E4%BA%AB%E6%88%91%E5%9C%A8%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%80%9D%E7%BB%B4%E8%BD%AC%E5%8F%98%E5%92%8C%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%AE%B0%E5%BD%95%E6%8A%80%E6%9C%AF%E5%BA%9F%E6%9F%B4%E5%9C%A8%E7%AE%97%E6%B3%95%E9%A2%86%E5%9F%9F%E7%9A%84%E6%88%90%E9%95%BF%E8%BD%A8%E8%BF%B9%E3%80%82"}],["$","meta","19",{"property":"og:image:width","content":"1200"}],["$","meta","20",{"property":"og:image:height","content":"630"}],["$","meta","21",{"property":"og:image:alt","content":"ğŸ“š ç®—æ³•å­¦ä¹ ç¬”è®°ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•æ€ç»´è¿›åŒ–å²"}],["$","meta","22",{"property":"og:type","content":"article"}],["$","meta","23",{"property":"article:published_time","content":"2023-12-25"}],["$","meta","24",{"property":"article:author","content":"LJoson"}],["$","meta","25",{"property":"article:tag","content":"ç®—æ³•"}],["$","meta","26",{"property":"article:tag","content":"æ•°æ®ç»“æ„"}],["$","meta","27",{"property":"article:tag","content":"ç¼–ç¨‹æŠ€å·§"}],["$","meta","28",{"property":"article:tag","content":"å­¦ä¹ ç¬”è®°"}],["$","meta","29",{"property":"article:tag","content":"åŠ¨æ€è§„åˆ’"}],["$","meta","30",{"property":"article:tag","content":"æ’åºç®—æ³•"}],["$","meta","31",{"property":"article:tag","content":"è·¨ç•Œæ¢ç´¢"}],["$","meta","32",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","33",{"name":"twitter:title","content":"ğŸ“š ç®—æ³•å­¦ä¹ ç¬”è®°ï¼šæŠ€æœ¯åºŸæŸ´çš„ç®—æ³•æ€ç»´è¿›åŒ–å²"}],["$","meta","34",{"name":"twitter:description","content":"ä»\"æš´åŠ›è§£æ³•\"åˆ°\"ä¼˜é›…ç®—æ³•\"ï¼Œåˆ†äº«æˆ‘åœ¨ç®—æ³•å­¦ä¹ è¿‡ç¨‹ä¸­çš„æ€ç»´è½¬å˜å’Œå®ç”¨æŠ€å·§ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨ç®—æ³•é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚"}],["$","meta","35",{"name":"twitter:image","content":"https://ljoson.com/api/og?title=%F0%9F%93%9A%20%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8A%80%E6%9C%AF%E5%BA%9F%E6%9F%B4%E7%9A%84%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E8%BF%9B%E5%8C%96%E5%8F%B2&description=%E4%BB%8E%22%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95%22%E5%88%B0%22%E4%BC%98%E9%9B%85%E7%AE%97%E6%B3%95%22%EF%BC%8C%E5%88%86%E4%BA%AB%E6%88%91%E5%9C%A8%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%80%9D%E7%BB%B4%E8%BD%AC%E5%8F%98%E5%92%8C%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%AE%B0%E5%BD%95%E6%8A%80%E6%9C%AF%E5%BA%9F%E6%9F%B4%E5%9C%A8%E7%AE%97%E6%B3%95%E9%A2%86%E5%9F%9F%E7%9A%84%E6%88%90%E9%95%BF%E8%BD%A8%E8%BF%B9%E3%80%82"}]]
1:null
