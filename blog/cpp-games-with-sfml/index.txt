2:I[313,["754","static/chunks/754-2d7956d0ca320083.js","308","static/chunks/app/blog/%5Bslug%5D/page-4898a743cdf7fc4a.js"],"BlogDetail"]
4:I[1270,["754","static/chunks/754-2d7956d0ca320083.js","308","static/chunks/app/blog/%5Bslug%5D/page-4898a743cdf7fc4a.js"],"BlogSidebar"]
5:I[4420,["754","static/chunks/754-2d7956d0ca320083.js","308","static/chunks/app/blog/%5Bslug%5D/page-4898a743cdf7fc4a.js"],"RelatedPosts"]
c:I[4707,[],""]
e:I[6423,[],""]
f:I[3529,["185","static/chunks/app/layout-f6c41656a6971b66.js"],"ThemeProvider"]
10:I[4326,["185","static/chunks/app/layout-f6c41656a6971b66.js"],"ClientLayout"]
11:I[3164,["185","static/chunks/app/layout-f6c41656a6971b66.js"],"PageTransition"]
12:I[3157,["185","static/chunks/app/layout-f6c41656a6971b66.js"],"Header"]
13:I[3490,["601","static/chunks/app/error-aca96ac5bb368170.js"],"default"]
14:I[5447,["160","static/chunks/app/not-found-b4a85d88d4259f8a.js"],"default"]
15:I[2063,["185","static/chunks/app/layout-f6c41656a6971b66.js"],"Footer"]
16:I[9615,["555","static/chunks/app/loading-14670c1b72ad4c70.js"],"default"]
3:T55c8,
# åå…­ä¸ªç»å…¸C++æ¸¸æˆé¡¹ç›®ï¼šæŠ€æœ¯åºŸæŸ´çš„æ¸¸æˆå¼€å‘å®æˆ˜

> ä»"Hello World"åˆ°å®Œæ•´æ¸¸æˆï¼Œæˆ‘çš„SFMLæ¸¸æˆå¼€å‘é¡¹ç›®é›†

## æˆ‘ä¸æ¸¸æˆå¼€å‘çš„"ç¬¬ä¸€æ¬¡äº²å¯†æ¥è§¦"

### ç¬¬ä¸€ä¸ªæ¸¸æˆï¼šè´ªåƒè›‡çš„"ç¿»è½¦"ç»å†

è¿˜è®°å¾—ç¬¬ä¸€æ¬¡ç”¨SFMLå†™è´ªåƒè›‡æ—¶ï¼Œæˆ‘ä¿¡å¿ƒæ»¡æ»¡åœ°å¼€å§‹ç¼–ç ï¼š

```cpp
// æˆ‘çš„ç¬¬ä¸€ä¸ª"æ°ä½œ"
class Snake {
    std::vector<sf::Vector2f> body;
    sf::Vector2f direction;

public:
    void move() {
        // ç§»åŠ¨è›‡èº«
        for (int i = body.size() - 1; i > 0; i--) {
            body[i] = body[i-1];  // ç»å…¸çš„"ç¿»è½¦"ä»£ç 
        }
        body[0] += direction;
    }
};
```

ç»“æœå‘¢ï¼Ÿè›‡å¤´ç§»åŠ¨äº†ï¼Œä½†è›‡èº«æ²¡æœ‰è·Ÿä¸Šï¼Œæ•´ä¸ªè›‡å°±åƒ"æ–­å¤´è›‡"ä¸€æ ·ã€‚å¯¼å¸ˆçœ‹åˆ°åç›´æ¥ç¬‘å‡ºäº†å£°ï¼š"ä½ è¿™æ˜¯åœ¨åš'è´ªåƒè™«'å—ï¼Ÿ"

### ç¬¬äºŒæ¬¡å°è¯•ï¼šä¿„ç½—æ–¯æ–¹å—çš„"å‡ ä½•å™©æ¢¦"

å¥½ä¸å®¹æ˜“æå®šäº†è´ªåƒè›‡ï¼Œæˆ‘åˆå¼€å§‹æŒ‘æˆ˜ä¿„ç½—æ–¯æ–¹å—ï¼š

```cpp
// æˆ‘çš„"å‡ ä½•å­¦å™©æ¢¦"
class Tetris {
    std::vector<std::vector<int>> board;

public:
    bool isValidMove(const Piece& piece, int x, int y) {
        // å¤æ‚çš„ç¢°æ’æ£€æµ‹é€»è¾‘
        // ç»“æœï¼šæ–¹å—å¯ä»¥ç©¿å¢™è€Œè¿‡
        return true;  // æ°¸è¿œè¿”å›trueï¼Œæ–¹å—æ— æ•Œäº†ï¼
    }
};
```

è¿™æ¬¡æ›´æƒ¨ï¼Œæ–¹å—å¯ä»¥ç©¿å¢™ã€é‡å ã€ç”šè‡³"é£å¤©"ã€‚æˆ‘çš„ä¿„ç½—æ–¯æ–¹å—å˜æˆäº†"ä¿„ç½—æ–¯é­”æ³•æ–¹å—"ã€‚

### è§‰é†’æ—¶åˆ»ï¼šæ¸¸æˆå¼€å‘ä¸æ˜¯å†™ä»£ç ï¼Œæ˜¯åˆ›é€ ä¸–ç•Œ

ç»è¿‡æ— æ•°æ¬¡çš„"ç¿»è½¦"ç»å†ï¼Œæˆ‘ç»ˆäºæ˜ç™½ï¼šæ¸¸æˆå¼€å‘ä¸ä»…ä»…æ˜¯å†™ä»£ç ï¼Œæ›´æ˜¯åˆ›é€ ä¸€ä¸ªå®Œæ•´çš„ä¸–ç•Œã€‚æ¯ä¸€ä¸ªç»†èŠ‚éƒ½éœ€è¦ç²¾å¿ƒè®¾è®¡ï¼Œæ¯ä¸€ä¸ªæœºåˆ¶éƒ½éœ€è¦åå¤æµ‹è¯•ã€‚

## ç»å…¸æ¸¸æˆé¡¹ç›®å®ç°

### 1. è´ªåƒè›‡ï¼šä»"æ–­å¤´è›‡"åˆ°å®Œç¾å®ç°

#### æ ¸å¿ƒæ•°æ®ç»“æ„

```cpp
class Snake {
private:
    std::vector<sf::Vector2f> body;
    sf::Vector2f direction;
    float moveTimer;
    float moveInterval;
    bool growing;

public:
    Snake() : direction(1, 0), moveTimer(0), moveInterval(0.2f), growing(false) {
        // åˆå§‹åŒ–è›‡èº«
        body.push_back(sf::Vector2f(400, 300)); // å¤´éƒ¨
        body.push_back(sf::Vector2f(380, 300)); // èº«ä½“
        body.push_back(sf::Vector2f(360, 300)); // å°¾éƒ¨
    }

    void update(float deltaTime) {
        moveTimer += deltaTime;

        if (moveTimer >= moveInterval) {
            move();
            moveTimer = 0;
        }
    }

    void move() {
        // ä¿å­˜å¤´éƒ¨ä½ç½®
        sf::Vector2f newHead = body[0] + direction * 20.0f;

        // ç§»åŠ¨èº«ä½“ï¼ˆä»å°¾éƒ¨å¼€å§‹ï¼Œé¿å…è¦†ç›–ï¼‰
        for (int i = body.size() - 1; i > 0; --i) {
            body[i] = body[i - 1];
        }

        // è®¾ç½®æ–°çš„å¤´éƒ¨ä½ç½®
        body[0] = newHead;

        // å¦‚æœä¸éœ€è¦ç”Ÿé•¿ï¼Œç§»é™¤å°¾éƒ¨
        if (!growing) {
            body.pop_back();
        } else {
            growing = false;
        }
    }

    void grow() {
        growing = true;
    }

    void setDirection(const sf::Vector2f& newDirection) {
        // é˜²æ­¢åå‘ç§»åŠ¨
        if (direction != -newDirection) {
            direction = newDirection;
        }
    }

    bool checkCollision() {
        // æ£€æŸ¥æ˜¯å¦æ’å¢™
        if (body[0].x < 0 || body[0].x >= 800 ||
            body[0].y < 0 || body[0].y >= 600) {
            return true;
        }

        // æ£€æŸ¥æ˜¯å¦æ’åˆ°è‡ªå·±
        for (size_t i = 1; i < body.size(); ++i) {
            if (body[0] == body[i]) {
                return true;
            }
        }

        return false;
    }

    const std::vector<sf::Vector2f>& getBody() const {
        return body;
    }

    sf::Vector2f getHead() const {
        return body[0];
    }
};
```

#### æ¸¸æˆé€»è¾‘å®ç°

```cpp
class SnakeGame : public GameState {
private:
    Snake snake;
    sf::Vector2f food;
    sf::Font font;
    sf::Text scoreText;
    int score;
    bool gameOver;

public:
    SnakeGame() : score(0), gameOver(false) {
        if (!font.loadFromFile("assets/fonts/arial.ttf")) {
            throw std::runtime_error("Failed to load font");
        }

        scoreText.setFont(font);
        scoreText.setCharacterSize(24);
        scoreText.setPosition(10, 10);
        scoreText.setString("Score: 0");

        spawnFood();
    }

    void handleEvent(const sf::Event& event) override {
        if (event.type == sf::Event::KeyPressed && !gameOver) {
            switch (event.key.code) {
                case sf::Keyboard::Up:
                    snake.setDirection(sf::Vector2f(0, -1));
                    break;
                case sf::Keyboard::Down:
                    snake.setDirection(sf::Vector2f(0, 1));
                    break;
                case sf::Keyboard::Left:
                    snake.setDirection(sf::Vector2f(-1, 0));
                    break;
                case sf::Keyboard::Right:
                    snake.setDirection(sf::Vector2f(1, 0));
                    break;
            }
        }

        if (event.type == sf::Event::KeyPressed && gameOver) {
            if (event.key.code == sf::Keyboard::R) {
                // é‡æ–°å¼€å§‹æ¸¸æˆ
                reset();
            }
        }
    }

    void update(float deltaTime) override {
        if (!gameOver) {
            snake.update(deltaTime);

            // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
            if (snake.getHead() == food) {
                snake.grow();
                score += 10;
                scoreText.setString("Score: " + std::to_string(score));
                spawnFood();
            }

            // æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
            if (snake.checkCollision()) {
                gameOver = true;
            }
        }
    }

    void render(sf::RenderWindow& window) override {
        // ç»˜åˆ¶è›‡èº«
        for (const auto& segment : snake.getBody()) {
            sf::RectangleShape rect(sf::Vector2f(18, 18));
            rect.setPosition(segment);
            rect.setFillColor(sf::Color::Green);
            rect.setOutlineColor(sf::Color::DarkGreen);
            rect.setOutlineThickness(1);
            window.draw(rect);
        }

        // ç»˜åˆ¶é£Ÿç‰©
        sf::CircleShape foodShape(8);
        foodShape.setPosition(food);
        foodShape.setFillColor(sf::Color::Red);
        window.draw(foodShape);

        // ç»˜åˆ¶åˆ†æ•°
        window.draw(scoreText);

        // ç»˜åˆ¶æ¸¸æˆç»“æŸä¿¡æ¯
        if (gameOver) {
            sf::Text gameOverText;
            gameOverText.setFont(font);
            gameOverText.setString("Game Over! Press R to restart");
            gameOverText.setCharacterSize(32);
            gameOverText.setPosition(200, 250);
            gameOverText.setColor(sf::Color::Red);
            window.draw(gameOverText);
        }
    }

    void onEnter() override {
        reset();
    }

    void onExit() override {
        // æ¸…ç†èµ„æº
    }

private:
    void spawnFood() {
        // éšæœºç”Ÿæˆé£Ÿç‰©ä½ç½®
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> disX(0, 39);
        std::uniform_int_distribution<> disY(0, 29);

        food = sf::Vector2f(disX(gen) * 20, disY(gen) * 20);
    }

    void reset() {
        snake = Snake();
        score = 0;
        scoreText.setString("Score: 0");
        gameOver = false;
        spawnFood();
    }
};
```

### 2. ä¿„ç½—æ–¯æ–¹å—ï¼šå‡ ä½•å­¦çš„å®Œç¾åº”ç”¨

#### æ–¹å—å½¢çŠ¶å®šä¹‰

```cpp
// æ–¹å—å½¢çŠ¶å®šä¹‰
const std::vector<std::vector<std::vector<int>>> TETROMINOES = {
    // Iå½¢
    {
        {0,0,0,0},
        {1,1,1,1},
        {0,0,0,0},
        {0,0,0,0}
    },
    // Oå½¢
    {
        {1,1},
        {1,1}
    },
    // Tå½¢
    {
        {0,1,0},
        {1,1,1},
        {0,0,0}
    },
    // Så½¢
    {
        {0,1,1},
        {1,1,0},
        {0,0,0}
    },
    // Zå½¢
    {
        {1,1,0},
        {0,1,1},
        {0,0,0}
    },
    // Jå½¢
    {
        {1,0,0},
        {1,1,1},
        {0,0,0}
    },
    // Lå½¢
    {
        {0,0,1},
        {1,1,1},
        {0,0,0}
    }
};

class Tetromino {
private:
    std::vector<std::vector<int>> shape;
    sf::Vector2i position;
    sf::Color color;

public:
    Tetromino(int type) {
        shape = TETROMINOES[type];
        position = sf::Vector2i(3, 0);

        // è®¾ç½®é¢œè‰²
        std::vector<sf::Color> colors = {
            sf::Color::Cyan,    // I
            sf::Color::Yellow,  // O
            sf::Color::Magenta, // T
            sf::Color::Green,   // S
            sf::Color::Red,     // Z
            sf::Color::Blue,    // J
            sf::Color(255, 165, 0) // L (æ©™è‰²)
        };
        color = colors[type];
    }

    void rotate() {
        // çŸ©é˜µæ—‹è½¬90åº¦
        std::vector<std::vector<int>> rotated(shape[0].size(),
                                             std::vector<int>(shape.size()));

        for (size_t i = 0; i < shape.size(); ++i) {
            for (size_t j = 0; j < shape[0].size(); ++j) {
                rotated[j][shape.size() - 1 - i] = shape[i][j];
            }
        }
        shape = rotated;
    }

    void move(const sf::Vector2i& offset) {
        position += offset;
    }

    bool isValidPosition(const std::vector<std::vector<int>>& board) const {
        for (size_t i = 0; i < shape.size(); ++i) {
            for (size_t j = 0; j < shape[i].size(); ++j) {
                if (shape[i][j] == 0) continue;

                int boardX = position.x + j;
                int boardY = position.y + i;

                // æ£€æŸ¥è¾¹ç•Œ
                if (boardX < 0 || boardX >= board[0].size() ||
                    boardY >= board.size()) {
                    return false;
                }

                // æ£€æŸ¥ç¢°æ’
                if (boardY >= 0 && board[boardY][boardX] != 0) {
                    return false;
                }
            }
        }
        return true;
    }

    void placeOnBoard(std::vector<std::vector<int>>& board) const {
        for (size_t i = 0; i < shape.size(); ++i) {
            for (size_t j = 0; j < shape[i].size(); ++j) {
                if (shape[i][j] != 0) {
                    int boardX = position.x + j;
                    int boardY = position.y + i;
                    if (boardY >= 0) {
                        board[boardY][boardX] = 1;
                    }
                }
            }
        }
    }

    const std::vector<std::vector<int>>& getShape() const { return shape; }
    sf::Vector2i getPosition() const { return position; }
    sf::Color getColor() const { return color; }
};
```
            currentPiece = rotated;
        }
    }

    void movePiece(int dx, int dy) {
        sf::Vector2i newPos = piecePos + sf::Vector2i(dx, dy);
        if (canPlace(currentPiece, newPos)) {
            piecePos = newPos;
        }
    }

    void dropPiece() {
        while (canPlace(currentPiece, piecePos + sf::Vector2i(0, 1))) {
            piecePos.y++;
        }
        placePiece();
        clearLines();
        spawnNewPiece();
    }
};
```

### 3. å¼¹çƒæ¸¸æˆ (Pong)

#### æ¸¸æˆç‰¹ç‚¹
- **åŒäººå¯¹æˆ˜**ï¼šæ”¯æŒä¸¤ä¸ªç©å®¶å¯¹æˆ˜
- **ç‰©ç†æ¨¡æ‹Ÿ**ï¼šçƒçš„åå¼¹å’Œé€Ÿåº¦å˜åŒ–
- **AIå¯¹æ‰‹**ï¼šå¯é€‰çš„AIå¯¹æ‰‹

#### æ ¸å¿ƒä»£ç 
```cpp
class Pong {
private:
    sf::RectangleShape leftPaddle, rightPaddle;
    sf::CircleShape ball;
    sf::Vector2f ballVelocity;
    int leftScore, rightScore;

public:
    void update() {
        // æ›´æ–°çƒçš„ä½ç½®
        ball.move(ballVelocity);

        // æ£€æŸ¥è¾¹ç•Œç¢°æ’
        if (ball.getPosition().y <= 0 ||
            ball.getPosition().y >= HEIGHT - ball.getRadius()) {
            ballVelocity.y = -ballVelocity.y;
        }

        // æ£€æŸ¥çƒæ‹ç¢°æ’
        if (ball.getGlobalBounds().intersects(leftPaddle.getGlobalBounds()) ||
            ball.getGlobalBounds().intersects(rightPaddle.getGlobalBounds())) {
            ballVelocity.x = -ballVelocity.x;
            // å¢åŠ çƒçš„é€Ÿåº¦
            ballVelocity *= 1.1f;
        }

        // æ£€æŸ¥å¾—åˆ†
        if (ball.getPosition().x <= 0) {
            rightScore++;
            resetBall();
        } else if (ball.getPosition().x >= WIDTH) {
            leftScore++;
            resetBall();
        }
    }

    void movePaddle(int player, float dy) {
        if (player == 0) {
            leftPaddle.move(0, dy);
        } else {
            rightPaddle.move(0, dy);
        }

        // é™åˆ¶çƒæ‹åœ¨å±å¹•å†…
        if (leftPaddle.getPosition().y < 0) {
            leftPaddle.setPosition(leftPaddle.getPosition().x, 0);
        }
        if (leftPaddle.getPosition().y > HEIGHT - leftPaddle.getSize().y) {
            leftPaddle.setPosition(leftPaddle.getPosition().x,
                                 HEIGHT - leftPaddle.getSize().y);
        }
    }
};
```

### 4. é£æœºå¤§æˆ˜ (Space Shooter)

#### æ¸¸æˆç‰¹ç‚¹
- **æ•Œæœºç”Ÿæˆ**ï¼šéšæœºç”Ÿæˆæ•Œæœº
- **å­å¼¹ç³»ç»Ÿ**ï¼šå‘å°„å­å¼¹å‡»æ¯æ•Œæœº
- **çˆ†ç‚¸æ•ˆæœ**ï¼šæ•Œæœºè¢«å‡»æ¯æ—¶çš„çˆ†ç‚¸åŠ¨ç”»

#### æ ¸å¿ƒä»£ç 
```cpp
class SpaceShooter {
private:
    sf::RectangleShape player;
    std::vector<sf::RectangleShape> enemies;
    std::vector<sf::RectangleShape> bullets;
    int score;

public:
    void update() {
        // æ›´æ–°å­å¼¹ä½ç½®
        for (auto& bullet : bullets) {
            bullet.move(0, -5);
        }

        // æ›´æ–°æ•Œæœºä½ç½®
        for (auto& enemy : enemies) {
            enemy.move(0, 2);
        }

        // æ£€æŸ¥ç¢°æ’
        checkCollisions();

        // æ¸…ç†è¶…å‡ºå±å¹•çš„å¯¹è±¡
        cleanupObjects();

        // ç”Ÿæˆæ–°æ•Œæœº
        if (rand() % 100 < 5) {
            spawnEnemy();
        }
    }

    void shoot() {
        sf::RectangleShape bullet(sf::Vector2f(2, 10));
        bullet.setPosition(player.getPosition().x +
                          player.getSize().x / 2 - 1,
                          player.getPosition().y);
        bullets.push_back(bullet);
    }

    void checkCollisions() {
        // æ£€æŸ¥å­å¼¹å’Œæ•Œæœºçš„ç¢°æ’
        for (auto bulletIt = bullets.begin();
             bulletIt != bullets.end(); ++bulletIt) {
            for (auto enemyIt = enemies.begin();
                 enemyIt != enemies.end(); ++enemyIt) {
                if (bulletIt->getGlobalBounds().intersects(
                    enemyIt->getGlobalBounds())) {
                    bullets.erase(bulletIt);
                    enemies.erase(enemyIt);
                    score += 10;
                    break;
                }
            }
        }
    }
};
```

### 5. è¿·å®«æ¸¸æˆ (Maze)

#### æ¸¸æˆç‰¹ç‚¹
- **è¿·å®«ç”Ÿæˆ**ï¼šä½¿ç”¨ç®—æ³•ç”Ÿæˆéšæœºè¿·å®«
- **è·¯å¾„å¯»æ‰¾**ï¼šå®ç°A*ç®—æ³•å¯»æ‰¾æœ€çŸ­è·¯å¾„
- **ç©å®¶æ§åˆ¶**ï¼šé”®ç›˜æ§åˆ¶ç©å®¶ç§»åŠ¨

#### æ ¸å¿ƒä»£ç 
```cpp
class Maze {
private:
    std::vector<std::vector<int>> maze;
    sf::Vector2i playerPos;
    sf::Vector2i goalPos;

public:
    void generateMaze() {
        // ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ç”Ÿæˆè¿·å®«
        std::vector<std::vector<bool>> visited(HEIGHT,
                                              std::vector<bool>(WIDTH, false));

        std::stack<sf::Vector2i> stack;
        stack.push(sf::Vector2i(1, 1));
        visited[1][1] = true;

        while (!stack.empty()) {
            sf::Vector2i current = stack.top();
            std::vector<sf::Vector2i> neighbors = getUnvisitedNeighbors(current, visited);

            if (neighbors.empty()) {
                stack.pop();
            } else {
                sf::Vector2i next = neighbors[rand() % neighbors.size()];
                removeWall(current, next);
                visited[next.y][next.x] = true;
                stack.push(next);
            }
        }
    }

    bool movePlayer(int dx, int dy) {
        sf::Vector2i newPos = playerPos + sf::Vector2i(dx, dy);

        if (newPos.x >= 0 && newPos.x < WIDTH &&
            newPos.y >= 0 && newPos.y < HEIGHT &&
            maze[newPos.y][newPos.x] == 0) {
            playerPos = newPos;
            return true;
        }
        return false;
    }

    bool isGoalReached() {
        return playerPos == goalPos;
    }
};
```

## æ¸¸æˆå¼€å‘æŠ€å·§

### 1. æ¸¸æˆå¾ªç¯è®¾è®¡
```cpp
class GameLoop {
private:
    sf::Clock clock;
    float deltaTime;

public:
    void run() {
        while (window.isOpen()) {
            // å¤„ç†äº‹ä»¶
            handleEvents();

            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            update(deltaTime);

            // æ¸²æŸ“ç”»é¢
            render();

            // æ§åˆ¶å¸§ç‡
            deltaTime = clock.restart().asSeconds();
            if (deltaTime < 1.0f / 60.0f) {
                sf::sleep(sf::seconds(1.0f / 60.0f - deltaTime));
            }
        }
    }

    void handleEvents() {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed) {
                window.close();
            }
            // å¤„ç†å…¶ä»–äº‹ä»¶
        }
    }
};
```

### 2. çŠ¶æ€ç®¡ç†
```cpp
enum class GameState {
    MENU,
    PLAYING,
    PAUSED,
    GAME_OVER
};

class GameStateManager {
private:
    GameState currentState;

public:
    void update() {
        switch (currentState) {
            case GameState::MENU:
                updateMenu();
                break;
            case GameState::PLAYING:
                updateGame();
                break;
            case GameState::PAUSED:
                updatePause();
                break;
            case GameState::GAME_OVER:
                updateGameOver();
                break;
        }
    }

    void changeState(GameState newState) {
        currentState = newState;
    }
};
```

### 3. èµ„æºç®¡ç†
```cpp
class ResourceManager {
private:
    std::map<std::string, sf::Texture> textures;
    std::map<std::string, sf::Font> fonts;
    std::map<std::string, sf::SoundBuffer> sounds;

public:
    sf::Texture& getTexture(const std::string& name) {
        if (textures.find(name) == textures.end()) {
            textures[name].loadFromFile("assets/textures/" + name + ".png");
        }
        return textures[name];
    }

    sf::Font& getFont(const std::string& name) {
        if (fonts.find(name) == fonts.end()) {
            fonts[name].loadFromFile("assets/fonts/" + name + ".ttf");
        }
        return fonts[name];
    }
};
```

## è¸©å‘ç»éªŒåˆ†äº«

### 1. ç¯å¢ƒé…ç½®å‘
```cpp
// é—®é¢˜ï¼šSFMLåº“é“¾æ¥å¤±è´¥
// é”™è¯¯ä¿¡æ¯ï¼šLNK2019 unresolved external symbol
// è§£å†³æ–¹æ¡ˆï¼š
// 1. æ£€æŸ¥åº“æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®
// 2. ç¡®è®¤Debug/Releaseç‰ˆæœ¬åŒ¹é…
// 3. æ£€æŸ¥ä¾èµ–é¡¹æ˜¯å¦å®Œæ•´

// é—®é¢˜ï¼šDLLæ–‡ä»¶æ‰¾ä¸åˆ°
// é”™è¯¯ä¿¡æ¯ï¼šThe program can't start because xxx.dll is missing
// è§£å†³æ–¹æ¡ˆï¼š
// 1. å°†SFMLçš„binç›®å½•æ·»åŠ åˆ°ç³»ç»ŸPATH
// 2. æˆ–è€…å°†DLLæ–‡ä»¶å¤åˆ¶åˆ°å¯æ‰§è¡Œæ–‡ä»¶ç›®å½•
```

### 2. æ¸¸æˆé€»è¾‘å‘
```cpp
// é—®é¢˜ï¼šæ¸¸æˆå¾ªç¯å¡é¡¿
// é”™è¯¯åšæ³•ï¼šæ²¡æœ‰æ§åˆ¶å¸§ç‡
// æ­£ç¡®åšæ³•ï¼šä½¿ç”¨sf::Clockæ§åˆ¶å¸§ç‡

// é—®é¢˜ï¼šç¢°æ’æ£€æµ‹ä¸å‡†ç¡®
// é”™è¯¯åšæ³•ï¼šä½¿ç”¨ç®€å•çš„çŸ©å½¢ç¢°æ’
// æ­£ç¡®åšæ³•ï¼šæ ¹æ®æ¸¸æˆéœ€æ±‚é€‰æ‹©åˆé€‚çš„ç¢°æ’æ£€æµ‹ç®—æ³•

// é—®é¢˜ï¼šå†…å­˜æ³„æ¼
// é”™è¯¯åšæ³•ï¼šé¢‘ç¹åˆ›å»ºåˆ é™¤å¯¹è±¡
// æ­£ç¡®åšæ³•ï¼šä½¿ç”¨å¯¹è±¡æ± æˆ–æ™ºèƒ½æŒ‡é’ˆ
```

### 3. æ€§èƒ½ä¼˜åŒ–å‘
```cpp
// é—®é¢˜ï¼šæ¸²æŸ“æ€§èƒ½å·®
// é”™è¯¯åšæ³•ï¼šæ¯å¸§é‡æ–°åˆ›å»ºå›¾å½¢å¯¹è±¡
// æ­£ç¡®åšæ³•ï¼šé¢„åˆ›å»ºå¯¹è±¡ï¼Œåªæ›´æ–°ä½ç½®

// é—®é¢˜ï¼šéŸ³æ•ˆæ’­æ”¾å¡é¡¿
// é”™è¯¯åšæ³•ï¼šåŒæ—¶æ’­æ”¾å¤ªå¤šéŸ³æ•ˆ
// æ­£ç¡®åšæ³•ï¼šé™åˆ¶åŒæ—¶æ’­æ”¾çš„éŸ³æ•ˆæ•°é‡

// é—®é¢˜ï¼šæ¸¸æˆå¡é¡¿
// é”™è¯¯åšæ³•ï¼šåœ¨æ¸²æŸ“å¾ªç¯ä¸­è¿›è¡Œå¤æ‚è®¡ç®—
// æ­£ç¡®åšæ³•ï¼šå°†è®¡ç®—åˆ†æ•£åˆ°å¤šä¸ªå¸§ä¸­
```

## é¡¹ç›®æ€»ç»“

### 1. æŠ€æœ¯æ”¶è·
- **å›¾å½¢ç¼–ç¨‹**ï¼šæŒæ¡äº†SFMLçš„åŸºæœ¬ç”¨æ³•
- **æ¸¸æˆè®¾è®¡**ï¼šå­¦ä¼šäº†æ¸¸æˆå¾ªç¯å’ŒçŠ¶æ€ç®¡ç†
- **ç‰©ç†æ¨¡æ‹Ÿ**ï¼šç†è§£äº†åŸºæœ¬çš„ç‰©ç†æ¦‚å¿µ
- **éŸ³æ•ˆå¤„ç†**ï¼šå­¦ä¼šäº†éŸ³é¢‘æ’­æ”¾å’Œç®¡ç†

### 2. å¼€å‘ç»éªŒ
- **æ¨¡å—åŒ–è®¾è®¡**ï¼šå°†æ¸¸æˆåˆ†è§£ä¸ºå¤šä¸ªæ¨¡å—
- **ä»£ç å¤ç”¨**ï¼šæå–å…¬å…±åŠŸèƒ½ä¸ºåŸºç±»
- **è°ƒè¯•æŠ€å·§**ï¼šä½¿ç”¨è°ƒè¯•å·¥å…·å®šä½é—®é¢˜
- **æ€§èƒ½ä¼˜åŒ–**ï¼šä¼˜åŒ–å…³é”®è·¯å¾„çš„æ€§èƒ½

### 3. å­¦ä¹ å»ºè®®
- **ä»ç®€å•å¼€å§‹**ï¼šå…ˆå®ç°ç®€å•çš„æ¸¸æˆï¼Œå†é€æ­¥å¢åŠ å¤æ‚åº¦
- **å¤šçœ‹æºç **ï¼šå­¦ä¹ ä¼˜ç§€çš„å¼€æºæ¸¸æˆé¡¹ç›®
- **å®è·µä¸ºä¸»**ï¼šç†è®ºç»“åˆå®è·µï¼Œå¤šå†™ä»£ç 
- **æŒç»­å­¦ä¹ **ï¼šå…³æ³¨æ¸¸æˆå¼€å‘çš„æ–°æŠ€æœ¯å’Œè¶‹åŠ¿

## å‚è€ƒèµ„æ–™

### å®˜æ–¹æ–‡æ¡£
- [SFMLå®˜æ–¹æ–‡æ¡£](https://www.sfml-dev.org/documentation.php)
- [SFMLæ•™ç¨‹](https://www.sfml-dev.org/tutorials.php)
- [SFMLç¤ºä¾‹](https://github.com/SFML/SFML/tree/master/examples)

### å­¦ä¹ èµ„æº
- [æ¸¸æˆå¼€å‘æ•™ç¨‹](https://www.gamefromscratch.com/)
- [C++æ¸¸æˆç¼–ç¨‹](https://www.learncpp.com/)
- [OpenGLæ•™ç¨‹](https://learnopengl.com/)

---

**å†™åœ¨æœ€å**ï¼šæ¸¸æˆå¼€å‘æ˜¯ä¸€ä¸ªå……æ»¡æŒ‘æˆ˜å’Œä¹è¶£çš„é¢†åŸŸï¼Œéœ€è¦æ‰å®çš„ç¼–ç¨‹åŸºç¡€å’Œä¸°å¯Œçš„æƒ³è±¡åŠ›ã€‚ä½œä¸ºä¸€ä¸ªæŠ€æœ¯åºŸæŸ´ï¼Œæˆ‘æ·±æ·±ä½“ä¼šåˆ°å®è·µå’ŒåšæŒçš„é‡è¦æ€§ã€‚è®°ä½ï¼Œæ¯ä¸€ä¸ªæ¸¸æˆå¤§ç¥éƒ½æ˜¯ä»ç®€å•çš„"Hello World"å¼€å§‹çš„ï¼

> ğŸ’¡ **åºŸæŸ´å°è´´å£«**ï¼šå½“ä½ å¼€å§‹æ¸¸æˆå¼€å‘æ—¶ï¼Œä¸è¦å®³æ€•ä»ç®€å•çš„é¡¹ç›®å¼€å§‹ï¼Œæ¯ä¸€ä¸ªç»å…¸æ¸¸æˆéƒ½æœ‰å…¶ç‹¬ç‰¹çš„é­…åŠ›ã€‚æ¯ä¸€ä¸ªæŠ€æœ¯åºŸæŸ´éƒ½æœ‰æˆä¸ºæ¸¸æˆå¼€å‘è€…çš„æ½œåŠ›ã€‚
6:T2556,# UnityæŠ¥é”™æ—¥è®°ï¼šç¬¬1001æ¬¡æƒ³æ”¾å¼ƒ

> ä½œä¸ºä¸€ä¸ªæ‰‹æ®‹å…šï¼Œåœ¨Unityå¼€å‘ä¸­é‡åˆ°çš„å¥‡è‘©é—®é¢˜ï¼Œä»¥åŠæˆ‘çš„è§£å†³æ€è·¯

## å‰è¨€

ä½œä¸ºä¸€ä¸ªæŠ€æœ¯åºŸæŸ´ï¼Œæˆ‘åœ¨Unityå¼€å‘çš„é“è·¯ä¸Šå¯è°“æ˜¯è·Œè·Œæ’æ’ï¼Œæ¯æ¬¡é‡åˆ°æŠ¥é”™éƒ½è®©æˆ‘æ€€ç–‘äººç”Ÿã€‚ä½†æ˜¯ç»è¿‡æ— æ•°æ¬¡çš„å°è¯•å’Œå¤±è´¥ï¼Œæˆ‘ç»ˆäºæ€»ç»“å‡ºäº†ä¸€äº›ç»éªŒã€‚è¿™ç¯‡æ–‡ç« è®°å½•äº†æˆ‘é‡åˆ°çš„å„ç§å¥‡è‘©é—®é¢˜ï¼Œä»¥åŠæˆ‘æ˜¯å¦‚ä½•ä¸€æ­¥æ­¥è§£å†³çš„ã€‚

## å¸¸è§æŠ¥é”™ç±»å‹åŠè§£å†³æ–¹æ¡ˆ

### 1. NullReferenceException - ç©ºå¼•ç”¨å¼‚å¸¸

è¿™æ˜¯Unityä¸­æœ€å¸¸è§çš„æŠ¥é”™ï¼Œæ²¡æœ‰ä¹‹ä¸€ã€‚

#### é”™è¯¯ä¿¡æ¯
```
NullReferenceException: Object reference not set to an instance of an object
```

#### å¸¸è§åŸå› 
- ç»„ä»¶æœªæ­£ç¡®èµ‹å€¼
- GameObjectè¢«é”€æ¯ä½†è„šæœ¬ä»åœ¨è¿è¡Œ
- åºåˆ—åŒ–å­—æ®µæœªåœ¨Inspectorä¸­è®¾ç½®

#### è§£å†³æ–¹æ¡ˆ

```csharp
// é”™è¯¯ç¤ºä¾‹
public class PlayerController : MonoBehaviour
{
    public Rigidbody rb; // å¯èƒ½ä¸ºnull

    void Start()
    {
        rb.AddForce(Vector3.up * 10f); // æŠ¥é”™ï¼
    }
}

// æ­£ç¡®ç¤ºä¾‹
public class PlayerController : MonoBehaviour
{
    [SerializeField] private Rigidbody rb;

    void Start()
    {
        // æ–¹æ³•1ï¼šæ£€æŸ¥null
        if (rb != null)
        {
            rb.AddForce(Vector3.up * 10f);
        }

        // æ–¹æ³•2ï¼šè‡ªåŠ¨è·å–ç»„ä»¶
        if (rb == null)
        {
            rb = GetComponent<Rigidbody>();
        }

        // æ–¹æ³•3ï¼šä½¿ç”¨TryGetComponent
        if (TryGetComponent<Rigidbody>(out Rigidbody rigidbody))
        {
            rigidbody.AddForce(Vector3.up * 10f);
        }
    }
}
```

### 2. MissingReferenceException - ä¸¢å¤±å¼•ç”¨å¼‚å¸¸

è¿™ä¸ªé”™è¯¯é€šå¸¸å‘ç”Ÿåœ¨åœºæ™¯åˆ‡æ¢æˆ–å¯¹è±¡é”€æ¯åã€‚

#### é”™è¯¯ä¿¡æ¯
```
MissingReferenceException: The object of type 'GameObject' has been destroyed but you are still trying to access it.
```

#### è§£å†³æ–¹æ¡ˆ

```csharp
public class GameManager : MonoBehaviour
{
    private GameObject player;

    void Update()
    {
        // é”™è¯¯ç¤ºä¾‹
        if (player != null)
        {
            player.transform.position = Vector3.zero; // å¯èƒ½æŠ¥é”™
        }

        // æ­£ç¡®ç¤ºä¾‹
        if (player != null && player != null)
        {
            player.transform.position = Vector3.zero;
        }

        // æ›´å¥½çš„æ–¹æ³•ï¼šä½¿ç”¨Object.ReferenceEquals
        if (!Object.ReferenceEquals(player, null))
        {
            player.transform.position = Vector3.zero;
        }
    }
}
```

### 3. IndexOutOfRangeException - æ•°ç»„è¶Šç•Œå¼‚å¸¸

åœ¨æ“ä½œæ•°ç»„æˆ–Listæ—¶ç»å¸¸é‡åˆ°ã€‚

#### é”™è¯¯ä¿¡æ¯
```
IndexOutOfRangeException: Index was outside the bounds of the array.
```

#### è§£å†³æ–¹æ¡ˆ

```csharp
public class ItemManager : MonoBehaviour
{
    public List<GameObject> items = new List<GameObject>();

    void Start()
    {
        // é”™è¯¯ç¤ºä¾‹
        GameObject firstItem = items[0]; // å¦‚æœåˆ—è¡¨ä¸ºç©ºä¼šæŠ¥é”™

        // æ­£ç¡®ç¤ºä¾‹
        if (items.Count > 0)
        {
            GameObject firstItem = items[0];
        }

        // ä½¿ç”¨å®‰å…¨çš„è®¿é—®æ–¹æ³•
        GameObject GetItem(int index)
        {
            if (index >= 0 && index < items.Count)
            {
                return items[index];
            }
            return null;
        }
    }
}
```

### 4. Coroutineç›¸å…³é”™è¯¯

åç¨‹æ˜¯Unityä¸­å¸¸ç”¨çš„åŠŸèƒ½ï¼Œä½†ä¹Ÿå®¹æ˜“å‡ºé”™ã€‚

#### å¸¸è§é—®é¢˜
- åç¨‹åœ¨å¯¹è±¡é”€æ¯åä»åœ¨è¿è¡Œ
- é‡å¤å¯åŠ¨åŒä¸€ä¸ªåç¨‹
- åç¨‹ä¸­çš„ç©ºå¼•ç”¨

#### è§£å†³æ–¹æ¡ˆ

```csharp
public class CoroutineManager : MonoBehaviour
{
    private Coroutine currentCoroutine;

    void Start()
    {
        // é”™è¯¯ç¤ºä¾‹
        StartCoroutine(MyCoroutine());
        StartCoroutine(MyCoroutine()); // é‡å¤å¯åŠ¨

        // æ­£ç¡®ç¤ºä¾‹
        if (currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
        }
        currentCoroutine = StartCoroutine(MyCoroutine());
    }

    IEnumerator MyCoroutine()
    {
        while (true)
        {
            // æ£€æŸ¥å¯¹è±¡æ˜¯å¦è¿˜å­˜åœ¨
            if (this == null || gameObject == null)
            {
                yield break; // é€€å‡ºåç¨‹
            }

            yield return new WaitForSeconds(1f);
        }
    }

    void OnDestroy()
    {
        // æ¸…ç†åç¨‹
        if (currentCoroutine != null)
        {
            StopCoroutine(currentCoroutine);
        }
    }
}
```

### 5. åºåˆ—åŒ–ç›¸å…³é”™è¯¯

åœ¨ä¿å­˜å’ŒåŠ è½½æ•°æ®æ—¶ç»å¸¸é‡åˆ°ã€‚

#### é”™è¯¯ä¿¡æ¯
```
SerializationException: Type 'MyClass' is not marked as serializable.
```

#### è§£å†³æ–¹æ¡ˆ

```csharp
// é”™è¯¯ç¤ºä¾‹
public class MyClass
{
    public string name;
    public int value;
}

// æ­£ç¡®ç¤ºä¾‹
[System.Serializable]
public class MyClass
{
    public string name;
    public int value;
}

// å¦‚æœéœ€è¦è‡ªå®šä¹‰åºåˆ—åŒ–
[System.Serializable]
public class CustomSerializableClass : ISerializationCallbackReceiver
{
    [SerializeField] private string serializedName;
    [SerializeField] private int serializedValue;

    public string Name { get; set; }
    public int Value { get; set; }

    public void OnBeforeSerialize()
    {
        serializedName = Name;
        serializedValue = Value;
    }

    public void OnAfterDeserialize()
    {
        Name = serializedName;
        Value = serializedValue;
    }
}
```

## è°ƒè¯•æŠ€å·§

### 1. ä½¿ç”¨Debug.Logè¿›è¡Œè°ƒè¯•

```csharp
public class DebugHelper : MonoBehaviour
{
    void Start()
    {
        Debug.Log("æ¸¸æˆå¼€å§‹");
        Debug.LogWarning("è¿™æ˜¯ä¸€ä¸ªè­¦å‘Š");
        Debug.LogError("è¿™æ˜¯ä¸€ä¸ªé”™è¯¯");

        // æ¡ä»¶è°ƒè¯•
        #if UNITY_EDITOR
        Debug.Log("åªåœ¨ç¼–è¾‘å™¨ä¸­æ˜¾ç¤º");
        #endif

        // æ ¼å¼åŒ–è¾“å‡º
        Debug.LogFormat("ç©å®¶ä½ç½®: {0}, ç”Ÿå‘½å€¼: {1}", transform.position, 100);
    }
}
```

### 2. ä½¿ç”¨æ–­ç‚¹è°ƒè¯•

åœ¨Visual Studioæˆ–Riderä¸­è®¾ç½®æ–­ç‚¹ï¼Œç„¶åä½¿ç”¨Unityçš„è°ƒè¯•æ¨¡å¼ã€‚

### 3. ä½¿ç”¨Unity Profiler

åˆ†ææ€§èƒ½é—®é¢˜ï¼Œæ‰¾å‡ºå¡é¡¿çš„åŸå› ã€‚

## é¢„é˜²æªæ–½

### 1. ä»£ç è§„èŒƒ

```csharp
// ä½¿ç”¨å±æ€§è€Œä¸æ˜¯å…¬å…±å­—æ®µ
public class Player : MonoBehaviour
{
    [SerializeField] private float health = 100f;
    [SerializeField] private float speed = 5f;

    public float Health
    {
        get => health;
        set => health = Mathf.Clamp(value, 0f, 100f);
    }

    public float Speed
    {
        get => speed;
        set => speed = Mathf.Max(0f, value);
    }
}
```

### 2. ä½¿ç”¨[RequireComponent]ç‰¹æ€§

```csharp
[RequireComponent(typeof(Rigidbody))]
[RequireComponent(typeof(Collider))]
public class PlayerController : MonoBehaviour
{
    private Rigidbody rb;
    private Collider col;

    void Awake()
    {
        rb = GetComponent<Rigidbody>();
        col = GetComponent<Collider>();
    }
}
```

### 3. ä½¿ç”¨[SerializeField]å’Œ[Header]

```csharp
public class Enemy : MonoBehaviour
{
    [Header("åŸºç¡€å±æ€§")]
    [SerializeField] private float health = 100f;
    [SerializeField] private float damage = 10f;

    [Header("ç§»åŠ¨è®¾ç½®")]
    [SerializeField] private float moveSpeed = 3f;
    [SerializeField] private float rotationSpeed = 90f;

    [Header("æ”»å‡»è®¾ç½®")]
    [SerializeField] private float attackRange = 2f;
    [SerializeField] private float attackCooldown = 1f;
}
```

## å¸¸è§é™·é˜±

### 1. åœ¨Updateä¸­ä½¿ç”¨FindObjectOfType

```csharp
// é”™è¯¯ç¤ºä¾‹ - æ€§èƒ½æå·®
void Update()
{
    Player player = FindObjectOfType<Player>();
    if (player != null)
    {
        // å¤„ç†é€»è¾‘
    }
}

// æ­£ç¡®ç¤ºä¾‹
private Player player;

void Start()
{
    player = FindObjectOfType<Player>();
}

void Update()
{
    if (player != null)
    {
        // å¤„ç†é€»è¾‘
    }
}
```

### 2. åœ¨åç¨‹ä¸­ä½¿ç”¨yield return null

```csharp
// é”™è¯¯ç¤ºä¾‹ - æ¯å¸§æ‰§è¡Œ
IEnumerator BadCoroutine()
{
    while (true)
    {
        // å¤„ç†é€»è¾‘
        yield return null; // æ¯å¸§æ‰§è¡Œï¼Œæ€§èƒ½å·®
    }
}

// æ­£ç¡®ç¤ºä¾‹
IEnumerator GoodCoroutine()
{
    while (true)
    {
        // å¤„ç†é€»è¾‘
        yield return new WaitForSeconds(0.1f); // æ¯0.1ç§’æ‰§è¡Œä¸€æ¬¡
    }
}
```

### 3. å¿˜è®°æ¸…ç†äº‹ä»¶ç›‘å¬

```csharp
public class EventManager : MonoBehaviour
{
    void OnEnable()
    {
        GameEvents.OnPlayerDeath += HandlePlayerDeath;
    }

    void OnDisable()
    {
        // é‡è¦ï¼šæ¸…ç†äº‹ä»¶ç›‘å¬
        GameEvents.OnPlayerDeath -= HandlePlayerDeath;
    }

    void HandlePlayerDeath()
    {
        Debug.Log("ç©å®¶æ­»äº¡");
    }
}
```

## æ€»ç»“

Unityå¼€å‘ä¸­çš„æŠ¥é”™æ˜¯ä¸å¯é¿å…çš„ï¼Œä½†é€šè¿‡è‰¯å¥½çš„ç¼–ç¨‹ä¹ æƒ¯å’Œè°ƒè¯•æŠ€å·§ï¼Œæˆ‘ä»¬å¯ä»¥å¤§å¤§å‡å°‘é”™è¯¯çš„å‘ç”Ÿã€‚è®°ä½ä»¥ä¸‹å‡ ç‚¹ï¼š

1. **æ€»æ˜¯æ£€æŸ¥nullå¼•ç”¨**
2. **ä½¿ç”¨é€‚å½“çš„è®¿é—®ä¿®é¥°ç¬¦**
3. **åŠæ—¶æ¸…ç†èµ„æº**
4. **ç¼–å†™é˜²å¾¡æ€§ä»£ç **
5. **å–„ç”¨è°ƒè¯•å·¥å…·**

è™½ç„¶æœ‰æ—¶å€™çœŸçš„æƒ³æ”¾å¼ƒï¼Œä½†æ¯æ¬¡è§£å†³ä¸€ä¸ªbugåçš„æˆå°±æ„Ÿæ˜¯æ— å¯æ›¿ä»£çš„ã€‚ä½œä¸ºä¸€ä¸ªæŠ€æœ¯åºŸæŸ´ï¼Œæˆ‘æ·±çŸ¥å­¦ä¹ Unityçš„é“è·¯å¹¶ä¸å®¹æ˜“ï¼Œä½†åªè¦åšæŒä¸‹å»ï¼Œæ€»ä¼šæœ‰æ‰€æ”¶è·ã€‚

---

*æ ‡ç­¾ï¼šUnity, æ¸¸æˆå¼€å‘, æŠ¥é”™å¤„ç†, è°ƒè¯•æŠ€å·§, è¸©å‘ç»éªŒ*
7:T3d26,# UE5æ¸¸æˆå¼€å‘å®æˆ˜æ•™ç¨‹

> æ·±å…¥Unreal Engine 5çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œä»è“å›¾ç¼–ç¨‹åˆ°C++å¼€å‘ï¼Œæ‰“é€ é«˜è´¨é‡æ¸¸æˆä½œå“

## å‰è¨€

Unreal Engine 5ä½œä¸ºEpic Gamesæœ€æ–°æ¨å‡ºçš„æ¸¸æˆå¼•æ“ï¼Œå¸¦æ¥äº†é©å‘½æ€§çš„æŠ€æœ¯é©æ–°ï¼ŒåŒ…æ‹¬Naniteè™šæ‹Ÿå‡ ä½•ä½“ç³»ç»Ÿã€Lumenå…¨å±€å…‰ç…§ç³»ç»Ÿç­‰ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨UE5çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œä»è“å›¾ç¼–ç¨‹åˆ°C++å¼€å‘ï¼Œä¸ºæ¸¸æˆå¼€å‘è€…æä¾›å…¨é¢çš„æŠ€æœ¯æŒ‡å¯¼ã€‚

## UE5æ ¸å¿ƒæŠ€æœ¯ç‰¹æ€§

### 1. Naniteè™šæ‹Ÿå‡ ä½•ä½“ç³»ç»Ÿ

Naniteæ˜¯UE5çš„æ ‡å¿—æ€§æŠ€æœ¯ï¼Œå…è®¸æ¸²æŸ“æ•°åäº¿çº§åˆ«çš„å‡ ä½•ä½“ç»†èŠ‚ï¼Œæ— éœ€æ‹…å¿ƒå¤šè¾¹å½¢æ•°é‡é™åˆ¶ã€‚

#### æŠ€æœ¯åŸç†
- **è™šæ‹Ÿå‡ ä½•ä½“**ï¼šå°†å‡ ä½•ä½“æ•°æ®å­˜å‚¨åœ¨GPUå†…å­˜ä¸­
- **è‡ªé€‚åº”LOD**ï¼šæ ¹æ®è§†è·è‡ªåŠ¨è°ƒæ•´ç»†èŠ‚çº§åˆ«
- **æ— é™åˆ¶å¤šè¾¹å½¢**ï¼šç†è®ºä¸Šæ”¯æŒæ— é™å¤šè¾¹å½¢æ•°é‡

#### åº”ç”¨åœºæ™¯
```cpp
// å¯ç”¨Naniteçš„é™æ€ç½‘æ ¼ä½“
UStaticMeshComponent* MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("NaniteMesh"));
MeshComponent->SetStaticMesh(NaniteMesh);
MeshComponent->SetNaniteEnabled(true);
```

### 2. Lumenå…¨å±€å…‰ç…§ç³»ç»Ÿ

Lumenæä¾›äº†å®æ—¶çš„å…¨å±€å…‰ç…§è§£å†³æ–¹æ¡ˆï¼Œæ”¯æŒåŠ¨æ€å…‰æºå’Œé—´æ¥å…‰ç…§ã€‚

#### ç‰¹æ€§
- **å®æ—¶å…¨å±€å…‰ç…§**ï¼šæ— éœ€é¢„è®¡ç®—å…‰ç…§è´´å›¾
- **åŠ¨æ€å…‰æº**ï¼šæ”¯æŒç§»åŠ¨å’Œå˜åŒ–çš„å…‰æº
- **é—´æ¥å…‰ç…§**ï¼šè‡ªåŠ¨è®¡ç®—åå°„å’Œæ•£å°„

#### é…ç½®ç¤ºä¾‹
```cpp
// åœ¨C++ä¸­é…ç½®Lumen
void AMyGameMode::ConfigureLumen()
{
    // å¯ç”¨Lumenå…¨å±€å…‰ç…§
    UWorld* World = GetWorld();
    if (World)
    {
        World->GetWorldSettings()->bEnableLumen = true;
        World->GetWorldSettings()->LumenSettings.GlobalIlluminationMethod = EGlobalIlluminationMethod::Lumen;
    }
}
```

## è“å›¾ç¼–ç¨‹åŸºç¡€

### 1. è“å›¾ç³»ç»Ÿæ¶æ„

UE5çš„è“å›¾ç³»ç»Ÿæä¾›äº†å¼ºå¤§çš„å¯è§†åŒ–ç¼–ç¨‹èƒ½åŠ›ï¼Œé€‚åˆå¿«é€ŸåŸå‹å¼€å‘ã€‚

#### è“å›¾ç±»å‹
- **Level Blueprint**ï¼šå…³å¡çº§åˆ«çš„é€»è¾‘
- **Class Blueprint**ï¼šå¯é‡ç”¨çš„ç»„ä»¶ç±»
- **Interface Blueprint**ï¼šæ¥å£å®šä¹‰
- **Function Library**ï¼šå‡½æ•°åº“

#### åŸºç¡€è“å›¾ç¤ºä¾‹

```cpp
// å¯¹åº”çš„C++ä»£ç ç¤ºä¾‹
UCLASS(BlueprintType, Blueprintable)
class MYGAME_API AMyCharacter : public ACharacter
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Health")
    float Health;

    UFUNCTION(BlueprintCallable, Category = "Combat")
    void TakeDamage(float DamageAmount);

    UFUNCTION(BlueprintImplementableEvent, Category = "Effects")
    void OnDamageTaken();
};
```

### 2. äº‹ä»¶é©±åŠ¨ç¼–ç¨‹

è“å›¾ä½¿ç”¨äº‹ä»¶é©±åŠ¨æ¨¡å‹ï¼Œå“åº”æ¸¸æˆä¸­çš„å„ç§äº‹ä»¶ã€‚

#### å¸¸ç”¨äº‹ä»¶
- **BeginPlay**ï¼šActorå¼€å§‹æ¸¸æˆæ—¶è§¦å‘
- **Tick**ï¼šæ¯å¸§æ‰§è¡Œ
- **OnComponentBeginOverlap**ï¼šç»„ä»¶å¼€å§‹é‡å 
- **OnComponentHit**ï¼šç»„ä»¶è¢«å‡»ä¸­

#### äº‹ä»¶å¤„ç†ç¤ºä¾‹
```cpp
// åœ¨C++ä¸­å¤„ç†äº‹ä»¶
void AMyActor::BeginPlay()
{
    Super::BeginPlay();

    // ç»‘å®šé‡å äº‹ä»¶
    OnActorBeginOverlap.AddDynamic(this, &AMyActor::OnOverlapBegin);
}

void AMyActor::OnOverlapBegin(AActor* OverlappedActor, AActor* OtherActor)
{
    if (OtherActor && OtherActor->IsA(APlayerCharacter::StaticClass()))
    {
        // ç©å®¶è¿›å…¥è§¦å‘åŒºåŸŸ
        OnPlayerEntered();
    }
}
```

## C++å¼€å‘è¿›é˜¶

### 1. ç±»è®¾è®¡æ¨¡å¼

åœ¨UE5ä¸­ï¼Œè‰¯å¥½çš„ç±»è®¾è®¡æ˜¯æˆåŠŸçš„å…³é”®ã€‚

#### åŸºç¡€Actorç±»
```cpp
UCLASS(BlueprintType, Blueprintable)
class MYGAME_API AMyGameActor : public AActor
{
    GENERATED_BODY()

public:
    AMyGameActor();

protected:
    virtual void BeginPlay() override;
    virtual void Tick(float DeltaTime) override;

    // ç»„ä»¶
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
    UStaticMeshComponent* MeshComponent;

    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
    USphereComponent* CollisionComponent;

    // å±æ€§
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Gameplay")
    float MovementSpeed;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Gameplay")
    float Health;

    // å‡½æ•°
    UFUNCTION(BlueprintCallable, Category = "Gameplay")
    void TakeDamage(float DamageAmount);

    UFUNCTION(BlueprintPure, Category = "Gameplay")
    bool IsAlive() const;

private:
    void UpdateMovement(float DeltaTime);
    void CheckHealth();
};
```

### 2. ç»„ä»¶ç³»ç»Ÿ

UE5çš„ç»„ä»¶ç³»ç»Ÿæä¾›äº†æ¨¡å—åŒ–çš„è®¾è®¡æ–¹å¼ã€‚

#### è‡ªå®šä¹‰ç»„ä»¶
```cpp
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class MYGAME_API UHealthComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    UHealthComponent();

protected:
    virtual void BeginPlay() override;

public:
    virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

    // å±æ€§
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Health")
    float MaxHealth;

    UPROPERTY(BlueprintReadOnly, Category = "Health")
    float CurrentHealth;

    // äº‹ä»¶
    UPROPERTY(BlueprintAssignable, Category = "Health")
    FOnHealthChanged OnHealthChanged;

    UPROPERTY(BlueprintAssignable, Category = "Health")
    FOnDeath OnDeath;

    // å‡½æ•°
    UFUNCTION(BlueprintCallable, Category = "Health")
    void TakeDamage(float DamageAmount);

    UFUNCTION(BlueprintCallable, Category = "Health")
    void Heal(float HealAmount);

    UFUNCTION(BlueprintPure, Category = "Health")
    float GetHealthPercentage() const;

private:
    void UpdateHealth(float NewHealth);
};

// äº‹ä»¶å§”æ‰˜å®šä¹‰
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnHealthChanged, float, OldHealth, float, NewHealth);
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnDeath);
```

### 3. æ¥å£ç³»ç»Ÿ

æ¥å£æä¾›äº†æ¾è€¦åˆçš„è®¾è®¡æ–¹å¼ã€‚

#### æ¥å£å®šä¹‰
```cpp
UINTERFACE(MinimalAPI, Blueprintable)
class UInteractable : public UInterface
{
    GENERATED_BODY()
};

class IInteractable
{
    GENERATED_BODY()

public:
    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Interaction")
    void OnInteract(AActor* Interactor);

    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Interaction")
    bool CanInteract(AActor* Interactor) const;

    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Interaction")
    FText GetInteractionText() const;
};
```

#### æ¥å£å®ç°
```cpp
UCLASS()
class MYGAME_API AInteractableActor : public AActor, public IInteractable
{
    GENERATED_BODY()

public:
    AInteractableActor();

protected:
    virtual void BeginPlay() override;

    // æ¥å£å®ç°
    virtual void OnInteract_Implementation(AActor* Interactor) override;
    virtual bool CanInteract_Implementation(AActor* Interactor) const override;
    virtual FText GetInteractionText_Implementation() const override;

private:
    UPROPERTY(EditAnywhere, Category = "Interaction")
    FText InteractionText;

    UPROPERTY(EditAnywhere, Category = "Interaction")
    float InteractionRange;
};
```

## æ¸¸æˆç³»ç»Ÿå¼€å‘

### 1. è¾“å…¥ç³»ç»Ÿ

UE5æä¾›äº†å¼ºå¤§çš„è¾“å…¥ç³»ç»Ÿï¼Œæ”¯æŒå¤šç§è¾“å…¥è®¾å¤‡ã€‚

#### è¾“å…¥æ˜ å°„
```cpp
// åœ¨é¡¹ç›®è®¾ç½®ä¸­é…ç½®è¾“å…¥æ˜ å°„
void AMyPlayerController::SetupInputComponent()
{
    Super::SetupInputComponent();

    // ç»‘å®šåŠ¨ä½œæ˜ å°„
    InputComponent->BindAction("Jump", IE_Pressed, this, &AMyPlayerController::OnJumpPressed);
    InputComponent->BindAction("Jump", IE_Released, this, &AMyPlayerController::OnJumpReleased);
    InputComponent->BindAction("Fire", IE_Pressed, this, &AMyPlayerController::OnFirePressed);

    // ç»‘å®šè½´æ˜ å°„
    InputComponent->BindAxis("MoveForward", this, &AMyPlayerController::MoveForward);
    InputComponent->BindAxis("MoveRight", this, &AMyPlayerController::MoveRight);
    InputComponent->BindAxis("Turn", this, &AMyPlayerController::Turn);
    InputComponent->BindAxis("LookUp", this, &AMyPlayerController::LookUp);
}
```

### 2. æ¸¸æˆæ¨¡å¼ç³»ç»Ÿ

æ¸¸æˆæ¨¡å¼å®šä¹‰äº†æ¸¸æˆçš„æ ¸å¿ƒè§„åˆ™å’Œæµç¨‹ã€‚

#### è‡ªå®šä¹‰æ¸¸æˆæ¨¡å¼
```cpp
UCLASS(BlueprintType, Blueprintable)
class MYGAME_API AMyGameMode : public AGameModeBase
{
    GENERATED_BODY()

public:
    AMyGameMode();

protected:
    virtual void BeginPlay() override;
    virtual void PostLogin(APlayerController* NewPlayer) override;
    virtual void Logout(AController* Exiting) override;

    // æ¸¸æˆçŠ¶æ€
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Gameplay")
    float GameTime;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Gameplay")
    int32 MaxPlayers;

    // äº‹ä»¶
    UFUNCTION(BlueprintCallable, Category = "Gameplay")
    void StartGame();

    UFUNCTION(BlueprintCallable, Category = "Gameplay")
    void EndGame();

    UFUNCTION(BlueprintImplementableEvent, Category = "Gameplay")
    void OnGameStarted();

    UFUNCTION(BlueprintImplementableEvent, Category = "Gameplay")
    void OnGameEnded();

private:
    FTimerHandle GameTimerHandle;
    void UpdateGameTime();
};
```

### 3. ä¿å­˜ç³»ç»Ÿ

UE5æä¾›äº†å®Œæ•´çš„æ¸¸æˆå­˜æ¡£ç³»ç»Ÿã€‚

#### ä¿å­˜æ¸¸æˆæ•°æ®
```cpp
UCLASS(BlueprintType, Blueprintable)
class MYGAME_API UGameSaveData : public USaveGame
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Save Data")
    FString PlayerName;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Save Data")
    float PlayerHealth;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Save Data")
    int32 PlayerLevel;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Save Data")
    FVector PlayerLocation;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Save Data")
    TArray<FString> UnlockedItems;
};

// ä¿å­˜å’ŒåŠ è½½å‡½æ•°
UFUNCTION(BlueprintCallable, Category = "Save System")
void SaveGameData(const FString& SlotName);

UFUNCTION(BlueprintCallable, Category = "Save System")
void LoadGameData(const FString& SlotName);

UFUNCTION(BlueprintCallable, Category = "Save System")
bool DoesSaveExist(const FString& SlotName);
```

## æ€§èƒ½ä¼˜åŒ–

### 1. æ¸²æŸ“ä¼˜åŒ–

#### LODç³»ç»Ÿ
```cpp
// é…ç½®LODè®¾ç½®
void AMyActor::ConfigureLOD()
{
    UStaticMeshComponent* MeshComp = GetStaticMeshComponent();
    if (MeshComp && MeshComp->GetStaticMesh())
    {
        UStaticMesh* Mesh = MeshComp->GetStaticMesh();

        // è®¾ç½®LODç»„
        Mesh->LODGroup = NAME_None;

        // é…ç½®LODè·ç¦»
        for (int32 LODIndex = 0; LODIndex < Mesh->GetNumLODLevels(); LODIndex++)
        {
            FMeshReductionSettings& ReductionSettings = Mesh->LODGroup;
            ReductionSettings.PercentTriangles = FMath::Pow(0.5f, LODIndex);
        }
    }
}
```

#### é®æŒ¡å‰”é™¤
```cpp
// å¯ç”¨é®æŒ¡å‰”é™¤
void AMyActor::EnableOcclusionCulling()
{
    UStaticMeshComponent* MeshComp = GetStaticMeshComponent();
    if (MeshComp)
    {
        MeshComp->SetVisibility(true);
        MeshComp->SetHiddenInGame(false);
        MeshComp->SetCullDistance(5000.0f); // è®¾ç½®å‰”é™¤è·ç¦»
    }
}
```

### 2. å†…å­˜ä¼˜åŒ–

#### å¯¹è±¡æ± 
```cpp
UCLASS()
class MYGAME_API UObjectPool : public UObject
{
    GENERATED_BODY()

public:
    template<typename T>
    T* GetObject();

    template<typename T>
    void ReturnObject(T* Object);

private:
    UPROPERTY()
    TArray<UObject*> PooledObjects;

    UPROPERTY()
    TSubclassOf<UObject> ObjectClass;
};

template<typename T>
T* UObjectPool::GetObject()
{
    if (PooledObjects.Num() > 0)
    {
        UObject* Object = PooledObjects.Pop();
        return Cast<T>(Object);
    }

    return NewObject<T>();
}

template<typename T>
void UObjectPool::ReturnObject(T* Object)
{
    if (Object)
    {
        PooledObjects.Add(Object);
    }
}
```

## è°ƒè¯•å’Œæµ‹è¯•

### 1. è°ƒè¯•å·¥å…·

#### æ—¥å¿—ç³»ç»Ÿ
```cpp
// ä½¿ç”¨UE_LOGè¿›è¡Œè°ƒè¯•
void AMyActor::DebugFunction()
{
    UE_LOG(LogTemp, Log, TEXT("Debug message: %s"), *GetName());
    UE_LOG(LogTemp, Warning, TEXT("Warning message"));
    UE_LOG(LogTemp, Error, TEXT("Error message"));

    // æ¡ä»¶æ—¥å¿—
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, TEXT("On-screen debug message"));
    }
}
```

#### å¯è§†åŒ–è°ƒè¯•
```cpp
// ç»˜åˆ¶è°ƒè¯•ä¿¡æ¯
void AMyActor::DrawDebugInfo()
{
    if (GEngine)
    {
        // ç»˜åˆ¶çº¿æ¡
        DrawDebugLine(GetWorld(), GetActorLocation(), GetActorLocation() + FVector(0, 0, 100),
                     FColor::Red, false, 5.0f);

        // ç»˜åˆ¶çƒä½“
        DrawDebugSphere(GetWorld(), GetActorLocation(), 50.0f, 12, FColor::Blue, false, 5.0f);

        // ç»˜åˆ¶æ–‡æœ¬
        DrawDebugString(GetWorld(), GetActorLocation(), TEXT("Debug Text"), nullptr,
                       FColor::White, 5.0f);
    }
}
```

### 2. è‡ªåŠ¨åŒ–æµ‹è¯•

#### å•å…ƒæµ‹è¯•
```cpp
IMPLEMENT_SIMPLE_AUTOMATION_TEST(FMyGameTest, "MyGame.BasicTest",
                                EAutomationTestFlags::ApplicationContextMask |
                                EAutomationTestFlags::ProductFilter)

bool FMyGameTest::RunTest(const FString& Parameters)
{
    // æµ‹è¯•ç”¨ä¾‹
    TestTrue("Basic test", true);
    TestEqual("Number test", 1 + 1, 2);
    TestNotEqual("Inequality test", 1, 2);

    return true;
}
```

## å‘å¸ƒå’Œéƒ¨ç½²

### 1. æ‰“åŒ…é…ç½®

#### é¡¹ç›®è®¾ç½®
```ini
; DefaultEngine.ini
[/Script/Engine.RendererSettings]
r.DefaultFeature.AutoExposure=False
r.DefaultFeature.AutoExposure.Method=0
r.DefaultFeature.AutoExposure.ExtendDefaultLuminanceRange=False

[/Script/Engine.PhysicsSettings]
DefaultGravityZ=-980.000000
DefaultTerminalVelocity=4000.000000
DefaultFluidFriction=0.300000
SimulateScratchMemorySize=262144
RagdollAggregateThreshold=4
TriangleMeshTriangleMinAreaThreshold=5.000000
bEnableShapeSharing=False
bEnablePCM=True
bEnableStabilization=False
bWarnMissingLocks=True
bEnable2DPhysics=False
PhysXErrorHandler=GEngine
LockedAxis=Invalid
DefaultDegreesOfFreedom=Full3D
bSimulateSkeletalMeshOnDedicatedServer=True
MaxPhysicsDeltaTime=0.033333
bSubstepping=False
bSubsteppingAsync=False
MaxSubstepDeltaTime=0.016667
MaxSubsteps=6
SyncSceneSmoothingFactor=0.000000
InitialAverageFrameRate=0.016667
PhysXTreeRebuildRate=10
```

### 2. æ€§èƒ½åˆ†æ

#### æ€§èƒ½ç›‘æ§
```cpp
// æ€§èƒ½ç»Ÿè®¡
void AMyActor::LogPerformanceStats()
{
    // å¸§ç‡ç»Ÿè®¡
    float FrameRate = 1.0f / FApp::GetDeltaTime();
    UE_LOG(LogTemp, Log, TEXT("Frame Rate: %.2f FPS"), FrameRate);

    // å†…å­˜ä½¿ç”¨
    FPlatformMemoryStats MemoryStats = FPlatformMemory::GetStats();
    UE_LOG(LogTemp, Log, TEXT("Memory Used: %d MB"), MemoryStats.UsedPhysical / (1024 * 1024));

    // GPUç»Ÿè®¡
    if (GEngine && GEngine->GetRenderDevice())
    {
        // GPUç›¸å…³ç»Ÿè®¡ä¿¡æ¯
    }
}
```

## æ€»ç»“

UE5ä¸ºæ¸¸æˆå¼€å‘å¸¦æ¥äº†é©å‘½æ€§çš„æŠ€æœ¯é©æ–°ï¼Œé€šè¿‡åˆç†è¿ç”¨å…¶æ ¸å¿ƒåŠŸèƒ½ï¼Œå¼€å‘è€…å¯ä»¥åˆ›å»ºå‡ºé«˜è´¨é‡çš„æ¸¸æˆä½œå“ã€‚ä»è“å›¾ç¼–ç¨‹åˆ°C++å¼€å‘ï¼Œä»æ€§èƒ½ä¼˜åŒ–åˆ°å‘å¸ƒéƒ¨ç½²ï¼Œæ¯ä¸ªç¯èŠ‚éƒ½éœ€è¦æ·±å…¥ç†è§£å’Œç²¾å¿ƒè®¾è®¡ã€‚

éšç€æŠ€æœ¯çš„ä¸æ–­å‘å±•ï¼ŒUE5å°†ç»§ç»­ä¸ºæ¸¸æˆå¼€å‘æä¾›æ›´å¼ºå¤§çš„å·¥å…·å’Œæ›´ä¼˜ç§€çš„æ€§èƒ½è¡¨ç°ã€‚

---

*æ ‡ç­¾ï¼šUE5, æ¸¸æˆå¼€å‘, è“å›¾ç¼–ç¨‹, C++, Nanite, Lumen, æ€§èƒ½ä¼˜åŒ–*
8:T6e44,
# ğŸ® Unityæ¸¸æˆç‰©ç†ç³»ç»Ÿå®æˆ˜æŒ‡å—

## é¡¹ç›®èƒŒæ™¯ï¼šæˆ‘çš„ç¬¬ä¸€ä¸ª3Dæ¸¸æˆ

è¿™æ˜¯ä¸€ä¸ªå…³äºå¤ªç©ºæ¢é™©çš„æ¸¸æˆé¡¹ç›®ï¼Œç©å®¶éœ€è¦æ§åˆ¶ä¸€ä¸ªæœºå™¨äººåœ¨ä¸åŒçš„æ˜Ÿçƒä¸Šæ¢ç´¢ã€æ”¶é›†èµ„æºã€ä¸æ•Œäººæˆ˜æ–—ã€‚

**æ¸¸æˆç‰¹è‰²**ï¼š
- çœŸå®çš„ç‰©ç†äº¤äº’
- æµç•…çš„è§’è‰²æ§åˆ¶
- ä¸°å¯Œçš„ç¯å¢ƒæ•ˆæœ
- æ™ºèƒ½çš„AIç³»ç»Ÿ

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š
- å¤æ‚çš„ç‰©ç†ç³»ç»Ÿ
- æµç•…çš„åŠ¨ç”»è¿‡æ¸¡
- å®æ—¶çš„ç¯å¢ƒäº¤äº’
- ä¼˜åŒ–çš„æ€§èƒ½è¡¨ç°

## æ ¸å¿ƒç³»ç»Ÿè®¾è®¡ï¼šä»éœ€æ±‚åˆ°å®ç°

### éœ€æ±‚åˆ†æï¼šç©å®¶ä½“éªŒä¼˜å…ˆ

**ç©å®¶åé¦ˆ**ï¼š
- "è§’è‰²ç§»åŠ¨æ„Ÿè§‰ä¸å¤ŸçœŸå®"
- "è·³è·ƒæ‰‹æ„Ÿå¤ªç”Ÿç¡¬"
- "ä¸ç‰©ä½“äº¤äº’ä¸å¤Ÿè‡ªç„¶"
- "ç¯å¢ƒæ•ˆæœç¼ºä¹æ²‰æµ¸æ„Ÿ"

**æŠ€æœ¯ç›®æ ‡**ï¼š
- å®ç°çœŸå®çš„ç‰©ç†åé¦ˆ
- æä¾›æµç•…çš„æ“ä½œä½“éªŒ
- åˆ›é€ ä¸°å¯Œçš„äº¤äº’æ•ˆæœ
- ä¿æŒç¨³å®šçš„æ€§èƒ½è¡¨ç°

### æ¶æ„è®¾è®¡ï¼šæ¨¡å—åŒ–æ€ç»´

**ç³»ç»Ÿæ¶æ„**ï¼š
```
æ¸¸æˆç‰©ç†ç³»ç»Ÿ
â”œâ”€â”€ è§’è‰²æ§åˆ¶ç³»ç»Ÿ
â”‚   â”œâ”€â”€ ç§»åŠ¨æ§åˆ¶å™¨
â”‚   â”œâ”€â”€ è·³è·ƒç³»ç»Ÿ
â”‚   â””â”€â”€ åŠ¨ç”»ç®¡ç†å™¨
â”œâ”€â”€ äº¤äº’ç³»ç»Ÿ
â”‚   â”œâ”€â”€ æ‹¾å–ç³»ç»Ÿ
â”‚   â”œâ”€â”€ æŠ•æ·ç³»ç»Ÿ
â”‚   â””â”€â”€ ç¢°æ’æ£€æµ‹
â”œâ”€â”€ ç¯å¢ƒç³»ç»Ÿ
â”‚   â”œâ”€â”€ ç‰©ç†æè´¨
â”‚   â”œâ”€â”€ ç²’å­æ•ˆæœ
â”‚   â””â”€â”€ å£°éŸ³ç³»ç»Ÿ
â””â”€â”€ ä¼˜åŒ–ç³»ç»Ÿ
    â”œâ”€â”€ æ€§èƒ½ç›‘æ§
    â”œâ”€â”€ å†…å­˜ç®¡ç†
    â””â”€â”€ æ¸²æŸ“ä¼˜åŒ–
```

## è§’è‰²æ§åˆ¶ç³»ç»Ÿï¼šä»åŸºç¡€åˆ°é«˜çº§

### åŸºç¡€ç§»åŠ¨æ§åˆ¶å™¨

**è®¾è®¡æ€è·¯**ï¼šä½¿ç”¨Rigidbodyå®ç°çœŸå®çš„ç‰©ç†ç§»åŠ¨

```csharp
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    [Header("ç§»åŠ¨å‚æ•°")]
    public float moveSpeed = 5f;
    public float acceleration = 10f;
    public float deceleration = 15f;
    public float airControl = 0.3f;

    [Header("è·³è·ƒå‚æ•°")]
    public float jumpForce = 8f;
    public float jumpCooldown = 0.1f;
    public int maxJumpCount = 2;

    [Header("åœ°é¢æ£€æµ‹")]
    public float groundCheckDistance = 0.1f;
    public LayerMask groundLayer = 1;

    private Rigidbody rb;
    private bool isGrounded;
    private int jumpCount;
    private float lastJumpTime;
    private Vector3 moveInput;
    private bool jumpInput;

    void Start()
    {
        rb = GetComponent<Rigidbody>();
        ConfigureRigidbody();
    }

    void Update()
    {
        GetInput();
        CheckGrounded();
        HandleJumpInput();
    }

    void FixedUpdate()
    {
        HandleMovement();
        ApplyAirControl();
    }

    private void ConfigureRigidbody()
    {
        rb.mass = 1f;
        rb.drag = 0f;
        rb.angularDrag = 0.05f;
        rb.constraints = RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ;
    }

    private void GetInput()
    {
        moveInput = new Vector3(Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical"));
        jumpInput = Input.GetButtonDown("Jump");
    }

    private void CheckGrounded()
    {
        isGrounded = Physics.Raycast(transform.position, Vector3.down, groundCheckDistance, groundLayer);

        if (isGrounded && rb.velocity.y <= 0)
        {
            jumpCount = 0;
        }
    }

    private void HandleJumpInput()
    {
        if (jumpInput && CanJump())
        {
            Jump();
        }
    }

    private bool CanJump()
    {
        return (isGrounded || jumpCount < maxJumpCount) &&
               Time.time - lastJumpTime > jumpCooldown;
    }

    private void Jump()
    {
        rb.velocity = new Vector3(rb.velocity.x, jumpForce, rb.velocity.z);
        jumpCount++;
        lastJumpTime = Time.time;
    }

    private void HandleMovement()
    {
        if (isGrounded)
        {
            // åœ°é¢ç§»åŠ¨ï¼šä½¿ç”¨åŠ›æ¥ç§»åŠ¨
            Vector3 targetVelocity = moveInput * moveSpeed;
            Vector3 velocityChange = targetVelocity - new Vector3(rb.velocity.x, 0, rb.velocity.z);

            if (moveInput.magnitude > 0.1f)
            {
                rb.AddForce(velocityChange * acceleration, ForceMode.Acceleration);
            }
            else
            {
                rb.AddForce(velocityChange * deceleration, ForceMode.Acceleration);
            }
        }
    }

    private void ApplyAirControl()
    {
        if (!isGrounded && moveInput.magnitude > 0.1f)
        {
            // ç©ºä¸­æ§åˆ¶ï¼šé™åˆ¶åœ¨ç©ºä¸­æ—¶çš„ç§»åŠ¨èƒ½åŠ›
            Vector3 airForce = moveInput * moveSpeed * airControl;
            rb.AddForce(airForce, ForceMode.Acceleration);
        }
    }
}
```

### é«˜çº§ç§»åŠ¨ç³»ç»Ÿ

**è®¾è®¡æ€è·¯**ï¼šæ·»åŠ æ›´å¤šç§»åŠ¨èƒ½åŠ›ï¼Œæå‡æ¸¸æˆä½“éªŒ

```csharp
public class AdvancedPlayerController : PlayerController
{
    [Header("å†²åˆºç³»ç»Ÿ")]
    public float sprintSpeed = 8f;
    public float sprintStaminaCost = 10f;
    public float staminaRegenRate = 5f;
    public float maxStamina = 100f;

    [Header("æ»‘è¡Œç³»ç»Ÿ")]
    public float slideSpeed = 12f;
    public float slideDuration = 1f;
    public float slideCooldown = 2f;

    [Header("æ”€çˆ¬ç³»ç»Ÿ")]
    public float climbSpeed = 3f;
    public float climbCheckDistance = 1f;
    public LayerMask climbableLayer;

    private float currentStamina;
    private bool isSprinting;
    private bool isSliding;
    private bool canSlide = true;
    private float slideTimer;
    private bool isClimbing;

    void Start()
    {
        base.Start();
        currentStamina = maxStamina;
    }

    void Update()
    {
        base.Update();
        HandleAdvancedInput();
        UpdateStamina();
        HandleSliding();
        HandleClimbing();
    }

    private void HandleAdvancedInput()
    {
        // å†²åˆºè¾“å…¥
        if (Input.GetKey(KeyCode.LeftShift) && currentStamina > 0 && moveInput.magnitude > 0.1f)
        {
            isSprinting = true;
        }
        else
        {
            isSprinting = false;
        }

        // æ»‘è¡Œè¾“å…¥
        if (Input.GetKeyDown(KeyCode.C) && isGrounded && canSlide && moveInput.magnitude > 0.1f)
        {
            StartSlide();
        }
    }

    private void UpdateStamina()
    {
        if (isSprinting)
        {
            currentStamina -= sprintStaminaCost * Time.deltaTime;
        }
        else
        {
            currentStamina += staminaRegenRate * Time.deltaTime;
        }

        currentStamina = Mathf.Clamp(currentStamina, 0, maxStamina);
    }

    private void StartSlide()
    {
        isSliding = true;
        canSlide = false;
        slideTimer = slideDuration;

        // é™ä½ç¢°æ’å™¨é«˜åº¦
        GetComponent<CapsuleCollider>().height *= 0.5f;
        GetComponent<CapsuleCollider>().center = new Vector3(0, -0.25f, 0);
    }

    private void HandleSliding()
    {
        if (isSliding)
        {
            slideTimer -= Time.deltaTime;

            if (slideTimer <= 0)
            {
                EndSlide();
            }
            else
            {
                // æ»‘è¡Œç§»åŠ¨
                Vector3 slideDirection = transform.forward;
                rb.velocity = new Vector3(slideDirection.x * slideSpeed, rb.velocity.y, slideDirection.z * slideSpeed);
            }
        }
    }

    private void EndSlide()
    {
        isSliding = false;

        // æ¢å¤ç¢°æ’å™¨
        GetComponent<CapsuleCollider>().height *= 2f;
        GetComponent<CapsuleCollider>().center = Vector3.zero;

        // å¯åŠ¨æ»‘è¡Œå†·å´
        StartCoroutine(SlideCooldown());
    }

    private IEnumerator SlideCooldown()
    {
        yield return new WaitForSeconds(slideCooldown);
        canSlide = true;
    }

    private void HandleClimbing()
    {
        // æ£€æµ‹å¯æ”€çˆ¬ç‰©ä½“
        RaycastHit hit;
        if (Physics.Raycast(transform.position, transform.forward, out hit, climbCheckDistance, climbableLayer))
        {
            if (Input.GetKey(KeyCode.E))
            {
                isClimbing = true;
                Climb(hit);
            }
        }
        else
        {
            isClimbing = false;
        }
    }

    private void Climb(RaycastHit hit)
    {
        // è®¡ç®—æ”€çˆ¬æ–¹å‘
        Vector3 climbDirection = hit.normal;
        Vector3 climbVelocity = climbDirection * climbSpeed;

        // åº”ç”¨æ”€çˆ¬åŠ›
        rb.velocity = new Vector3(climbVelocity.x, climbSpeed, climbVelocity.z);
    }

    protected override void HandleMovement()
    {
        if (isClimbing)
        {
            return; // æ”€çˆ¬æ—¶ç¦ç”¨æ™®é€šç§»åŠ¨
        }

        base.HandleMovement();

        // åº”ç”¨å†²åˆºé€Ÿåº¦
        if (isSprinting && currentStamina > 0)
        {
            moveSpeed = sprintSpeed;
        }
        else
        {
            moveSpeed = 5f; // åŸºç¡€é€Ÿåº¦
        }
    }
}
```

## äº¤äº’ç³»ç»Ÿï¼šä»æ‹¾å–åˆ°æŠ•æ·

### æ‹¾å–ç³»ç»Ÿ

**è®¾è®¡æ€è·¯**ï¼šå®ç°è‡ªç„¶çš„ç‰©ä½“æ‹¾å–å’Œæºå¸¦

```csharp
public class PickupSystem : MonoBehaviour
{
    [Header("æ‹¾å–å‚æ•°")]
    public float pickupRange = 3f;
    public float pickupForce = 10f;
    public Transform holdPoint;
    public LayerMask pickupLayer;

    [Header("ç‰©ç†å‚æ•°")]
    public float holdDistance = 2f;
    public float holdSpring = 100f;
    public float holdDamping = 10f;

    private GameObject heldObject;
    private Rigidbody heldRigidbody;
    private Collider heldCollider;
    private bool isHolding;

    void Update()
    {
        HandlePickupInput();
        UpdateHeldObject();
    }

    private void HandlePickupInput()
    {
        if (Input.GetKeyDown(KeyCode.F))
        {
            if (isHolding)
            {
                DropObject();
            }
            else
            {
                TryPickupObject();
            }
        }

        if (Input.GetKeyDown(KeyCode.G) && isHolding)
        {
            ThrowObject();
        }
    }

    private void TryPickupObject()
    {
        RaycastHit hit;
        if (Physics.Raycast(transform.position, transform.forward, out hit, pickupRange, pickupLayer))
        {
            PickupObject(hit.collider.gameObject);
        }
    }

    private void PickupObject(GameObject obj)
    {
        heldObject = obj;
        heldRigidbody = obj.GetComponent<Rigidbody>();
        heldCollider = obj.GetComponent<Collider>();

        if (heldRigidbody != null)
        {
            // é…ç½®åˆšä½“
            heldRigidbody.useGravity = false;
            heldRigidbody.drag = 10f;
            heldRigidbody.angularDrag = 10f;

            // é…ç½®ç¢°æ’å™¨
            if (heldCollider != null)
            {
                heldCollider.isTrigger = true;
            }

            isHolding = true;
        }
    }

    private void UpdateHeldObject()
    {
        if (isHolding && heldObject != null)
        {
            // è®¡ç®—ç›®æ ‡ä½ç½®
            Vector3 targetPosition = holdPoint.position + transform.forward * holdDistance;

            // åº”ç”¨å¼¹ç°§åŠ›
            Vector3 displacement = targetPosition - heldObject.transform.position;
            Vector3 springForce = displacement * holdSpring;
            Vector3 dampingForce = -heldRigidbody.velocity * holdDamping;

            heldRigidbody.AddForce(springForce + dampingForce);

            // å¹³æ»‘æ—‹è½¬
            Quaternion targetRotation = holdPoint.rotation;
            heldObject.transform.rotation = Quaternion.Slerp(heldObject.transform.rotation, targetRotation, Time.deltaTime * 5f);
        }
    }

    private void DropObject()
    {
        if (heldRigidbody != null)
        {
            heldRigidbody.useGravity = true;
            heldRigidbody.drag = 0f;
            heldRigidbody.angularDrag = 0.05f;
        }

        if (heldCollider != null)
        {
            heldCollider.isTrigger = false;
        }

        heldObject = null;
        heldRigidbody = null;
        heldCollider = null;
        isHolding = false;
    }

    private void ThrowObject()
    {
        if (heldRigidbody != null)
        {
            // è®¡ç®—æŠ•æ·åŠ›
            Vector3 throwDirection = transform.forward + transform.up * 0.5f;
            Vector3 throwForce = throwDirection * pickupForce;

            heldRigidbody.AddForce(throwForce, ForceMode.Impulse);
        }

        DropObject();
    }
}
```

### æŠ•æ·ç³»ç»Ÿ

**è®¾è®¡æ€è·¯**ï¼šå®ç°ç²¾ç¡®çš„æŠ•æ·æœºåˆ¶

```csharp
public class ThrowSystem : MonoBehaviour
{
    [Header("æŠ•æ·å‚æ•°")]
    public float throwForce = 15f;
    public float maxThrowDistance = 20f;
    public float throwArc = 45f;
    public LayerMask throwableLayer;

    [Header("è½¨è¿¹é¢„æµ‹")]
    public int trajectoryPoints = 20;
    public float trajectoryTimeStep = 0.1f;
    public LineRenderer trajectoryLine;

    private Vector3 throwStartPosition;
    private bool isAiming;

    void Start()
    {
        if (trajectoryLine != null)
        {
            trajectoryLine.positionCount = trajectoryPoints;
        }
    }

    void Update()
    {
        HandleThrowInput();
        UpdateTrajectory();
    }

    private void HandleThrowInput()
    {
        if (Input.GetMouseButtonDown(1)) // å³é”®ç„å‡†
        {
            StartAiming();
        }
        else if (Input.GetMouseButtonUp(1))
        {
            EndAiming();
        }

        if (Input.GetMouseButtonDown(0) && isAiming) // å·¦é”®æŠ•æ·
        {
            Throw();
        }
    }

    private void StartAiming()
    {
        isAiming = true;
        throwStartPosition = transform.position;

        if (trajectoryLine != null)
        {
            trajectoryLine.enabled = true;
        }
    }

    private void EndAiming()
    {
        isAiming = false;

        if (trajectoryLine != null)
        {
            trajectoryLine.enabled = false;
        }
    }

    private void UpdateTrajectory()
    {
        if (!isAiming || trajectoryLine == null)
            return;

        Vector3[] trajectory = CalculateTrajectory();
        trajectoryLine.SetPositions(trajectory);
    }

    private Vector3[] CalculateTrajectory()
    {
        Vector3[] points = new Vector3[trajectoryPoints];
        Vector3 velocity = CalculateThrowVelocity();

        for (int i = 0; i < trajectoryPoints; i++)
        {
            float time = i * trajectoryTimeStep;
            points[i] = throwStartPosition + velocity * time + 0.5f * Physics.gravity * time * time;
        }

        return points;
    }

    private Vector3 CalculateThrowVelocity()
    {
        // è·å–é¼ æ ‡ä½ç½®
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        Plane plane = new Plane(Vector3.up, throwStartPosition);

        if (plane.Raycast(ray, out float distance))
        {
            Vector3 targetPoint = ray.GetPoint(distance);
            Vector3 direction = (targetPoint - throwStartPosition).normalized;

            // é™åˆ¶æŠ•æ·è·ç¦»
            float throwDistance = Mathf.Min(Vector3.Distance(throwStartPosition, targetPoint), maxThrowDistance);

            // è®¡ç®—æŠ•æ·é€Ÿåº¦
            float angle = throwArc * Mathf.Deg2Rad;
            float velocity = Mathf.Sqrt(throwDistance * Physics.gravity.magnitude / Mathf.Sin(2 * angle));

            return direction * velocity;
        }

        return transform.forward * throwForce;
    }

    private void Throw()
    {
        Vector3 velocity = CalculateThrowVelocity();

        // åˆ›å»ºæŠ•æ·ç‰©
        GameObject throwable = CreateThrowable();
        if (throwable != null)
        {
            Rigidbody rb = throwable.GetComponent<Rigidbody>();
            if (rb != null)
            {
                rb.velocity = velocity;
            }
        }

        EndAiming();
    }

    private GameObject CreateThrowable()
    {
        // è¿™é‡Œå¯ä»¥å®ä¾‹åŒ–æŠ•æ·ç‰©é¢„åˆ¶ä½“
        // æˆ–è€…ä½¿ç”¨å½“å‰æŒæœ‰çš„ç‰©ä½“
        return null;
    }
}
```

## ç¯å¢ƒç³»ç»Ÿï¼šä»æè´¨åˆ°æ•ˆæœ

### ç‰©ç†æè´¨ç³»ç»Ÿ

**è®¾è®¡æ€è·¯**ï¼šåˆ›å»ºä¸åŒæè´¨çš„ç‰©ç†ç‰¹æ€§

```csharp
[System.Serializable]
public class PhysicsMaterial
{
    public string materialName;
    public float friction = 0.6f;
    public float bounciness = 0.0f;
    public AudioClip impactSound;
    public GameObject impactEffect;
    public float impactForce = 1f;
}

public class PhysicsMaterialManager : MonoBehaviour
{
    [Header("æè´¨é…ç½®")]
    public PhysicsMaterial[] materials;

    [Header("æ•ˆæœé…ç½®")]
    public AudioSource audioSource;
    public Transform effectParent;

    private Dictionary<string, PhysicsMaterial> materialDict;

    void Start()
    {
        InitializeMaterialDictionary();
    }

    private void InitializeMaterialDictionary()
    {
        materialDict = new Dictionary<string, PhysicsMaterial>();
        foreach (var material in materials)
        {
            materialDict[material.materialName] = material;
        }
    }

    public void HandleCollision(Collision collision, string materialName)
    {
        if (materialDict.TryGetValue(materialName, out PhysicsMaterial material))
        {
            // æ’­æ”¾ç¢°æ’éŸ³æ•ˆ
            if (material.impactSound != null && audioSource != null)
            {
                audioSource.PlayOneShot(material.impactSound);
            }

            // ç”Ÿæˆç¢°æ’æ•ˆæœ
            if (material.impactEffect != null)
            {
                Vector3 impactPoint = collision.contacts[0].point;
                Vector3 impactNormal = collision.contacts[0].normal;

                GameObject effect = Instantiate(material.impactEffect, impactPoint, Quaternion.LookRotation(impactNormal));
                if (effectParent != null)
                {
                    effect.transform.SetParent(effectParent);
                }

                Destroy(effect, 3f);
            }
        }
    }
}
```

### ç²’å­æ•ˆæœç³»ç»Ÿ

**è®¾è®¡æ€è·¯**ï¼šåˆ›å»ºä¸°å¯Œçš„ç¯å¢ƒç²’å­æ•ˆæœ

```csharp
public class ParticleEffectManager : MonoBehaviour
{
    [Header("ç¯å¢ƒæ•ˆæœ")]
    public ParticleSystem dustEffect;
    public ParticleSystem sparkEffect;
    public ParticleSystem smokeEffect;

    [Header("äº¤äº’æ•ˆæœ")]
    public ParticleSystem pickupEffect;
    public ParticleSystem throwEffect;
    public ParticleSystem impactEffect;

    [Header("é…ç½®å‚æ•°")]
    public float dustEmissionRate = 10f;
    public float sparkEmissionRate = 5f;
    public float smokeEmissionRate = 3f;

    private PlayerController playerController;
    private Rigidbody playerRigidbody;

    void Start()
    {
        playerController = GetComponent<PlayerController>();
        playerRigidbody = GetComponent<Rigidbody>();

        ConfigureParticleSystems();
    }

    void Update()
    {
        UpdateDustEffect();
        UpdateSparkEffect();
    }

    private void ConfigureParticleSystems()
    {
        // é…ç½®ç°å°˜æ•ˆæœ
        if (dustEffect != null)
        {
            var emission = dustEffect.emission;
            emission.rateOverTime = dustEmissionRate;
        }

        // é…ç½®ç«èŠ±æ•ˆæœ
        if (sparkEffect != null)
        {
            var emission = sparkEffect.emission;
            emission.rateOverTime = sparkEmissionRate;
        }

        // é…ç½®çƒŸé›¾æ•ˆæœ
        if (smokeEffect != null)
        {
            var emission = smokeEffect.emission;
            emission.rateOverTime = smokeEmissionRate;
        }
    }

    private void UpdateDustEffect()
    {
        if (dustEffect != null && playerController != null)
        {
            // æ ¹æ®ç§»åŠ¨é€Ÿåº¦è°ƒæ•´ç°å°˜æ•ˆæœ
            float speed = playerRigidbody.velocity.magnitude;
            var emission = dustEffect.emission;

            if (speed > 0.1f && playerController.IsGrounded)
            {
                emission.rateOverTime = dustEmissionRate * (speed / 5f);
                dustEffect.Play();
            }
            else
            {
                emission.rateOverTime = 0;
                dustEffect.Stop();
            }
        }
    }

    private void UpdateSparkEffect()
    {
        if (sparkEffect != null)
        {
            // æ ¹æ®ç¢°æ’å¼ºåº¦è°ƒæ•´ç«èŠ±æ•ˆæœ
            // è¿™é‡Œå¯ä»¥é€šè¿‡ç›‘å¬ç¢°æ’äº‹ä»¶æ¥å®ç°
        }
    }

    public void PlayPickupEffect(Vector3 position)
    {
        if (pickupEffect != null)
        {
            pickupEffect.transform.position = position;
            pickupEffect.Play();
        }
    }

    public void PlayThrowEffect(Vector3 position, Vector3 direction)
    {
        if (throwEffect != null)
        {
            throwEffect.transform.position = position;
            throwEffect.transform.rotation = Quaternion.LookRotation(direction);
            throwEffect.Play();
        }
    }

    public void PlayImpactEffect(Vector3 position, Vector3 normal)
    {
        if (impactEffect != null)
        {
            impactEffect.transform.position = position;
            impactEffect.transform.rotation = Quaternion.LookRotation(normal);
            impactEffect.Play();
        }
    }
}
```

## ä¼˜åŒ–ç³»ç»Ÿï¼šä»æ€§èƒ½åˆ°ä½“éªŒ

### æ€§èƒ½ç›‘æ§

**è®¾è®¡æ€è·¯**ï¼šå®æ—¶ç›‘æ§æ¸¸æˆæ€§èƒ½

```csharp
public class PerformanceMonitor : MonoBehaviour
{
    [Header("ç›‘æ§å‚æ•°")]
    public bool enableMonitoring = true;
    public float updateInterval = 0.5f;

    [Header("æ€§èƒ½æŒ‡æ ‡")]
    public float fps;
    public float frameTime;
    public int drawCalls;
    public float memoryUsage;
    public int physicsObjects;

    private float deltaTime = 0.0f;
    private float lastUpdateTime;

    void Update()
    {
        if (!enableMonitoring)
            return;

        UpdatePerformanceMetrics();

        if (Time.time - lastUpdateTime >= updateInterval)
        {
            LogPerformanceData();
            lastUpdateTime = Time.time;
        }
    }

    private void UpdatePerformanceMetrics()
    {
        deltaTime += (Time.unscaledDeltaTime - deltaTime) * 0.1f;
        fps = 1.0f / deltaTime;
        frameTime = deltaTime * 1000f;

        drawCalls = UnityStats.drawCalls;
        memoryUsage = System.GC.GetTotalMemory(false) / 1024f / 1024f; // MB
        physicsObjects = FindObjectsOfType<Rigidbody>().Length;
    }

    private void LogPerformanceData()
    {
        Debug.Log($"FPS: {fps:F1}, Frame Time: {frameTime:F1}ms, Draw Calls: {drawCalls}, Memory: {memoryUsage:F1}MB, Physics Objects: {physicsObjects}");
    }

    void OnGUI()
    {
        if (!enableMonitoring)
            return;

        GUILayout.BeginArea(new Rect(10, 10, 200, 100));
        GUILayout.Label($"FPS: {fps:F1}");
        GUILayout.Label($"Frame Time: {frameTime:F1}ms");
        GUILayout.Label($"Draw Calls: {drawCalls}");
        GUILayout.Label($"Memory: {memoryUsage:F1}MB");
        GUILayout.Label($"Physics Objects: {physicsObjects}");
        GUILayout.EndArea();
    }
}
```

### å†…å­˜ç®¡ç†

**è®¾è®¡æ€è·¯**ï¼šä¼˜åŒ–å†…å­˜ä½¿ç”¨

```csharp
public class MemoryManager : MonoBehaviour
{
    [Header("å†…å­˜é…ç½®")]
    public float maxMemoryUsage = 1024f; // MB
    public float cleanupThreshold = 0.8f; // 80%
    public float cleanupInterval = 30f; // 30ç§’

    private float lastCleanupTime;
    private List<GameObject> pooledObjects = new List<GameObject>();

    void Update()
    {
        if (Time.time - lastCleanupTime >= cleanupInterval)
        {
            CheckMemoryUsage();
            lastCleanupTime = Time.time;
        }
    }

    private void CheckMemoryUsage()
    {
        float currentMemory = System.GC.GetTotalMemory(false) / 1024f / 1024f;

        if (currentMemory > maxMemoryUsage * cleanupThreshold)
        {
            PerformMemoryCleanup();
        }
    }

    private void PerformMemoryCleanup()
    {
        // æ¸…ç†æœªä½¿ç”¨çš„å¯¹è±¡
        Resources.UnloadUnusedAssets();

        // å¼ºåˆ¶åƒåœ¾å›æ”¶
        System.GC.Collect();

        // æ¸…ç†æ± åŒ–å¯¹è±¡
        CleanupPooledObjects();

        Debug.Log("Memory cleanup performed");
    }

    private void CleanupPooledObjects()
    {
        for (int i = pooledObjects.Count - 1; i >= 0; i--)
        {
            if (pooledObjects[i] == null)
            {
                pooledObjects.RemoveAt(i);
            }
        }
    }

    public void AddToPool(GameObject obj)
    {
        if (!pooledObjects.Contains(obj))
        {
            pooledObjects.Add(obj);
        }
    }

    public void RemoveFromPool(GameObject obj)
    {
        pooledObjects.Remove(obj);
    }
}
```

## é¡¹ç›®æ€»ç»“ï¼šä»å¼€å‘åˆ°å‘å¸ƒ

### å¼€å‘æˆæœ

**æŠ€æœ¯æˆæœ**ï¼š
- å®ç°äº†å®Œæ•´çš„ç‰©ç†äº¤äº’ç³»ç»Ÿ
- åˆ›å»ºäº†æµç•…çš„è§’è‰²æ§åˆ¶ç³»ç»Ÿ
- å¼€å‘äº†ä¸°å¯Œçš„ç¯å¢ƒæ•ˆæœ
- å»ºç«‹äº†å®Œå–„çš„ä¼˜åŒ–æœºåˆ¶

**æ€§èƒ½è¡¨ç°**ï¼š
- ç¨³å®š60FPSè¿è¡Œ
- å†…å­˜ä½¿ç”¨æ§åˆ¶åœ¨1GBä»¥å†…
- ç‰©ç†å¯¹è±¡æ•°é‡ä¼˜åŒ–åˆ°100ä¸ªä»¥å†…
- åŠ è½½æ—¶é—´æ§åˆ¶åœ¨3ç§’ä»¥å†…

**ç”¨æˆ·ä½“éªŒ**ï¼š
- ç©å®¶åé¦ˆç§»åŠ¨æ‰‹æ„ŸçœŸå®
- äº¤äº’æ•ˆæœè‡ªç„¶æµç•…
- ç¯å¢ƒæ•ˆæœå¢å¼ºæ²‰æµ¸æ„Ÿ
- æ•´ä½“æ€§èƒ½è¡¨ç°ä¼˜ç§€

### æŠ€æœ¯æ”¶è·

**ç‰©ç†ç³»ç»Ÿ**ï¼š
- æ·±å…¥ç†è§£äº†Unityç‰©ç†å¼•æ“
- æŒæ¡äº†Rigidbodyçš„ä½¿ç”¨æŠ€å·§
- å­¦ä¼šäº†ç‰©ç†æè´¨çš„é…ç½®
- ç†è§£äº†æ€§èƒ½ä¼˜åŒ–çš„æ–¹æ³•

**æ¸¸æˆå¼€å‘**ï¼š
- å­¦ä¼šäº†æ¨¡å—åŒ–è®¾è®¡
- æŒæ¡äº†æ€§èƒ½ç›‘æ§æŠ€æœ¯
- ç†è§£äº†ç”¨æˆ·ä½“éªŒçš„é‡è¦æ€§
- ç§¯ç´¯äº†é¡¹ç›®å¼€å‘ç»éªŒ

**ä»£ç è´¨é‡**ï¼š
- æé«˜äº†ä»£ç ç»„ç»‡èƒ½åŠ›
- å­¦ä¼šäº†è®¾è®¡æ¨¡å¼çš„åº”ç”¨
- æŒæ¡äº†è°ƒè¯•å’Œä¼˜åŒ–æŠ€å·§
- ç†è§£äº†å¯ç»´æŠ¤æ€§çš„é‡è¦æ€§

### æœªæ¥æ”¹è¿›

**æŠ€æœ¯æ”¹è¿›**ï¼š
- æ·»åŠ æ›´å¤šç‰©ç†æ•ˆæœ
- ä¼˜åŒ–æ¸²æŸ“æ€§èƒ½
- å¢å¼ºAIç³»ç»Ÿ
- æ‰©å±•æ¸¸æˆå†…å®¹

**åŠŸèƒ½æ‰©å±•**ï¼š
- å¤šäººæ¸¸æˆæ”¯æŒ
- å…³å¡ç¼–è¾‘å™¨
- æˆå°±ç³»ç»Ÿ
- ç¤¾äº¤åŠŸèƒ½

## å‚è€ƒèµ„æ–™

### Unityå®˜æ–¹æ–‡æ¡£
- [Unity Physics](https://docs.unity3d.com/Manual/PhysicsOverview.html)
- [Rigidbody](https://docs.unity3d.com/ScriptReference/Rigidbody.html)
- [Collider](https://docs.unity3d.com/ScriptReference/Collider.html)
- [Particle System](https://docs.unity3d.com/Manual/ParticleSystem.html)

### å­¦ä¹ èµ„æº
- [Unity Learn](https://learn.unity.com/)
- [Unity Forums](https://forum.unity.com/)
- [Unity Asset Store](https://assetstore.unity.com/)

### æ€§èƒ½ä¼˜åŒ–
- [Unity Performance](https://docs.unity3d.com/Manual/PerformanceOptimization.html)
- [Profiler](https://docs.unity3d.com/Manual/Profiler.html)
- [Memory Management](https://docs.unity3d.com/Manual/PerformanceOptimization.html)

## ç»“è¯­

è¿™ä¸ªUnityæ¸¸æˆç‰©ç†ç³»ç»Ÿé¡¹ç›®è®©æˆ‘æ·±å…¥ç†è§£äº†æ¸¸æˆå¼€å‘çš„æŠ€æœ¯ç»†èŠ‚å’Œè®¾è®¡ç†å¿µã€‚

ä»åŸºç¡€çš„è§’è‰²æ§åˆ¶åˆ°å¤æ‚çš„ç‰©ç†äº¤äº’ï¼Œä»ç®€å•çš„ç²’å­æ•ˆæœåˆ°å®Œæ•´çš„ä¼˜åŒ–ç³»ç»Ÿï¼Œæ¯ä¸€ä¸ªæ¨¡å—éƒ½è®©æˆ‘å¯¹æ¸¸æˆå¼€å‘æœ‰äº†æ›´æ·±çš„è®¤è¯†ã€‚

è™½ç„¶å¼€å‘è¿‡ç¨‹ä¸­é‡åˆ°äº†å¾ˆå¤šæŠ€æœ¯æŒ‘æˆ˜ï¼Œä½†æ¯ä¸€æ¬¡é—®é¢˜çš„è§£å†³éƒ½è®©æˆ‘æˆé•¿ã€‚ç°åœ¨ï¼Œè¿™ä¸ªé¡¹ç›®ä¸ä»…æ˜¯ä¸€ä¸ªæŠ€æœ¯æˆæœï¼Œæ›´æ˜¯æˆ‘æ¸¸æˆå¼€å‘èƒ½åŠ›çš„é‡è¦é‡Œç¨‹ç¢‘ã€‚

è®°ä½ï¼Œæ¸¸æˆå¼€å‘ä¸ä»…ä»…æ˜¯æŠ€æœ¯å®ç°ï¼Œæ›´æ˜¯ç”¨æˆ·ä½“éªŒçš„åˆ›é€ ã€‚å¥½çš„ç‰©ç†ç³»ç»Ÿåº”è¯¥è®©ç©å®¶æ„Ÿè§‰è‡ªç„¶æµç•…ï¼Œè€Œä¸æ˜¯æŠ€æœ¯ç‚«é…·ã€‚

---

> ğŸ’¡ **å®ç”¨å°è´´å£«**ï¼šåœ¨å¼€å‘ç‰©ç†ç³»ç»Ÿæ—¶ï¼Œå§‹ç»ˆä»¥ç”¨æˆ·ä½“éªŒä¸ºä¸­å¿ƒã€‚æŠ€æœ¯å®ç°å¯ä»¥å¤æ‚ï¼Œä½†ç©å®¶æ“ä½œå¿…é¡»ç®€å•ç›´è§‚ã€‚è®°ä½ï¼Œæœ€å¥½çš„ç‰©ç†ç³»ç»Ÿæ˜¯ç©å®¶æ„Ÿè§‰ä¸åˆ°çš„ç‰©ç†ç³»ç»Ÿï¼

*"åœ¨æ¸¸æˆå¼€å‘çš„ä¸–ç•Œé‡Œï¼Œè®©æŠ€æœ¯åºŸæŸ´ä¹Ÿèƒ½æˆä¸ºç‰©ç†ç³»ç»Ÿä¸“å®¶ï¼"* ğŸ®
a:["æ¸¸æˆå¼€å‘","C++","SFML","å›¾å½¢ç¼–ç¨‹","æ¸¸æˆå¼•æ“","æŠ€æœ¯åºŸæŸ´","é¡¹ç›®å®æˆ˜","è·¨ç•Œæ¢ç´¢"]
b:T55c8,
# åå…­ä¸ªç»å…¸C++æ¸¸æˆé¡¹ç›®ï¼šæŠ€æœ¯åºŸæŸ´çš„æ¸¸æˆå¼€å‘å®æˆ˜

> ä»"Hello World"åˆ°å®Œæ•´æ¸¸æˆï¼Œæˆ‘çš„SFMLæ¸¸æˆå¼€å‘é¡¹ç›®é›†

## æˆ‘ä¸æ¸¸æˆå¼€å‘çš„"ç¬¬ä¸€æ¬¡äº²å¯†æ¥è§¦"

### ç¬¬ä¸€ä¸ªæ¸¸æˆï¼šè´ªåƒè›‡çš„"ç¿»è½¦"ç»å†

è¿˜è®°å¾—ç¬¬ä¸€æ¬¡ç”¨SFMLå†™è´ªåƒè›‡æ—¶ï¼Œæˆ‘ä¿¡å¿ƒæ»¡æ»¡åœ°å¼€å§‹ç¼–ç ï¼š

```cpp
// æˆ‘çš„ç¬¬ä¸€ä¸ª"æ°ä½œ"
class Snake {
    std::vector<sf::Vector2f> body;
    sf::Vector2f direction;

public:
    void move() {
        // ç§»åŠ¨è›‡èº«
        for (int i = body.size() - 1; i > 0; i--) {
            body[i] = body[i-1];  // ç»å…¸çš„"ç¿»è½¦"ä»£ç 
        }
        body[0] += direction;
    }
};
```

ç»“æœå‘¢ï¼Ÿè›‡å¤´ç§»åŠ¨äº†ï¼Œä½†è›‡èº«æ²¡æœ‰è·Ÿä¸Šï¼Œæ•´ä¸ªè›‡å°±åƒ"æ–­å¤´è›‡"ä¸€æ ·ã€‚å¯¼å¸ˆçœ‹åˆ°åç›´æ¥ç¬‘å‡ºäº†å£°ï¼š"ä½ è¿™æ˜¯åœ¨åš'è´ªåƒè™«'å—ï¼Ÿ"

### ç¬¬äºŒæ¬¡å°è¯•ï¼šä¿„ç½—æ–¯æ–¹å—çš„"å‡ ä½•å™©æ¢¦"

å¥½ä¸å®¹æ˜“æå®šäº†è´ªåƒè›‡ï¼Œæˆ‘åˆå¼€å§‹æŒ‘æˆ˜ä¿„ç½—æ–¯æ–¹å—ï¼š

```cpp
// æˆ‘çš„"å‡ ä½•å­¦å™©æ¢¦"
class Tetris {
    std::vector<std::vector<int>> board;

public:
    bool isValidMove(const Piece& piece, int x, int y) {
        // å¤æ‚çš„ç¢°æ’æ£€æµ‹é€»è¾‘
        // ç»“æœï¼šæ–¹å—å¯ä»¥ç©¿å¢™è€Œè¿‡
        return true;  // æ°¸è¿œè¿”å›trueï¼Œæ–¹å—æ— æ•Œäº†ï¼
    }
};
```

è¿™æ¬¡æ›´æƒ¨ï¼Œæ–¹å—å¯ä»¥ç©¿å¢™ã€é‡å ã€ç”šè‡³"é£å¤©"ã€‚æˆ‘çš„ä¿„ç½—æ–¯æ–¹å—å˜æˆäº†"ä¿„ç½—æ–¯é­”æ³•æ–¹å—"ã€‚

### è§‰é†’æ—¶åˆ»ï¼šæ¸¸æˆå¼€å‘ä¸æ˜¯å†™ä»£ç ï¼Œæ˜¯åˆ›é€ ä¸–ç•Œ

ç»è¿‡æ— æ•°æ¬¡çš„"ç¿»è½¦"ç»å†ï¼Œæˆ‘ç»ˆäºæ˜ç™½ï¼šæ¸¸æˆå¼€å‘ä¸ä»…ä»…æ˜¯å†™ä»£ç ï¼Œæ›´æ˜¯åˆ›é€ ä¸€ä¸ªå®Œæ•´çš„ä¸–ç•Œã€‚æ¯ä¸€ä¸ªç»†èŠ‚éƒ½éœ€è¦ç²¾å¿ƒè®¾è®¡ï¼Œæ¯ä¸€ä¸ªæœºåˆ¶éƒ½éœ€è¦åå¤æµ‹è¯•ã€‚

## ç»å…¸æ¸¸æˆé¡¹ç›®å®ç°

### 1. è´ªåƒè›‡ï¼šä»"æ–­å¤´è›‡"åˆ°å®Œç¾å®ç°

#### æ ¸å¿ƒæ•°æ®ç»“æ„

```cpp
class Snake {
private:
    std::vector<sf::Vector2f> body;
    sf::Vector2f direction;
    float moveTimer;
    float moveInterval;
    bool growing;

public:
    Snake() : direction(1, 0), moveTimer(0), moveInterval(0.2f), growing(false) {
        // åˆå§‹åŒ–è›‡èº«
        body.push_back(sf::Vector2f(400, 300)); // å¤´éƒ¨
        body.push_back(sf::Vector2f(380, 300)); // èº«ä½“
        body.push_back(sf::Vector2f(360, 300)); // å°¾éƒ¨
    }

    void update(float deltaTime) {
        moveTimer += deltaTime;

        if (moveTimer >= moveInterval) {
            move();
            moveTimer = 0;
        }
    }

    void move() {
        // ä¿å­˜å¤´éƒ¨ä½ç½®
        sf::Vector2f newHead = body[0] + direction * 20.0f;

        // ç§»åŠ¨èº«ä½“ï¼ˆä»å°¾éƒ¨å¼€å§‹ï¼Œé¿å…è¦†ç›–ï¼‰
        for (int i = body.size() - 1; i > 0; --i) {
            body[i] = body[i - 1];
        }

        // è®¾ç½®æ–°çš„å¤´éƒ¨ä½ç½®
        body[0] = newHead;

        // å¦‚æœä¸éœ€è¦ç”Ÿé•¿ï¼Œç§»é™¤å°¾éƒ¨
        if (!growing) {
            body.pop_back();
        } else {
            growing = false;
        }
    }

    void grow() {
        growing = true;
    }

    void setDirection(const sf::Vector2f& newDirection) {
        // é˜²æ­¢åå‘ç§»åŠ¨
        if (direction != -newDirection) {
            direction = newDirection;
        }
    }

    bool checkCollision() {
        // æ£€æŸ¥æ˜¯å¦æ’å¢™
        if (body[0].x < 0 || body[0].x >= 800 ||
            body[0].y < 0 || body[0].y >= 600) {
            return true;
        }

        // æ£€æŸ¥æ˜¯å¦æ’åˆ°è‡ªå·±
        for (size_t i = 1; i < body.size(); ++i) {
            if (body[0] == body[i]) {
                return true;
            }
        }

        return false;
    }

    const std::vector<sf::Vector2f>& getBody() const {
        return body;
    }

    sf::Vector2f getHead() const {
        return body[0];
    }
};
```

#### æ¸¸æˆé€»è¾‘å®ç°

```cpp
class SnakeGame : public GameState {
private:
    Snake snake;
    sf::Vector2f food;
    sf::Font font;
    sf::Text scoreText;
    int score;
    bool gameOver;

public:
    SnakeGame() : score(0), gameOver(false) {
        if (!font.loadFromFile("assets/fonts/arial.ttf")) {
            throw std::runtime_error("Failed to load font");
        }

        scoreText.setFont(font);
        scoreText.setCharacterSize(24);
        scoreText.setPosition(10, 10);
        scoreText.setString("Score: 0");

        spawnFood();
    }

    void handleEvent(const sf::Event& event) override {
        if (event.type == sf::Event::KeyPressed && !gameOver) {
            switch (event.key.code) {
                case sf::Keyboard::Up:
                    snake.setDirection(sf::Vector2f(0, -1));
                    break;
                case sf::Keyboard::Down:
                    snake.setDirection(sf::Vector2f(0, 1));
                    break;
                case sf::Keyboard::Left:
                    snake.setDirection(sf::Vector2f(-1, 0));
                    break;
                case sf::Keyboard::Right:
                    snake.setDirection(sf::Vector2f(1, 0));
                    break;
            }
        }

        if (event.type == sf::Event::KeyPressed && gameOver) {
            if (event.key.code == sf::Keyboard::R) {
                // é‡æ–°å¼€å§‹æ¸¸æˆ
                reset();
            }
        }
    }

    void update(float deltaTime) override {
        if (!gameOver) {
            snake.update(deltaTime);

            // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
            if (snake.getHead() == food) {
                snake.grow();
                score += 10;
                scoreText.setString("Score: " + std::to_string(score));
                spawnFood();
            }

            // æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
            if (snake.checkCollision()) {
                gameOver = true;
            }
        }
    }

    void render(sf::RenderWindow& window) override {
        // ç»˜åˆ¶è›‡èº«
        for (const auto& segment : snake.getBody()) {
            sf::RectangleShape rect(sf::Vector2f(18, 18));
            rect.setPosition(segment);
            rect.setFillColor(sf::Color::Green);
            rect.setOutlineColor(sf::Color::DarkGreen);
            rect.setOutlineThickness(1);
            window.draw(rect);
        }

        // ç»˜åˆ¶é£Ÿç‰©
        sf::CircleShape foodShape(8);
        foodShape.setPosition(food);
        foodShape.setFillColor(sf::Color::Red);
        window.draw(foodShape);

        // ç»˜åˆ¶åˆ†æ•°
        window.draw(scoreText);

        // ç»˜åˆ¶æ¸¸æˆç»“æŸä¿¡æ¯
        if (gameOver) {
            sf::Text gameOverText;
            gameOverText.setFont(font);
            gameOverText.setString("Game Over! Press R to restart");
            gameOverText.setCharacterSize(32);
            gameOverText.setPosition(200, 250);
            gameOverText.setColor(sf::Color::Red);
            window.draw(gameOverText);
        }
    }

    void onEnter() override {
        reset();
    }

    void onExit() override {
        // æ¸…ç†èµ„æº
    }

private:
    void spawnFood() {
        // éšæœºç”Ÿæˆé£Ÿç‰©ä½ç½®
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> disX(0, 39);
        std::uniform_int_distribution<> disY(0, 29);

        food = sf::Vector2f(disX(gen) * 20, disY(gen) * 20);
    }

    void reset() {
        snake = Snake();
        score = 0;
        scoreText.setString("Score: 0");
        gameOver = false;
        spawnFood();
    }
};
```

### 2. ä¿„ç½—æ–¯æ–¹å—ï¼šå‡ ä½•å­¦çš„å®Œç¾åº”ç”¨

#### æ–¹å—å½¢çŠ¶å®šä¹‰

```cpp
// æ–¹å—å½¢çŠ¶å®šä¹‰
const std::vector<std::vector<std::vector<int>>> TETROMINOES = {
    // Iå½¢
    {
        {0,0,0,0},
        {1,1,1,1},
        {0,0,0,0},
        {0,0,0,0}
    },
    // Oå½¢
    {
        {1,1},
        {1,1}
    },
    // Tå½¢
    {
        {0,1,0},
        {1,1,1},
        {0,0,0}
    },
    // Så½¢
    {
        {0,1,1},
        {1,1,0},
        {0,0,0}
    },
    // Zå½¢
    {
        {1,1,0},
        {0,1,1},
        {0,0,0}
    },
    // Jå½¢
    {
        {1,0,0},
        {1,1,1},
        {0,0,0}
    },
    // Lå½¢
    {
        {0,0,1},
        {1,1,1},
        {0,0,0}
    }
};

class Tetromino {
private:
    std::vector<std::vector<int>> shape;
    sf::Vector2i position;
    sf::Color color;

public:
    Tetromino(int type) {
        shape = TETROMINOES[type];
        position = sf::Vector2i(3, 0);

        // è®¾ç½®é¢œè‰²
        std::vector<sf::Color> colors = {
            sf::Color::Cyan,    // I
            sf::Color::Yellow,  // O
            sf::Color::Magenta, // T
            sf::Color::Green,   // S
            sf::Color::Red,     // Z
            sf::Color::Blue,    // J
            sf::Color(255, 165, 0) // L (æ©™è‰²)
        };
        color = colors[type];
    }

    void rotate() {
        // çŸ©é˜µæ—‹è½¬90åº¦
        std::vector<std::vector<int>> rotated(shape[0].size(),
                                             std::vector<int>(shape.size()));

        for (size_t i = 0; i < shape.size(); ++i) {
            for (size_t j = 0; j < shape[0].size(); ++j) {
                rotated[j][shape.size() - 1 - i] = shape[i][j];
            }
        }
        shape = rotated;
    }

    void move(const sf::Vector2i& offset) {
        position += offset;
    }

    bool isValidPosition(const std::vector<std::vector<int>>& board) const {
        for (size_t i = 0; i < shape.size(); ++i) {
            for (size_t j = 0; j < shape[i].size(); ++j) {
                if (shape[i][j] == 0) continue;

                int boardX = position.x + j;
                int boardY = position.y + i;

                // æ£€æŸ¥è¾¹ç•Œ
                if (boardX < 0 || boardX >= board[0].size() ||
                    boardY >= board.size()) {
                    return false;
                }

                // æ£€æŸ¥ç¢°æ’
                if (boardY >= 0 && board[boardY][boardX] != 0) {
                    return false;
                }
            }
        }
        return true;
    }

    void placeOnBoard(std::vector<std::vector<int>>& board) const {
        for (size_t i = 0; i < shape.size(); ++i) {
            for (size_t j = 0; j < shape[i].size(); ++j) {
                if (shape[i][j] != 0) {
                    int boardX = position.x + j;
                    int boardY = position.y + i;
                    if (boardY >= 0) {
                        board[boardY][boardX] = 1;
                    }
                }
            }
        }
    }

    const std::vector<std::vector<int>>& getShape() const { return shape; }
    sf::Vector2i getPosition() const { return position; }
    sf::Color getColor() const { return color; }
};
```
            currentPiece = rotated;
        }
    }

    void movePiece(int dx, int dy) {
        sf::Vector2i newPos = piecePos + sf::Vector2i(dx, dy);
        if (canPlace(currentPiece, newPos)) {
            piecePos = newPos;
        }
    }

    void dropPiece() {
        while (canPlace(currentPiece, piecePos + sf::Vector2i(0, 1))) {
            piecePos.y++;
        }
        placePiece();
        clearLines();
        spawnNewPiece();
    }
};
```

### 3. å¼¹çƒæ¸¸æˆ (Pong)

#### æ¸¸æˆç‰¹ç‚¹
- **åŒäººå¯¹æˆ˜**ï¼šæ”¯æŒä¸¤ä¸ªç©å®¶å¯¹æˆ˜
- **ç‰©ç†æ¨¡æ‹Ÿ**ï¼šçƒçš„åå¼¹å’Œé€Ÿåº¦å˜åŒ–
- **AIå¯¹æ‰‹**ï¼šå¯é€‰çš„AIå¯¹æ‰‹

#### æ ¸å¿ƒä»£ç 
```cpp
class Pong {
private:
    sf::RectangleShape leftPaddle, rightPaddle;
    sf::CircleShape ball;
    sf::Vector2f ballVelocity;
    int leftScore, rightScore;

public:
    void update() {
        // æ›´æ–°çƒçš„ä½ç½®
        ball.move(ballVelocity);

        // æ£€æŸ¥è¾¹ç•Œç¢°æ’
        if (ball.getPosition().y <= 0 ||
            ball.getPosition().y >= HEIGHT - ball.getRadius()) {
            ballVelocity.y = -ballVelocity.y;
        }

        // æ£€æŸ¥çƒæ‹ç¢°æ’
        if (ball.getGlobalBounds().intersects(leftPaddle.getGlobalBounds()) ||
            ball.getGlobalBounds().intersects(rightPaddle.getGlobalBounds())) {
            ballVelocity.x = -ballVelocity.x;
            // å¢åŠ çƒçš„é€Ÿåº¦
            ballVelocity *= 1.1f;
        }

        // æ£€æŸ¥å¾—åˆ†
        if (ball.getPosition().x <= 0) {
            rightScore++;
            resetBall();
        } else if (ball.getPosition().x >= WIDTH) {
            leftScore++;
            resetBall();
        }
    }

    void movePaddle(int player, float dy) {
        if (player == 0) {
            leftPaddle.move(0, dy);
        } else {
            rightPaddle.move(0, dy);
        }

        // é™åˆ¶çƒæ‹åœ¨å±å¹•å†…
        if (leftPaddle.getPosition().y < 0) {
            leftPaddle.setPosition(leftPaddle.getPosition().x, 0);
        }
        if (leftPaddle.getPosition().y > HEIGHT - leftPaddle.getSize().y) {
            leftPaddle.setPosition(leftPaddle.getPosition().x,
                                 HEIGHT - leftPaddle.getSize().y);
        }
    }
};
```

### 4. é£æœºå¤§æˆ˜ (Space Shooter)

#### æ¸¸æˆç‰¹ç‚¹
- **æ•Œæœºç”Ÿæˆ**ï¼šéšæœºç”Ÿæˆæ•Œæœº
- **å­å¼¹ç³»ç»Ÿ**ï¼šå‘å°„å­å¼¹å‡»æ¯æ•Œæœº
- **çˆ†ç‚¸æ•ˆæœ**ï¼šæ•Œæœºè¢«å‡»æ¯æ—¶çš„çˆ†ç‚¸åŠ¨ç”»

#### æ ¸å¿ƒä»£ç 
```cpp
class SpaceShooter {
private:
    sf::RectangleShape player;
    std::vector<sf::RectangleShape> enemies;
    std::vector<sf::RectangleShape> bullets;
    int score;

public:
    void update() {
        // æ›´æ–°å­å¼¹ä½ç½®
        for (auto& bullet : bullets) {
            bullet.move(0, -5);
        }

        // æ›´æ–°æ•Œæœºä½ç½®
        for (auto& enemy : enemies) {
            enemy.move(0, 2);
        }

        // æ£€æŸ¥ç¢°æ’
        checkCollisions();

        // æ¸…ç†è¶…å‡ºå±å¹•çš„å¯¹è±¡
        cleanupObjects();

        // ç”Ÿæˆæ–°æ•Œæœº
        if (rand() % 100 < 5) {
            spawnEnemy();
        }
    }

    void shoot() {
        sf::RectangleShape bullet(sf::Vector2f(2, 10));
        bullet.setPosition(player.getPosition().x +
                          player.getSize().x / 2 - 1,
                          player.getPosition().y);
        bullets.push_back(bullet);
    }

    void checkCollisions() {
        // æ£€æŸ¥å­å¼¹å’Œæ•Œæœºçš„ç¢°æ’
        for (auto bulletIt = bullets.begin();
             bulletIt != bullets.end(); ++bulletIt) {
            for (auto enemyIt = enemies.begin();
                 enemyIt != enemies.end(); ++enemyIt) {
                if (bulletIt->getGlobalBounds().intersects(
                    enemyIt->getGlobalBounds())) {
                    bullets.erase(bulletIt);
                    enemies.erase(enemyIt);
                    score += 10;
                    break;
                }
            }
        }
    }
};
```

### 5. è¿·å®«æ¸¸æˆ (Maze)

#### æ¸¸æˆç‰¹ç‚¹
- **è¿·å®«ç”Ÿæˆ**ï¼šä½¿ç”¨ç®—æ³•ç”Ÿæˆéšæœºè¿·å®«
- **è·¯å¾„å¯»æ‰¾**ï¼šå®ç°A*ç®—æ³•å¯»æ‰¾æœ€çŸ­è·¯å¾„
- **ç©å®¶æ§åˆ¶**ï¼šé”®ç›˜æ§åˆ¶ç©å®¶ç§»åŠ¨

#### æ ¸å¿ƒä»£ç 
```cpp
class Maze {
private:
    std::vector<std::vector<int>> maze;
    sf::Vector2i playerPos;
    sf::Vector2i goalPos;

public:
    void generateMaze() {
        // ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ç”Ÿæˆè¿·å®«
        std::vector<std::vector<bool>> visited(HEIGHT,
                                              std::vector<bool>(WIDTH, false));

        std::stack<sf::Vector2i> stack;
        stack.push(sf::Vector2i(1, 1));
        visited[1][1] = true;

        while (!stack.empty()) {
            sf::Vector2i current = stack.top();
            std::vector<sf::Vector2i> neighbors = getUnvisitedNeighbors(current, visited);

            if (neighbors.empty()) {
                stack.pop();
            } else {
                sf::Vector2i next = neighbors[rand() % neighbors.size()];
                removeWall(current, next);
                visited[next.y][next.x] = true;
                stack.push(next);
            }
        }
    }

    bool movePlayer(int dx, int dy) {
        sf::Vector2i newPos = playerPos + sf::Vector2i(dx, dy);

        if (newPos.x >= 0 && newPos.x < WIDTH &&
            newPos.y >= 0 && newPos.y < HEIGHT &&
            maze[newPos.y][newPos.x] == 0) {
            playerPos = newPos;
            return true;
        }
        return false;
    }

    bool isGoalReached() {
        return playerPos == goalPos;
    }
};
```

## æ¸¸æˆå¼€å‘æŠ€å·§

### 1. æ¸¸æˆå¾ªç¯è®¾è®¡
```cpp
class GameLoop {
private:
    sf::Clock clock;
    float deltaTime;

public:
    void run() {
        while (window.isOpen()) {
            // å¤„ç†äº‹ä»¶
            handleEvents();

            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            update(deltaTime);

            // æ¸²æŸ“ç”»é¢
            render();

            // æ§åˆ¶å¸§ç‡
            deltaTime = clock.restart().asSeconds();
            if (deltaTime < 1.0f / 60.0f) {
                sf::sleep(sf::seconds(1.0f / 60.0f - deltaTime));
            }
        }
    }

    void handleEvents() {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed) {
                window.close();
            }
            // å¤„ç†å…¶ä»–äº‹ä»¶
        }
    }
};
```

### 2. çŠ¶æ€ç®¡ç†
```cpp
enum class GameState {
    MENU,
    PLAYING,
    PAUSED,
    GAME_OVER
};

class GameStateManager {
private:
    GameState currentState;

public:
    void update() {
        switch (currentState) {
            case GameState::MENU:
                updateMenu();
                break;
            case GameState::PLAYING:
                updateGame();
                break;
            case GameState::PAUSED:
                updatePause();
                break;
            case GameState::GAME_OVER:
                updateGameOver();
                break;
        }
    }

    void changeState(GameState newState) {
        currentState = newState;
    }
};
```

### 3. èµ„æºç®¡ç†
```cpp
class ResourceManager {
private:
    std::map<std::string, sf::Texture> textures;
    std::map<std::string, sf::Font> fonts;
    std::map<std::string, sf::SoundBuffer> sounds;

public:
    sf::Texture& getTexture(const std::string& name) {
        if (textures.find(name) == textures.end()) {
            textures[name].loadFromFile("assets/textures/" + name + ".png");
        }
        return textures[name];
    }

    sf::Font& getFont(const std::string& name) {
        if (fonts.find(name) == fonts.end()) {
            fonts[name].loadFromFile("assets/fonts/" + name + ".ttf");
        }
        return fonts[name];
    }
};
```

## è¸©å‘ç»éªŒåˆ†äº«

### 1. ç¯å¢ƒé…ç½®å‘
```cpp
// é—®é¢˜ï¼šSFMLåº“é“¾æ¥å¤±è´¥
// é”™è¯¯ä¿¡æ¯ï¼šLNK2019 unresolved external symbol
// è§£å†³æ–¹æ¡ˆï¼š
// 1. æ£€æŸ¥åº“æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®
// 2. ç¡®è®¤Debug/Releaseç‰ˆæœ¬åŒ¹é…
// 3. æ£€æŸ¥ä¾èµ–é¡¹æ˜¯å¦å®Œæ•´

// é—®é¢˜ï¼šDLLæ–‡ä»¶æ‰¾ä¸åˆ°
// é”™è¯¯ä¿¡æ¯ï¼šThe program can't start because xxx.dll is missing
// è§£å†³æ–¹æ¡ˆï¼š
// 1. å°†SFMLçš„binç›®å½•æ·»åŠ åˆ°ç³»ç»ŸPATH
// 2. æˆ–è€…å°†DLLæ–‡ä»¶å¤åˆ¶åˆ°å¯æ‰§è¡Œæ–‡ä»¶ç›®å½•
```

### 2. æ¸¸æˆé€»è¾‘å‘
```cpp
// é—®é¢˜ï¼šæ¸¸æˆå¾ªç¯å¡é¡¿
// é”™è¯¯åšæ³•ï¼šæ²¡æœ‰æ§åˆ¶å¸§ç‡
// æ­£ç¡®åšæ³•ï¼šä½¿ç”¨sf::Clockæ§åˆ¶å¸§ç‡

// é—®é¢˜ï¼šç¢°æ’æ£€æµ‹ä¸å‡†ç¡®
// é”™è¯¯åšæ³•ï¼šä½¿ç”¨ç®€å•çš„çŸ©å½¢ç¢°æ’
// æ­£ç¡®åšæ³•ï¼šæ ¹æ®æ¸¸æˆéœ€æ±‚é€‰æ‹©åˆé€‚çš„ç¢°æ’æ£€æµ‹ç®—æ³•

// é—®é¢˜ï¼šå†…å­˜æ³„æ¼
// é”™è¯¯åšæ³•ï¼šé¢‘ç¹åˆ›å»ºåˆ é™¤å¯¹è±¡
// æ­£ç¡®åšæ³•ï¼šä½¿ç”¨å¯¹è±¡æ± æˆ–æ™ºèƒ½æŒ‡é’ˆ
```

### 3. æ€§èƒ½ä¼˜åŒ–å‘
```cpp
// é—®é¢˜ï¼šæ¸²æŸ“æ€§èƒ½å·®
// é”™è¯¯åšæ³•ï¼šæ¯å¸§é‡æ–°åˆ›å»ºå›¾å½¢å¯¹è±¡
// æ­£ç¡®åšæ³•ï¼šé¢„åˆ›å»ºå¯¹è±¡ï¼Œåªæ›´æ–°ä½ç½®

// é—®é¢˜ï¼šéŸ³æ•ˆæ’­æ”¾å¡é¡¿
// é”™è¯¯åšæ³•ï¼šåŒæ—¶æ’­æ”¾å¤ªå¤šéŸ³æ•ˆ
// æ­£ç¡®åšæ³•ï¼šé™åˆ¶åŒæ—¶æ’­æ”¾çš„éŸ³æ•ˆæ•°é‡

// é—®é¢˜ï¼šæ¸¸æˆå¡é¡¿
// é”™è¯¯åšæ³•ï¼šåœ¨æ¸²æŸ“å¾ªç¯ä¸­è¿›è¡Œå¤æ‚è®¡ç®—
// æ­£ç¡®åšæ³•ï¼šå°†è®¡ç®—åˆ†æ•£åˆ°å¤šä¸ªå¸§ä¸­
```

## é¡¹ç›®æ€»ç»“

### 1. æŠ€æœ¯æ”¶è·
- **å›¾å½¢ç¼–ç¨‹**ï¼šæŒæ¡äº†SFMLçš„åŸºæœ¬ç”¨æ³•
- **æ¸¸æˆè®¾è®¡**ï¼šå­¦ä¼šäº†æ¸¸æˆå¾ªç¯å’ŒçŠ¶æ€ç®¡ç†
- **ç‰©ç†æ¨¡æ‹Ÿ**ï¼šç†è§£äº†åŸºæœ¬çš„ç‰©ç†æ¦‚å¿µ
- **éŸ³æ•ˆå¤„ç†**ï¼šå­¦ä¼šäº†éŸ³é¢‘æ’­æ”¾å’Œç®¡ç†

### 2. å¼€å‘ç»éªŒ
- **æ¨¡å—åŒ–è®¾è®¡**ï¼šå°†æ¸¸æˆåˆ†è§£ä¸ºå¤šä¸ªæ¨¡å—
- **ä»£ç å¤ç”¨**ï¼šæå–å…¬å…±åŠŸèƒ½ä¸ºåŸºç±»
- **è°ƒè¯•æŠ€å·§**ï¼šä½¿ç”¨è°ƒè¯•å·¥å…·å®šä½é—®é¢˜
- **æ€§èƒ½ä¼˜åŒ–**ï¼šä¼˜åŒ–å…³é”®è·¯å¾„çš„æ€§èƒ½

### 3. å­¦ä¹ å»ºè®®
- **ä»ç®€å•å¼€å§‹**ï¼šå…ˆå®ç°ç®€å•çš„æ¸¸æˆï¼Œå†é€æ­¥å¢åŠ å¤æ‚åº¦
- **å¤šçœ‹æºç **ï¼šå­¦ä¹ ä¼˜ç§€çš„å¼€æºæ¸¸æˆé¡¹ç›®
- **å®è·µä¸ºä¸»**ï¼šç†è®ºç»“åˆå®è·µï¼Œå¤šå†™ä»£ç 
- **æŒç»­å­¦ä¹ **ï¼šå…³æ³¨æ¸¸æˆå¼€å‘çš„æ–°æŠ€æœ¯å’Œè¶‹åŠ¿

## å‚è€ƒèµ„æ–™

### å®˜æ–¹æ–‡æ¡£
- [SFMLå®˜æ–¹æ–‡æ¡£](https://www.sfml-dev.org/documentation.php)
- [SFMLæ•™ç¨‹](https://www.sfml-dev.org/tutorials.php)
- [SFMLç¤ºä¾‹](https://github.com/SFML/SFML/tree/master/examples)

### å­¦ä¹ èµ„æº
- [æ¸¸æˆå¼€å‘æ•™ç¨‹](https://www.gamefromscratch.com/)
- [C++æ¸¸æˆç¼–ç¨‹](https://www.learncpp.com/)
- [OpenGLæ•™ç¨‹](https://learnopengl.com/)

---

**å†™åœ¨æœ€å**ï¼šæ¸¸æˆå¼€å‘æ˜¯ä¸€ä¸ªå……æ»¡æŒ‘æˆ˜å’Œä¹è¶£çš„é¢†åŸŸï¼Œéœ€è¦æ‰å®çš„ç¼–ç¨‹åŸºç¡€å’Œä¸°å¯Œçš„æƒ³è±¡åŠ›ã€‚ä½œä¸ºä¸€ä¸ªæŠ€æœ¯åºŸæŸ´ï¼Œæˆ‘æ·±æ·±ä½“ä¼šåˆ°å®è·µå’ŒåšæŒçš„é‡è¦æ€§ã€‚è®°ä½ï¼Œæ¯ä¸€ä¸ªæ¸¸æˆå¤§ç¥éƒ½æ˜¯ä»ç®€å•çš„"Hello World"å¼€å§‹çš„ï¼

> ğŸ’¡ **åºŸæŸ´å°è´´å£«**ï¼šå½“ä½ å¼€å§‹æ¸¸æˆå¼€å‘æ—¶ï¼Œä¸è¦å®³æ€•ä»ç®€å•çš„é¡¹ç›®å¼€å§‹ï¼Œæ¯ä¸€ä¸ªç»å…¸æ¸¸æˆéƒ½æœ‰å…¶ç‹¬ç‰¹çš„é­…åŠ›ã€‚æ¯ä¸€ä¸ªæŠ€æœ¯åºŸæŸ´éƒ½æœ‰æˆä¸ºæ¸¸æˆå¼€å‘è€…çš„æ½œåŠ›ã€‚
9:{"id":"cpp-games-with-sfml","title":"ğŸ® åå…­ä¸ªç»å…¸C++æ¸¸æˆé¡¹ç›®ï¼šæŠ€æœ¯åºŸæŸ´çš„æ¸¸æˆå¼€å‘å®æˆ˜","description":"ä»è´ªåƒè›‡åˆ°ä¿„ç½—æ–¯æ–¹å—ï¼Œä»é£æœºå¤§æˆ˜åˆ°è¿·å®«æ¢ç´¢ï¼Œåˆ†äº«æˆ‘åœ¨SFMLæ¸¸æˆå¼€å‘ä¸­çš„å®Œæ•´é¡¹ç›®ç»éªŒå’Œå®ç”¨æŠ€å·§ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨æ¸¸æˆå¼€å‘é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚","date":"2020-06-30","readTime":"15åˆ†é’Ÿ","tags":"$a","category":"æ¸¸æˆå¼€å‘","slug":"cpp-games-with-sfml","featured":false,"author":"LJoson","status":"published","content":"$b","excerpt":"\r\n åå…­ä¸ªç»å…¸C++æ¸¸æˆé¡¹ç›®ï¼šæŠ€æœ¯åºŸæŸ´çš„æ¸¸æˆå¼€å‘å®æˆ˜\r\n\r\n> ä»\"Hello World\"åˆ°å®Œæ•´æ¸¸æˆï¼Œæˆ‘çš„SFMLæ¸¸æˆå¼€å‘é¡¹ç›®é›†\r\n\r\n æˆ‘ä¸æ¸¸æˆå¼€å‘çš„\"ç¬¬ä¸€æ¬¡äº²å¯†æ¥è§¦\"\r\n\r\n ç¬¬ä¸€ä¸ªæ¸¸æˆï¼šè´ªåƒè›‡çš„\"ç¿»è½¦\"ç»å†\r\n\r\nè¿˜è®°å¾—ç¬¬ä¸€æ¬¡ç”¨SFMLå†™è´ªåƒè›‡æ—¶ï¼Œæˆ‘ä¿¡å¿ƒæ»¡æ»¡åœ°å¼€å§‹ç¼–ç ï¼š\r\n\r\ncpp\r\n// æˆ‘çš„ç¬¬ä¸€ä¸ª\"æ°ä½œ\"\r\nclass Snake {\r\n    std::vector<sf::Ve..."}
d:["slug","cpp-games-with-sfml","d"]
0:["build-1756572638459",[[["",{"children":["blog",{"children":[["slug","cpp-games-with-sfml","d"],{"children":["__PAGE__?{\"slug\":\"cpp-games-with-sfml\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["blog",{"children":[["slug","cpp-games-with-sfml","d"],{"children":["__PAGE__",{},[["$L1",["$","div",null,{"className":"min-h-screen bg-cyber-bg-900","children":["$","div",null,{"className":"relative overflow-hidden","children":[["$","div",null,{"className":"absolute inset-0 bg-gradient-to-br from-fail-red/5 via-fail-orange/3 to-fail-purple/5"}],["$","div",null,{"className":"relative z-10","children":[["$","div",null,{"className":"max-w-7xl mx-auto px-4 py-8","children":["$","div",null,{"className":"grid grid-cols-1 lg:grid-cols-4 gap-8","children":[["$","div",null,{"className":"lg:col-span-3 w-full","children":["$","$L2",null,{"post":{"id":"cpp-games-with-sfml","title":"ğŸ® åå…­ä¸ªç»å…¸C++æ¸¸æˆé¡¹ç›®ï¼šæŠ€æœ¯åºŸæŸ´çš„æ¸¸æˆå¼€å‘å®æˆ˜","description":"ä»è´ªåƒè›‡åˆ°ä¿„ç½—æ–¯æ–¹å—ï¼Œä»é£æœºå¤§æˆ˜åˆ°è¿·å®«æ¢ç´¢ï¼Œåˆ†äº«æˆ‘åœ¨SFMLæ¸¸æˆå¼€å‘ä¸­çš„å®Œæ•´é¡¹ç›®ç»éªŒå’Œå®ç”¨æŠ€å·§ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨æ¸¸æˆå¼€å‘é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚","date":"2020-06-30","readTime":"15åˆ†é’Ÿ","tags":["æ¸¸æˆå¼€å‘","C++","SFML","å›¾å½¢ç¼–ç¨‹","æ¸¸æˆå¼•æ“","æŠ€æœ¯åºŸæŸ´","é¡¹ç›®å®æˆ˜","è·¨ç•Œæ¢ç´¢"],"category":"æ¸¸æˆå¼€å‘","slug":"cpp-games-with-sfml","featured":false,"author":"LJoson","status":"published","content":"$3","excerpt":"\r\n åå…­ä¸ªç»å…¸C++æ¸¸æˆé¡¹ç›®ï¼šæŠ€æœ¯åºŸæŸ´çš„æ¸¸æˆå¼€å‘å®æˆ˜\r\n\r\n> ä»\"Hello World\"åˆ°å®Œæ•´æ¸¸æˆï¼Œæˆ‘çš„SFMLæ¸¸æˆå¼€å‘é¡¹ç›®é›†\r\n\r\n æˆ‘ä¸æ¸¸æˆå¼€å‘çš„\"ç¬¬ä¸€æ¬¡äº²å¯†æ¥è§¦\"\r\n\r\n ç¬¬ä¸€ä¸ªæ¸¸æˆï¼šè´ªåƒè›‡çš„\"ç¿»è½¦\"ç»å†\r\n\r\nè¿˜è®°å¾—ç¬¬ä¸€æ¬¡ç”¨SFMLå†™è´ªåƒè›‡æ—¶ï¼Œæˆ‘ä¿¡å¿ƒæ»¡æ»¡åœ°å¼€å§‹ç¼–ç ï¼š\r\n\r\ncpp\r\n// æˆ‘çš„ç¬¬ä¸€ä¸ª\"æ°ä½œ\"\r\nclass Snake {\r\n    std::vector<sf::Ve..."}}]}],["$","div",null,{"className":"lg:col-span-1","children":["$","div",null,{"className":"sticky top-24","children":["$","$L4",null,{}]}]}]]}]}],["$","div",null,{"className":"max-w-7xl mx-auto px-4 pb-16","children":["$","$L5",null,{"posts":[{"id":"unity-error-diary-1001","title":"ğŸ˜­ UnityæŠ¥é”™æ—¥è®°ï¼šç¬¬1001æ¬¡æƒ³æ”¾å¼ƒ","description":"Unityå¼€å‘ä¸­å¸¸è§é”™è¯¯çš„è§£å†³æ–¹æ¡ˆåˆé›†ï¼Œè®°å½•æˆ‘åœ¨Unityå¼€å‘ä¸­é‡åˆ°çš„å„ç§å¥‡è‘©é—®é¢˜å’Œè§£å†³æ–¹æ³•ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨æ¸¸æˆå¼€å‘é¢†åŸŸçš„æˆé•¿è½¨è¿¹","date":"2024-02-15","readTime":"5åˆ†é’Ÿ","tags":["Unity","æ¸¸æˆå¼€å‘","é”™è¯¯å¤„ç†","C#","è¸©å‘ç»éªŒ","è·¨ç•Œæ¢ç´¢"],"category":"æ¸¸æˆå¼€å‘","slug":"unity-error-diary-1001","featured":false,"author":"LJoson","status":"published","content":"$6","excerpt":" UnityæŠ¥é”™æ—¥è®°ï¼šç¬¬1001æ¬¡æƒ³æ”¾å¼ƒ\r\n\r\n> ä½œä¸ºä¸€ä¸ªæ‰‹æ®‹å…šï¼Œåœ¨Unityå¼€å‘ä¸­é‡åˆ°çš„å¥‡è‘©é—®é¢˜ï¼Œä»¥åŠæˆ‘çš„è§£å†³æ€è·¯\r\n\r\n å‰è¨€\r\n\r\nä½œä¸ºä¸€ä¸ªæŠ€æœ¯åºŸæŸ´ï¼Œæˆ‘åœ¨Unityå¼€å‘çš„é“è·¯ä¸Šå¯è°“æ˜¯è·Œè·Œæ’æ’ï¼Œæ¯æ¬¡é‡åˆ°æŠ¥é”™éƒ½è®©æˆ‘æ€€ç–‘äººç”Ÿã€‚ä½†æ˜¯ç»è¿‡æ— æ•°æ¬¡çš„å°è¯•å’Œå¤±è´¥ï¼Œæˆ‘ç»ˆäºæ€»ç»“å‡ºäº†ä¸€äº›ç»éªŒã€‚è¿™ç¯‡æ–‡ç« è®°å½•äº†æˆ‘é‡åˆ°çš„å„ç§å¥‡è‘©é—®é¢˜ï¼Œä»¥åŠæˆ‘æ˜¯å¦‚ä½•ä¸€æ­¥æ­¥è§£å†³çš„ã€‚\r\n\r\n å¸¸è§æŠ¥é”™ç±»å‹åŠè§£å†³æ–¹æ¡ˆ\r\n\r\n 1. NullR..."},{"id":"ue5-game-development","title":"ğŸ® UE5æ¸¸æˆå¼€å‘å®æˆ˜ï¼šä»å…¥é—¨åˆ°ç²¾é€š","description":"è™šå¹»å¼•æ“5æ¸¸æˆå¼€å‘å®Œæ•´æŒ‡å—ï¼Œä»ç¯å¢ƒæ­å»ºåˆ°é¡¹ç›®å‘å¸ƒï¼ŒåŒ…å«æœ€æ–°çš„UE5ç‰¹æ€§å’Œæœ€ä½³å®è·µï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨æ¸¸æˆå¼€å‘é¢†åŸŸçš„æˆé•¿è½¨è¿¹","date":"2024-02-10","readTime":"5åˆ†é’Ÿ","tags":["UE5","è™šå¹»å¼•æ“","æ¸¸æˆå¼€å‘","C++","è“å›¾","è·¨ç•Œæ¢ç´¢"],"category":"æ¸¸æˆå¼€å‘","slug":"ue5-game-development","featured":false,"author":"LJoson","status":"published","content":"$7","excerpt":" UE5æ¸¸æˆå¼€å‘å®æˆ˜æ•™ç¨‹\r\n\r\n> æ·±å…¥Unreal Engine 5çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œä»è“å›¾ç¼–ç¨‹åˆ°C++å¼€å‘ï¼Œæ‰“é€ é«˜è´¨é‡æ¸¸æˆä½œå“\r\n\r\n å‰è¨€\r\n\r\nUnreal Engine 5ä½œä¸ºEpic Gamesæœ€æ–°æ¨å‡ºçš„æ¸¸æˆå¼•æ“ï¼Œå¸¦æ¥äº†é©å‘½æ€§çš„æŠ€æœ¯é©æ–°ï¼ŒåŒ…æ‹¬Naniteè™šæ‹Ÿå‡ ä½•ä½“ç³»ç»Ÿã€Lumenå…¨å±€å…‰ç…§ç³»ç»Ÿç­‰ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨UE5çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œä»è“å›¾ç¼–ç¨‹åˆ°C++å¼€å‘ï¼Œä¸ºæ¸¸æˆå¼€å‘è€…æä¾›å…¨é¢çš„æŠ€æœ¯æŒ‡å¯¼ã€‚\r\n\r\n ..."},{"id":"unity-robot-simulation","title":"ğŸ® Unityæ¸¸æˆç‰©ç†ç³»ç»Ÿå®æˆ˜æŒ‡å—","description":"ä»è§’è‰²æ§åˆ¶åˆ°é“å…·äº¤äº’ï¼Œä»ç¯å¢ƒæ•ˆæœåˆ°åŠ¨ç”»ç³»ç»Ÿï¼Œåˆ†äº«æˆ‘åœ¨Unityæ¸¸æˆå¼€å‘ä¸­çš„çœŸå®é¡¹ç›®ç»éªŒå’Œå®ç”¨æŠ€å·§ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨æ¸¸æˆå¼€å‘é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚","date":"2024-01-10","readTime":"15åˆ†é’Ÿ","tags":["Unity3D","æ¸¸æˆå¼€å‘","ç‰©ç†ç³»ç»Ÿ","è§’è‰²æ§åˆ¶","é“å…·äº¤äº’","C#","Rigidbody","ç‰©ç†å¼•æ“","è·¨ç•Œæ¢ç´¢"],"category":"æ¸¸æˆå¼€å‘","slug":"unity-robot-simulation","featured":true,"author":"LJoson","status":"published","content":"$8","excerpt":"\r\n ğŸ® Unityæ¸¸æˆç‰©ç†ç³»ç»Ÿå®æˆ˜æŒ‡å—\r\n\r\n é¡¹ç›®èƒŒæ™¯ï¼šæˆ‘çš„ç¬¬ä¸€ä¸ª3Dæ¸¸æˆ\r\n\r\nè¿™æ˜¯ä¸€ä¸ªå…³äºå¤ªç©ºæ¢é™©çš„æ¸¸æˆé¡¹ç›®ï¼Œç©å®¶éœ€è¦æ§åˆ¶ä¸€ä¸ªæœºå™¨äººåœ¨ä¸åŒçš„æ˜Ÿçƒä¸Šæ¢ç´¢ã€æ”¶é›†èµ„æºã€ä¸æ•Œäººæˆ˜æ–—ã€‚\r\n\r\næ¸¸æˆç‰¹è‰²ï¼š\r\n- çœŸå®çš„ç‰©ç†äº¤äº’\r\n- æµç•…çš„è§’è‰²æ§åˆ¶\r\n- ä¸°å¯Œçš„ç¯å¢ƒæ•ˆæœ\r\n- æ™ºèƒ½çš„AIç³»ç»Ÿ\r\n\r\næŠ€æœ¯æŒ‘æˆ˜ï¼š\r\n- å¤æ‚çš„ç‰©ç†ç³»ç»Ÿ\r\n- æµç•…çš„åŠ¨ç”»è¿‡æ¸¡\r\n- å®æ—¶çš„ç¯å¢ƒäº¤äº’\r\n- ä¼˜åŒ–çš„æ€§èƒ½è¡¨ç°\r\n..."}],"currentPost":"$9"}]}]]}]]}]}],null],null],null]},[null,["$","$Lc",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","$d","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Le",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$Lc",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$Le",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/3689037f0d92e8a5.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"zh-CN","className":"scroll-smooth","children":[["$","head",null,{"children":[["$","link",null,{"rel":"icon","href":"/favicon.svg"}],["$","link",null,{"rel":"apple-touch-icon","href":"/apple-touch-icon.svg"}],["$","link",null,{"rel":"manifest","href":"/manifest.json"}],["$","meta",null,{"name":"theme-color","content":"#ff6b6b"}],["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"WebSite\",\"name\":\"LJoson çš„åºŸæŸ´å°çª\",\"description\":\"ä»æŠ€æœ¯åºŸæŸ´åˆ°è·¨ç•Œæ¢ç´¢è€…çš„è¿›åŒ–ä¹‹è·¯\",\"url\":\"https://ljoson.com\",\"author\":{\"@type\":\"Person\",\"name\":\"LJoson\",\"url\":\"https://ljoson.com\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"GlimmerLab\",\"url\":\"https://glimmerlab.com\"}}"}}]]}],["$","body",null,{"className":"bg-cyber-bg-900 text-white antialiased font-sans selection:bg-fail-red/20 selection:text-white","children":[["$","$Lf",null,{"children":["$","$L10",null,{"children":["$","$L11",null,{"children":["$","div",null,{"className":"min-h-screen flex flex-col relative","children":[["$","div",null,{"className":"fixed inset-0 pointer-events-none","children":[["$","div",null,{"className":"absolute inset-0 bg-gradient-to-br from-fail-red/5 via-transparent to-fail-purple/5"}],["$","div",null,{"className":"absolute top-0 left-0 w-full h-full bg-[radial-gradient(circle_at_50%_50%,rgba(255,107,107,0.1),transparent_50%)]"}]]}],["$","div",null,{"className":"relative z-10 flex flex-col min-h-screen","children":[["$","$L12",null,{}],["$","main",null,{"className":"flex-1 relative","children":["$","$Lc",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$13","errorStyles":[],"errorScripts":[],"template":["$","$Le",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","$L14",null,{}],"notFoundStyles":[]}]}],["$","$L15",null,{}]]}]]}]}]}]}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              // æ€§èƒ½ç›‘æ§\n              if (typeof window !== 'undefined') {\n                window.addEventListener('load', () => {\n                  if ('performance' in window) {\n                    const perfData = performance.getEntriesByType('navigation')[0];\n                    if (perfData) {\n                      console.log('é¡µé¢åŠ è½½æ€§èƒ½:', {\n                        'DOMå†…å®¹åŠ è½½': perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart + 'ms',\n                        'é¡µé¢å®Œå…¨åŠ è½½': perfData.loadEventEnd - perfData.loadEventStart + 'ms',\n                        'é¦–æ¬¡å†…å®¹ç»˜åˆ¶': performance.getEntriesByName('first-contentful-paint')[0]?.startTime + 'ms'\n                      });\n                    }\n                  }\n                });\n              }\n            "}}]]}]]}]],null],[["$","$L16",null,{}],[],[]]],["$L17",null]]]]
17:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"ğŸ® åå…­ä¸ªç»å…¸C++æ¸¸æˆé¡¹ç›®ï¼šæŠ€æœ¯åºŸæŸ´çš„æ¸¸æˆå¼€å‘å®æˆ˜ - LJoson çš„\"åºŸæŸ´\"å°çª | LJoson çš„\"åºŸæŸ´\"å°çª"}],["$","meta","3",{"name":"description","content":"ä»è´ªåƒè›‡åˆ°ä¿„ç½—æ–¯æ–¹å—ï¼Œä»é£æœºå¤§æˆ˜åˆ°è¿·å®«æ¢ç´¢ï¼Œåˆ†äº«æˆ‘åœ¨SFMLæ¸¸æˆå¼€å‘ä¸­çš„å®Œæ•´é¡¹ç›®ç»éªŒå’Œå®ç”¨æŠ€å·§ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨æ¸¸æˆå¼€å‘é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚"}],["$","meta","4",{"name":"author","content":"LJoson"}],["$","meta","5",{"name":"keywords","content":"æ¸¸æˆå¼€å‘, C++, SFML, å›¾å½¢ç¼–ç¨‹, æ¸¸æˆå¼•æ“, æŠ€æœ¯åºŸæŸ´, é¡¹ç›®å®æˆ˜, è·¨ç•Œæ¢ç´¢"}],["$","meta","6",{"name":"creator","content":"LJoson"}],["$","meta","7",{"name":"publisher","content":"LJoson"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","meta","10",{"name":"theme-color","content":"#ff6b6b"}],["$","meta","11",{"name":"color-scheme","content":"dark"}],["$","meta","12",{"name":"viewport-fit","content":"cover"}],["$","link","13",{"rel":"canonical","href":"https://ljoson.com/"}],["$","meta","14",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","15",{"name":"google-site-verification","content":"your-google-verification-code"}],["$","meta","16",{"property":"og:title","content":"ğŸ® åå…­ä¸ªç»å…¸C++æ¸¸æˆé¡¹ç›®ï¼šæŠ€æœ¯åºŸæŸ´çš„æ¸¸æˆå¼€å‘å®æˆ˜"}],["$","meta","17",{"property":"og:description","content":"ä»è´ªåƒè›‡åˆ°ä¿„ç½—æ–¯æ–¹å—ï¼Œä»é£æœºå¤§æˆ˜åˆ°è¿·å®«æ¢ç´¢ï¼Œåˆ†äº«æˆ‘åœ¨SFMLæ¸¸æˆå¼€å‘ä¸­çš„å®Œæ•´é¡¹ç›®ç»éªŒå’Œå®ç”¨æŠ€å·§ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨æ¸¸æˆå¼€å‘é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚"}],["$","meta","18",{"property":"og:image","content":"https://ljoson.com/api/og?title=%F0%9F%8E%AE%20%E5%8D%81%E5%85%AD%E4%B8%AA%E7%BB%8F%E5%85%B8C%2B%2B%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%8A%80%E6%9C%AF%E5%BA%9F%E6%9F%B4%E7%9A%84%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98&description=%E4%BB%8E%E8%B4%AA%E5%90%83%E8%9B%87%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%EF%BC%8C%E4%BB%8E%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%E5%88%B0%E8%BF%B7%E5%AE%AB%E6%8E%A2%E7%B4%A2%EF%BC%8C%E5%88%86%E4%BA%AB%E6%88%91%E5%9C%A8SFML%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E5%92%8C%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%AE%B0%E5%BD%95%E6%8A%80%E6%9C%AF%E5%BA%9F%E6%9F%B4%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%86%E5%9F%9F%E7%9A%84%E6%88%90%E9%95%BF%E8%BD%A8%E8%BF%B9%E3%80%82"}],["$","meta","19",{"property":"og:image:width","content":"1200"}],["$","meta","20",{"property":"og:image:height","content":"630"}],["$","meta","21",{"property":"og:image:alt","content":"ğŸ® åå…­ä¸ªç»å…¸C++æ¸¸æˆé¡¹ç›®ï¼šæŠ€æœ¯åºŸæŸ´çš„æ¸¸æˆå¼€å‘å®æˆ˜"}],["$","meta","22",{"property":"og:type","content":"article"}],["$","meta","23",{"property":"article:published_time","content":"2020-06-30"}],["$","meta","24",{"property":"article:author","content":"LJoson"}],["$","meta","25",{"property":"article:tag","content":"æ¸¸æˆå¼€å‘"}],["$","meta","26",{"property":"article:tag","content":"C++"}],["$","meta","27",{"property":"article:tag","content":"SFML"}],["$","meta","28",{"property":"article:tag","content":"å›¾å½¢ç¼–ç¨‹"}],["$","meta","29",{"property":"article:tag","content":"æ¸¸æˆå¼•æ“"}],["$","meta","30",{"property":"article:tag","content":"æŠ€æœ¯åºŸæŸ´"}],["$","meta","31",{"property":"article:tag","content":"é¡¹ç›®å®æˆ˜"}],["$","meta","32",{"property":"article:tag","content":"è·¨ç•Œæ¢ç´¢"}],["$","meta","33",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","34",{"name":"twitter:title","content":"ğŸ® åå…­ä¸ªç»å…¸C++æ¸¸æˆé¡¹ç›®ï¼šæŠ€æœ¯åºŸæŸ´çš„æ¸¸æˆå¼€å‘å®æˆ˜"}],["$","meta","35",{"name":"twitter:description","content":"ä»è´ªåƒè›‡åˆ°ä¿„ç½—æ–¯æ–¹å—ï¼Œä»é£æœºå¤§æˆ˜åˆ°è¿·å®«æ¢ç´¢ï¼Œåˆ†äº«æˆ‘åœ¨SFMLæ¸¸æˆå¼€å‘ä¸­çš„å®Œæ•´é¡¹ç›®ç»éªŒå’Œå®ç”¨æŠ€å·§ï¼Œè®°å½•æŠ€æœ¯åºŸæŸ´åœ¨æ¸¸æˆå¼€å‘é¢†åŸŸçš„æˆé•¿è½¨è¿¹ã€‚"}],["$","meta","36",{"name":"twitter:image","content":"https://ljoson.com/api/og?title=%F0%9F%8E%AE%20%E5%8D%81%E5%85%AD%E4%B8%AA%E7%BB%8F%E5%85%B8C%2B%2B%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%8A%80%E6%9C%AF%E5%BA%9F%E6%9F%B4%E7%9A%84%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98&description=%E4%BB%8E%E8%B4%AA%E5%90%83%E8%9B%87%E5%88%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%EF%BC%8C%E4%BB%8E%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%E5%88%B0%E8%BF%B7%E5%AE%AB%E6%8E%A2%E7%B4%A2%EF%BC%8C%E5%88%86%E4%BA%AB%E6%88%91%E5%9C%A8SFML%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E5%92%8C%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%AE%B0%E5%BD%95%E6%8A%80%E6%9C%AF%E5%BA%9F%E6%9F%B4%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E9%A2%86%E5%9F%9F%E7%9A%84%E6%88%90%E9%95%BF%E8%BD%A8%E8%BF%B9%E3%80%82"}]]
1:null
